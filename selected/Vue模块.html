<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Vue模块 | Frontend Starter</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.12353158.js"><link rel="modulepreload" href="/assets/Vue模块.html.a27ab950.js"><link rel="modulepreload" href="/assets/Vue模块.html.785747a6.js"><link rel="prefetch" href="/assets/index.html.ee998a26.js"><link rel="prefetch" href="/assets/CSS.html.c64e9431.js"><link rel="prefetch" href="/assets/HTML.html.a70e4433.js"><link rel="prefetch" href="/assets/HTTP.html.6dbdd949.js"><link rel="prefetch" href="/assets/JS基础.html.0a913d15.js"><link rel="prefetch" href="/assets/React.html.6802a56c.js"><link rel="prefetch" href="/assets/Vue.html.a81339b7.js"><link rel="prefetch" href="/assets/工程化.html.0c152696.js"><link rel="prefetch" href="/assets/性能.html.090fde92.js"><link rel="prefetch" href="/assets/框架通识.html.1a3f58ab.js"><link rel="prefetch" href="/assets/浏览器.html.2ec19a51.js"><link rel="prefetch" href="/assets/设计模式.html.5761cd54.js"><link rel="prefetch" href="/assets/Bootstrap.html.86ad9734.js"><link rel="prefetch" href="/assets/CSS.html.e3ee6176.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.6603dd61.js"><link rel="prefetch" href="/assets/JavaScript.html.14aca0a4.js"><link rel="prefetch" href="/assets/Webpack.html.f773c5e1.js"><link rel="prefetch" href="/assets/jQuery.html.c3b9972e.js"><link rel="prefetch" href="/assets/其他.html.c716f6ee.js"><link rel="prefetch" href="/assets/微信小程序.html.0335a142.js"><link rel="prefetch" href="/assets/综合.html.5dfe757e.js"><link rel="prefetch" href="/assets/编程题.html.cbfc1c8c.js"><link rel="prefetch" href="/assets/性能优化.html.30c3f1c5.js"><link rel="prefetch" href="/assets/高频考点.html.2ee4efd2.js"><link rel="prefetch" href="/assets/handwritten.html.879fcb5e.js"><link rel="prefetch" href="/assets/JavaScript.html.bcb5a0d9.js"><link rel="prefetch" href="/assets/Node.html.be9ed4e1.js"><link rel="prefetch" href="/assets/React.html.36beeb6b.js"><link rel="prefetch" href="/assets/Vue.html.b739e835.js"><link rel="prefetch" href="/assets/Webpack.html.b34fb870.js"><link rel="prefetch" href="/assets/综合.html.30e0bc70.js"><link rel="prefetch" href="/assets/CSS模块.html.99bd45d7.js"><link rel="prefetch" href="/assets/ES6模块.html.0f2bfddb.js"><link rel="prefetch" href="/assets/HTML模块.html.4fb65265.js"><link rel="prefetch" href="/assets/HTTP模块.html.b4ce19f7.js"><link rel="prefetch" href="/assets/JS模块.html.015ff251.js"><link rel="prefetch" href="/assets/Node模块.html.b1985276.js"><link rel="prefetch" href="/assets/React模块.html.f53e1f03.js"><link rel="prefetch" href="/assets/前端安全模块.html.f0f98ff3.js"><link rel="prefetch" href="/assets/前端工程相关.html.183e2c9f.js"><link rel="prefetch" href="/assets/小程序模块.html.f7ab4d91.js"><link rel="prefetch" href="/assets/常用设计模式.html.03f9722f.js"><link rel="prefetch" href="/assets/性能优化相关.html.12e8a2e3.js"><link rel="prefetch" href="/assets/排序算法.html.40481e91.js"><link rel="prefetch" href="/assets/框架通识.html.c3c3096b.js"><link rel="prefetch" href="/assets/浏览器模块.html.24652566.js"><link rel="prefetch" href="/assets/移动多端开发.html.8636371c.js"><link rel="prefetch" href="/assets/计算机通识.html.728b7ceb.js"><link rel="prefetch" href="/assets/404.html.93c18560.js"><link rel="prefetch" href="/assets/index.html.60500264.js"><link rel="prefetch" href="/assets/CSS.html.02fa634c.js"><link rel="prefetch" href="/assets/HTML.html.3a31cd64.js"><link rel="prefetch" href="/assets/HTTP.html.a1df6d3a.js"><link rel="prefetch" href="/assets/JS基础.html.b88ab559.js"><link rel="prefetch" href="/assets/React.html.4ec983c7.js"><link rel="prefetch" href="/assets/Vue.html.5c58cab9.js"><link rel="prefetch" href="/assets/工程化.html.863e35db.js"><link rel="prefetch" href="/assets/性能.html.470e0a6f.js"><link rel="prefetch" href="/assets/框架通识.html.32d2fbab.js"><link rel="prefetch" href="/assets/浏览器.html.8279ebd9.js"><link rel="prefetch" href="/assets/设计模式.html.6afe6cf3.js"><link rel="prefetch" href="/assets/Bootstrap.html.2cc414a0.js"><link rel="prefetch" href="/assets/CSS.html.5d66e791.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.bbea8927.js"><link rel="prefetch" href="/assets/JavaScript.html.07acfd24.js"><link rel="prefetch" href="/assets/Webpack.html.a1c5dce1.js"><link rel="prefetch" href="/assets/jQuery.html.4e2f3899.js"><link rel="prefetch" href="/assets/其他.html.929587e1.js"><link rel="prefetch" href="/assets/微信小程序.html.69cc86fd.js"><link rel="prefetch" href="/assets/综合.html.1c892aa5.js"><link rel="prefetch" href="/assets/编程题.html.5478af99.js"><link rel="prefetch" href="/assets/性能优化.html.337c4654.js"><link rel="prefetch" href="/assets/高频考点.html.8772c401.js"><link rel="prefetch" href="/assets/handwritten.html.0f0ee7e3.js"><link rel="prefetch" href="/assets/JavaScript.html.5dd72bd0.js"><link rel="prefetch" href="/assets/Node.html.7eac5124.js"><link rel="prefetch" href="/assets/React.html.d8ccb952.js"><link rel="prefetch" href="/assets/Vue.html.47efbab1.js"><link rel="prefetch" href="/assets/Webpack.html.793df544.js"><link rel="prefetch" href="/assets/综合.html.ff78888d.js"><link rel="prefetch" href="/assets/CSS模块.html.bcc3cfc7.js"><link rel="prefetch" href="/assets/ES6模块.html.2ea3507a.js"><link rel="prefetch" href="/assets/HTML模块.html.6b729342.js"><link rel="prefetch" href="/assets/HTTP模块.html.2c6adffa.js"><link rel="prefetch" href="/assets/JS模块.html.28259fe6.js"><link rel="prefetch" href="/assets/Node模块.html.c36cd1fb.js"><link rel="prefetch" href="/assets/React模块.html.b09a5954.js"><link rel="prefetch" href="/assets/前端安全模块.html.e3aebe2f.js"><link rel="prefetch" href="/assets/前端工程相关.html.281b6ffe.js"><link rel="prefetch" href="/assets/小程序模块.html.493268db.js"><link rel="prefetch" href="/assets/常用设计模式.html.a600f326.js"><link rel="prefetch" href="/assets/性能优化相关.html.aff23982.js"><link rel="prefetch" href="/assets/排序算法.html.361967d5.js"><link rel="prefetch" href="/assets/框架通识.html.7719e539.js"><link rel="prefetch" href="/assets/浏览器模块.html.ac4e495d.js"><link rel="prefetch" href="/assets/移动多端开发.html.d8fc5993.js"><link rel="prefetch" href="/assets/计算机通识.html.0e8ab127.js"><link rel="prefetch" href="/assets/404.html.232c3875.js"><link rel="prefetch" href="/assets/404.176778df.js"><link rel="prefetch" href="/assets/Layout.ac3a6e88.js">
    <link rel="stylesheet" href="/assets/style.20e644be.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Frontend Starter</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">基础 Basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/basic/HTTP%20&amp;%20HTML.html" class="sidebar-item" aria-label="HTML、HTTP、Web"><!--[--><!--]--> HTML、HTTP、Web <!--[--><!--]--></a><!----></li><li><a href="/basic/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/basic/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/basic/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/basic/Bootstrap.html" class="sidebar-item" aria-label="Bootstrap"><!--[--><!--]--> Bootstrap <!--[--><!--]--></a><!----></li><li><a href="/basic/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BC%96%E7%A8%8B%E9%A2%98.html" class="sidebar-item" aria-label="编程题"><!--[--><!--]--> 编程题 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%85%B6%E4%BB%96.html" class="sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">进阶 Advanced <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/advanced/JS%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/advanced/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%B5%8F%E8%A7%88%E5%99%A8.html" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/advanced/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/advanced/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%80%A7%E8%83%BD.html" class="sidebar-item" aria-label="性能"><!--[--><!--]--> 性能 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="sidebar-item" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">精选 Selected <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/selected/HTML%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTML模块"><!--[--><!--]--> HTML模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/CSS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="CSS模块"><!--[--><!--]--> CSS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/JS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="JS模块"><!--[--><!--]--> JS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/ES6%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="ES6模块"><!--[--><!--]--> ES6模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="浏览器模块"><!--[--><!--]--> 浏览器模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/React%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="React模块"><!--[--><!--]--> React模块 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Vue模块"><!--[--><!--]--> Vue模块 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_1-对于mvvm的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 对于MVVM的理解"><!--[--><!--]--> 1 对于MVVM的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_2-请详细说下你对vue生命周期的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 请详细说下你对vue生命周期的理解"><!--[--><!--]--> 2 请详细说下你对vue生命周期的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_3-vue实现数据双向绑定的原理-object-defineproperty" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 Vue实现数据双向绑定的原理：Object.defineProperty()"><!--[--><!--]--> 3 Vue实现数据双向绑定的原理：Object.defineProperty() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_4-vue组件间的参数传递" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 Vue组件间的参数传递"><!--[--><!--]--> 4 Vue组件间的参数传递 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_5-vue的路由实现-hash模式-和-history模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 Vue的路由实现：hash模式 和 history模式"><!--[--><!--]--> 5 Vue的路由实现：hash模式 和 history模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_5-vue路由的钩子函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 vue路由的钩子函数"><!--[--><!--]--> 5 vue路由的钩子函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_6-vuex是什么-怎么使用-哪种功能场景使用它" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 vuex是什么？怎么使用？哪种功能场景使用它？"><!--[--><!--]--> 6 vuex是什么？怎么使用？哪种功能场景使用它？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_7-v-if-和-v-show-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="7 v-if 和 v-show 区别"><!--[--><!--]--> 7 v-if 和 v-show 区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_8-route和-router的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="8$route和$router的区别"><!--[--><!--]--> 8$route和$router的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_9-如何让css只在当前组件中起作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="9 如何让CSS只在当前组件中起作用?"><!--[--><!--]--> 9 如何让CSS只在当前组件中起作用? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_10-keep-alive-keep-alive-的作用是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="10&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么?"><!--[--><!--]--> 10&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_11-指令v-el的作用是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="11 指令v-el的作用是什么?"><!--[--><!--]--> 11 指令v-el的作用是什么? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_12-在vue中使用插件的步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="12 在Vue中使用插件的步骤"><!--[--><!--]--> 12 在Vue中使用插件的步骤 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_13-请列举出3个vue中常用的生命周期钩子函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="13 请列举出3个Vue中常用的生命周期钩子函数?"><!--[--><!--]--> 13 请列举出3个Vue中常用的生命周期钩子函数? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_14-vue-cli-工程技术集合介绍" class="router-link-active router-link-exact-active sidebar-item" aria-label="14 vue-cli 工程技术集合介绍"><!--[--><!--]--> 14 vue-cli 工程技术集合介绍 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_15-nexttick" class="router-link-active router-link-exact-active sidebar-item" aria-label="15 NextTick"><!--[--><!--]--> 15 NextTick <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_16-vue的优点是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="16 vue的优点是什么？"><!--[--><!--]--> 16 vue的优点是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_17-路由之间跳转" class="router-link-active router-link-exact-active sidebar-item" aria-label="17 路由之间跳转？"><!--[--><!--]--> 17 路由之间跳转？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_18-实现-vue-ssr" class="router-link-active router-link-exact-active sidebar-item" aria-label="18 实现 Vue SSR"><!--[--><!--]--> 18 实现 Vue SSR <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_19-vue-组件-data-为什么必须是函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="19 Vue 组件 data 为什么必须是函数"><!--[--><!--]--> 19 Vue 组件 data 为什么必须是函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_20-vue-computed-实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="20 Vue computed 实现"><!--[--><!--]--> 20 Vue computed 实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_21-vue-complier-实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="21 Vue complier 实现"><!--[--><!--]--> 21 Vue complier 实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_22-怎么快速定位哪个组件出现性能问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="22 怎么快速定位哪个组件出现性能问题"><!--[--><!--]--> 22 怎么快速定位哪个组件出现性能问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_23-开发中常用的指令有哪些" class="router-link-active router-link-exact-active sidebar-item" aria-label="23 开发中常用的指令有哪些"><!--[--><!--]--> 23 开发中常用的指令有哪些 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_24-proxy-相比于-defineproperty-的优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="24 Proxy 相比于 defineProperty 的优势"><!--[--><!--]--> 24 Proxy 相比于 defineProperty 的优势 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_25-vue-router-有哪几种导航守卫" class="router-link-active router-link-exact-active sidebar-item" aria-label="25 vue-router 有哪几种导航守卫?"><!--[--><!--]--> 25 vue-router 有哪几种导航守卫? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_26-组件之间的传值通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="26 组件之间的传值通信"><!--[--><!--]--> 26 组件之间的传值通信 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_27-vue与angular以及react的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="27 Vue与Angular以及React的区别？"><!--[--><!--]--> 27 Vue与Angular以及React的区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_28-vuex是什么-怎么使用-哪种功能场景使用它" class="router-link-active router-link-exact-active sidebar-item" aria-label="28 vuex是什么？怎么使用？哪种功能场景使用它？"><!--[--><!--]--> 28 vuex是什么？怎么使用？哪种功能场景使用它？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_28-watch与computed的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="28 watch与computed的区别"><!--[--><!--]--> 28 watch与computed的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_29、vue是如何实现双向绑定的" class="router-link-active router-link-exact-active sidebar-item" aria-label="29、Vue是如何实现双向绑定的?"><!--[--><!--]--> 29、Vue是如何实现双向绑定的? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_29-vue2-x-响应式原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="29 Vue2.x 响应式原理"><!--[--><!--]--> 29 Vue2.x 响应式原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_30-v-model双向绑定原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="30 v-model双向绑定原理"><!--[--><!--]--> 30 v-model双向绑定原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_31-scoped样式穿透" class="router-link-active router-link-exact-active sidebar-item" aria-label="31 scoped样式穿透"><!--[--><!--]--> 31 scoped样式穿透 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_32-ref的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="32 ref的作用"><!--[--><!--]--> 32 ref的作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_33-computed和watch区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="33 computed和watch区别"><!--[--><!--]--> 33 computed和watch区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_34-vue-router守卫" class="router-link-active router-link-exact-active sidebar-item" aria-label="34 vue-router守卫"><!--[--><!--]--> 34 vue-router守卫 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_35-vue修饰符" class="router-link-active router-link-exact-active sidebar-item" aria-label="35 vue修饰符"><!--[--><!--]--> 35 vue修饰符 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_36-vue项目中的性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="36 vue项目中的性能优化"><!--[--><!--]--> 36 vue项目中的性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_37-vue-extend和vue-component" class="router-link-active router-link-exact-active sidebar-item" aria-label="37 vue.extend和vue.component"><!--[--><!--]--> 37 vue.extend和vue.component <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_38-vue的spa-如何优化加载速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="38 Vue的SPA 如何优化加载速度"><!--[--><!--]--> 38 Vue的SPA 如何优化加载速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_39-移动端如何设计一个比较友好的header组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="39 移动端如何设计一个比较友好的Header组件？"><!--[--><!--]--> 39 移动端如何设计一个比较友好的Header组件？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_40-proxy与object-defineproperty的优劣对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="40 Proxy与Object.defineProperty的优劣对比?"><!--[--><!--]--> 40 Proxy与Object.defineProperty的优劣对比? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_41-你是如何理解vue的响应式系统的" class="router-link-active router-link-exact-active sidebar-item" aria-label="41 你是如何理解Vue的响应式系统的?"><!--[--><!--]--> 41 你是如何理解Vue的响应式系统的? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异" class="router-link-active router-link-exact-active sidebar-item" aria-label="42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?"><!--[--><!--]--> 42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？"><!--[--><!--]--> 43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_44-vue中的key到底有什么用" class="router-link-active router-link-exact-active sidebar-item" aria-label="44 Vue中的key到底有什么用？"><!--[--><!--]--> 44 Vue中的key到底有什么用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_45-vue-项目性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="45 vue 项目性能优化"><!--[--><!--]--> 45 vue 项目性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_46-nexttick" class="router-link-active router-link-exact-active sidebar-item" aria-label="46 nextTick"><!--[--><!--]--> 46 nextTick <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_47-说一下vue2-x中如何监测数组变化" class="router-link-active router-link-exact-active sidebar-item" aria-label="47 说一下vue2.x中如何监测数组变化"><!--[--><!--]--> 47 说一下vue2.x中如何监测数组变化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_48-你的接口请求一般放在哪个生命周期中" class="router-link-active router-link-exact-active sidebar-item" aria-label="48 你的接口请求一般放在哪个生命周期中"><!--[--><!--]--> 48 你的接口请求一般放在哪个生命周期中 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_49-组件中的data为什么是一个函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="49 组件中的data为什么是一个函数"><!--[--><!--]--> 49 组件中的data为什么是一个函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_50-说一下v-model的原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="50 说一下v-model的原理"><!--[--><!--]--> 50 说一下v-model的原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_51-vue事件绑定原理说一下" class="router-link-active router-link-exact-active sidebar-item" aria-label="51 Vue事件绑定原理说一下"><!--[--><!--]--> 51 Vue事件绑定原理说一下 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_52-vue模版编译原理知道吗-能简单说一下吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="52 Vue模版编译原理知道吗，能简单说一下吗？"><!--[--><!--]--> 52 Vue模版编译原理知道吗，能简单说一下吗？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_53-vue2-x和vue3-x渲染器的diff算法分别说一下" class="router-link-active router-link-exact-active sidebar-item" aria-label="53 Vue2.x和Vue3.x渲染器的diff算法分别说一下"><!--[--><!--]--> 53 Vue2.x和Vue3.x渲染器的diff算法分别说一下 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_54-再说一下虚拟dom以及key属性的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="54 再说一下虚拟Dom以及key属性的作用"><!--[--><!--]--> 54 再说一下虚拟Dom以及key属性的作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_55-vue中组件生命周期调用顺序说一下" class="router-link-active router-link-exact-active sidebar-item" aria-label="55 Vue中组件生命周期调用顺序说一下"><!--[--><!--]--> 55 Vue中组件生命周期调用顺序说一下 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_56-ssr了解吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="56 SSR了解吗"><!--[--><!--]--> 56 SSR了解吗 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_57-你都做过哪些vue的性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="57 你都做过哪些Vue的性能优化"><!--[--><!--]--> 57 你都做过哪些Vue的性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_58-vue-js特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="58 Vue.js特点"><!--[--><!--]--> 58 Vue.js特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_59-请说出vue-cli项目中src目录每个文件夹和文件的用法" class="router-link-active router-link-exact-active sidebar-item" aria-label="59 请说出vue.cli项目中src目录每个文件夹和文件的用法"><!--[--><!--]--> 59 请说出vue.cli项目中src目录每个文件夹和文件的用法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_60-vue路由传参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="60 vue路由传参数"><!--[--><!--]--> 60 vue路由传参数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_61-vuex-是什么-有哪几种属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="61 vuex 是什么？ 有哪几种属性？"><!--[--><!--]--> 61 vuex 是什么？ 有哪几种属性？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_62-如何让css只在当前组件中起作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="62 如何让CSS只在当前组件中起作用？"><!--[--><!--]--> 62 如何让CSS只在当前组件中起作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_63-delete和vue-delete删除数组的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="63 delete和Vue.delete删除数组的区别？"><!--[--><!--]--> 63 delete和Vue.delete删除数组的区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_64-v-on可以监听多个方法吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="64 v-on可以监听多个方法吗？"><!--[--><!--]--> 64 v-on可以监听多个方法吗？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_65-vue子组件调用父组件的方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="65 Vue子组件调用父组件的方法"><!--[--><!--]--> 65 Vue子组件调用父组件的方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_66-vue如何兼容ie的问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="66 vue如何兼容ie的问题"><!--[--><!--]--> 66 vue如何兼容ie的问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_67-vue-改变数组触发视图更新" class="router-link-active router-link-exact-active sidebar-item" aria-label="67 Vue 改变数组触发视图更新"><!--[--><!--]--> 67 Vue 改变数组触发视图更新 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_68-dom-渲染在哪个周期中就已经完成" class="router-link-active router-link-exact-active sidebar-item" aria-label="68 DOM 渲染在哪个周期中就已经完成？"><!--[--><!--]--> 68 DOM 渲染在哪个周期中就已经完成？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_69-简述每个周期具体适合哪些场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="69 简述每个周期具体适合哪些场景"><!--[--><!--]--> 69 简述每个周期具体适合哪些场景 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_70-动态绑定class" class="router-link-active router-link-exact-active sidebar-item" aria-label="70 动态绑定class"><!--[--><!--]--> 70 动态绑定class <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_71-vue3-0-是如何变得更快的" class="router-link-active router-link-exact-active sidebar-item" aria-label="71 Vue3.0 是如何变得更快的"><!--[--><!--]--> 71 Vue3.0 是如何变得更快的 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#diff-方法优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="diff 方法优化"><!--[--><!--]--> diff 方法优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#hoiststatic-静态提升" class="router-link-active router-link-exact-active sidebar-item" aria-label="hoistStatic 静态提升"><!--[--><!--]--> hoistStatic 静态提升 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#cachehandlers-事件侦听器缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="cacheHandlers 事件侦听器缓存"><!--[--><!--]--> cacheHandlers 事件侦听器缓存 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_72-说说你对-proxy-的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="72 说说你对 proxy 的理解"><!--[--><!--]--> 72 说说你对 proxy 的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_73-生命周期详解" class="router-link-active router-link-exact-active sidebar-item" aria-label="73 生命周期详解"><!--[--><!--]--> 73 生命周期详解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_74-proxy-相比于-defineproperty-的优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="74 Proxy 相比于 defineProperty 的优势"><!--[--><!--]--> 74 Proxy 相比于 defineProperty 的优势 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_75-vue-router" class="router-link-active router-link-exact-active sidebar-item" aria-label="75 vue-router"><!--[--><!--]--> 75 vue-router <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_76-vuex总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="76 vuex总结"><!--[--><!--]--> 76 vuex总结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_77-diff-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="77 diff 算法"><!--[--><!--]--> 77 diff 算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_78-vue-的响应式原理中-object-defineproperty-有什么缺陷" class="router-link-active router-link-exact-active sidebar-item" aria-label="78 Vue 的响应式原理中 Object.defineProperty 有什么缺陷"><!--[--><!--]--> 78 Vue 的响应式原理中 Object.defineProperty 有什么缺陷 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_79-composition-api" class="router-link-active router-link-exact-active sidebar-item" aria-label="79 Composition API"><!--[--><!--]--> 79 Composition API <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_80-vue中是如何检测数组变化的呢" class="router-link-active router-link-exact-active sidebar-item" aria-label="80 vue中是如何检测数组变化的呢"><!--[--><!--]--> 80 vue中是如何检测数组变化的呢 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_81-vue的事件绑定原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="81 Vue的事件绑定原理"><!--[--><!--]--> 81 Vue的事件绑定原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_82-v-model中的实现原理及如何自定义v-model" class="router-link-active router-link-exact-active sidebar-item" aria-label="82 v-model中的实现原理及如何自定义v-model"><!--[--><!--]--> 82 v-model中的实现原理及如何自定义v-model <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_83-为什么vue采用异步渲染呢" class="router-link-active router-link-exact-active sidebar-item" aria-label="83 为什么Vue采用异步渲染呢"><!--[--><!--]--> 83 为什么Vue采用异步渲染呢 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_84-vuex-工作原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="84 Vuex 工作原理"><!--[--><!--]--> 84 Vuex 工作原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_85-如何从真实dom到虚拟dom" class="router-link-active router-link-exact-active sidebar-item" aria-label="85 如何从真实DOM到虚拟DOM"><!--[--><!--]--> 85 如何从真实DOM到虚拟DOM <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_86-computed-watch-和-method" class="router-link-active router-link-exact-active sidebar-item" aria-label="86 Computed watch 和 method"><!--[--><!--]--> 86 Computed watch 和 method <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_87-为什么要使用异步组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="87 为什么要使用异步组件？"><!--[--><!--]--> 87 为什么要使用异步组件？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_88-action-与-mutation-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="88 action 与 mutation 的区别"><!--[--><!--]--> 88 action 与 mutation 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_89-插槽与作用域插槽的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="89 插槽与作用域插槽的区别"><!--[--><!--]--> 89 插槽与作用域插槽的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_90-vue中相同逻辑如何抽离" class="router-link-active router-link-exact-active sidebar-item" aria-label="90 vue中相同逻辑如何抽离"><!--[--><!--]--> 90 vue中相同逻辑如何抽离 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_91-谈谈对keep-alive的了解" class="router-link-active router-link-exact-active sidebar-item" aria-label="91 谈谈对keep-alive的了解"><!--[--><!--]--> 91 谈谈对keep-alive的了解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_92-vue性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="92 Vue性能优化"><!--[--><!--]--> 92 Vue性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_93-vue3-0相对于vue2-x有哪些不同" class="router-link-active router-link-exact-active sidebar-item" aria-label="93 Vue3.0相对于Vue2.x有哪些不同？"><!--[--><!--]--> 93 Vue3.0相对于Vue2.x有哪些不同？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_94-vue中hash模式和history模式的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="94 Vue中hash模式和history模式的区别"><!--[--><!--]--> 94 Vue中hash模式和history模式的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_95-了解history有哪些方法吗-说下它们的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="95 了解history有哪些方法吗？说下它们的区别"><!--[--><!--]--> 95 了解history有哪些方法吗？说下它们的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_96-如何监听-pushstate-和-replacestate-的变化呢" class="router-link-active router-link-exact-active sidebar-item" aria-label="96 如何监听 pushState 和 replaceState 的变化呢？"><!--[--><!--]--> 96 如何监听 pushState 和 replaceState 的变化呢？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_97-vue组件内的导航守卫有哪几个" class="router-link-active router-link-exact-active sidebar-item" aria-label="97 Vue组件内的导航守卫有哪几个？"><!--[--><!--]--> 97 Vue组件内的导航守卫有哪几个？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_98-beforerouteenter和另外两个有什么不同吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="98 beforeRouteEnter和另外两个有什么不同吗？"><!--[--><!--]--> 98 beforeRouteEnter和另外两个有什么不同吗？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_99-完整的导航解析流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="99 完整的导航解析流程"><!--[--><!--]--> 99 完整的导航解析流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/Vue%E6%A8%A1%E5%9D%97.html#_100-你是怎么看vue和react的" class="router-link-active router-link-exact-active sidebar-item" aria-label="100 你是怎么看Vue和React的？"><!--[--><!--]--> 100 你是怎么看Vue和React的？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/selected/Node%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Node模块"><!--[--><!--]--> Node模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="前端工程相关"><!--[--><!--]--> 前端工程相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="移动多端开发"><!--[--><!--]--> 移动多端开发 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="小程序模块"><!--[--><!--]--> 小程序模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="前端安全模块"><!--[--><!--]--> 前端安全模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="性能优化相关"><!--[--><!--]--> 性能优化相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/HTTP%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTTP模块"><!--[--><!--]--> HTTP模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="常用设计模式"><!--[--><!--]--> 常用设计模式 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="计算机通识"><!--[--><!--]--> 计算机通识 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">高频 Frequency <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/frequency/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" class="sidebar-item" aria-label="高频考点"><!--[--><!--]--> 高频考点 <!--[--><!--]--></a><!----></li><li><a href="/frequency/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">原理 Principle <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/principle/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/principle/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/principle/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/principle/Node.html" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><li><a href="/principle/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/principle/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="vue模块" tabindex="-1"><a class="header-anchor" href="#vue模块" aria-hidden="true">#</a> Vue模块</h1><hr><h2 id="_1-对于mvvm的理解" tabindex="-1"><a class="header-anchor" href="#_1-对于mvvm的理解" aria-hidden="true">#</a> 1 对于MVVM的理解</h2><blockquote><p><code>MVVM</code>是<code>Model-View-ViewModel</code>缩写，也就是把MVC中的Controller演变成<code>ViewModel</code>。Model层代表数据模型，<code>View</code>代表UI组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p></blockquote><ul><li><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写</li><li><code>Model</code>: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为</li><li><code>View</code>: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View</li><li><code>ViewModel</code>： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.</li><li>总结： <code>MVVM</code>模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，<code>ViewModel</code> 会自动更新，而 <code>ViewModel</code> 变化时，View 也会自动变化。</li></ul><h2 id="_2-请详细说下你对vue生命周期的理解" tabindex="-1"><a class="header-anchor" href="#_2-请详细说下你对vue生命周期的理解" aria-hidden="true">#</a> 2 请详细说下你对vue生命周期的理解</h2><blockquote><p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote><p>生命周期是什么</p><blockquote><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期</p></blockquote><p>各个生命周期的作用</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activated</td><td>keep-alive专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive专属，组件被销毁时调用</td></tr><tr><td>beforeDestroy</td><td>组件销毁前调用</td></tr><tr><td>destroyed</td><td>组件销毁后调用</td></tr></tbody></table><p><img src="/assets/61.418ba127.png" alt=""></p><blockquote><p>由于Vue会在初始化实例时对属性执行<code>getter/setter</code>转化，所以属性必须在<code>data</code>对象上存在才能让<code>Vue</code>将它转换为响应式的。Vue提供了<code>$set</code>方法用来触发视图更新</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>export default {
    data(){
        return {
            obj: {
                name: &#39;fei&#39;
            }
        }
    },
    mounted(){
        this.$set(this.obj, &#39;sex&#39;, &#39;man&#39;)
    }

}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>什么是vue生命周期？</p><ul><li>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li></ul><p>vue生命周期的作用是什么？</p><ul><li>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</li></ul><p>vue生命周期总共有几个阶段？</p><ul><li>答：它可以总共分为<code>8</code>个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。</li></ul><p>第一次页面加载会触发哪几个钩子？</p><ul><li>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 。</li></ul><p>DOM 渲染在哪个周期中就已经完成？</p><ul><li>答：<code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了</li></ul><h2 id="_3-vue实现数据双向绑定的原理-object-defineproperty" tabindex="-1"><a class="header-anchor" href="#_3-vue实现数据双向绑定的原理-object-defineproperty" aria-hidden="true">#</a> 3 Vue实现数据双向绑定的原理：Object.defineProperty()</h2><ul><li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 <code>data</code> 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty()</code> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 <code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li><li>vue的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>{{}}</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 ---&gt;视图更新；视图交互变化（<code>input</code>）---&gt;数据<code>model</code>变更双向绑定效果。</li></ul><h2 id="_4-vue组件间的参数传递" tabindex="-1"><a class="header-anchor" href="#_4-vue组件间的参数传递" aria-hidden="true">#</a> 4 Vue组件间的参数传递</h2><p>父组件与子组件传值</p><blockquote><p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p></blockquote><ul><li>子组件传给父组件： <code>$emit</code> 方法传递参数</li></ul><p>非父子组件间的数据传递，兄弟组件传值</p><blockquote><p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用<code>VUEX</code>，具体来说看需求）</p></blockquote><h2 id="_5-vue的路由实现-hash模式-和-history模式" tabindex="-1"><a class="header-anchor" href="#_5-vue的路由实现-hash模式-和-history模式" aria-hidden="true">#</a> 5 Vue的路由实现：hash模式 和 history模式</h2><ul><li><code>hash</code>模式：在浏览器中符号<code>&quot;#&quot;</code>，#以及#后面的字符称之为<code>hash</code>，用 <code>window.location.hash</code> 读取。特点：<code>hash</code>虽然在<code>URL</code>中，但不被包括在<code>HTTP</code>请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。</li><li><code>history</code>模式：h<code>istory</code>采用<code>HTML5</code>的新特性；且提供了两个新方法： <code>pushState()</code>， <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更</li></ul><h2 id="_5-vue路由的钩子函数" tabindex="-1"><a class="header-anchor" href="#_5-vue路由的钩子函数" aria-hidden="true">#</a> 5 vue路由的钩子函数</h2><blockquote><p>首页可以控制导航跳转，<code>beforeEach</code>，<code>afterEach</code>等，一般用于页面<code>title</code>的修改。一些需要登录才能调整页面的重定向功能。</p></blockquote><ul><li><code>beforeEach</code>主要有3个参数<code>to</code>，<code>from</code>，<code>next</code>。</li><li><code>to</code>：<code>route</code>即将进入的目标路由对象。</li><li><code>from</code>：<code>route</code>当前导航正要离开的路由。</li><li><code>next</code>：<code>function</code>一定要调用该方法<code>resolve</code>这个钩子。执行效果依赖n<code>ext</code>方法的调用参数。可以控制网页的跳转</li></ul><h2 id="_6-vuex是什么-怎么使用-哪种功能场景使用它" tabindex="-1"><a class="header-anchor" href="#_6-vuex是什么-怎么使用-哪种功能场景使用它" aria-hidden="true">#</a> 6 vuex是什么？怎么使用？哪种功能场景使用它？</h2><ul><li>只用来读取的状态集中放在<code>store</code>中； 改变状态的方式是提交<code>mutations</code>，这是个同步的事物； 异步逻辑应该封装在<code>action</code>中。</li><li>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>... export</code></li><li>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li></ul><p><img src="/assets/62.7becc057.png" alt=""></p><ul><li><code>state</code>：<code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个<code>store</code> 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li><li><code>mutations</code>：<code>mutations</code>定义的方法动态修改<code>Vuex</code> 的 <code>store</code> 中的状态或数据</li><li><code>getters</code>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</li><li><code>action</code>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code> 层通过 <code>store.dispath</code> 来分发 <code>action</code></li></ul><p><img src="/assets/63.821b9611.png" alt=""></p><blockquote><p><code>modules</code>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理</p></blockquote><p><img src="/assets/64.f13ebd26.png" alt=""></p><h2 id="_7-v-if-和-v-show-区别" tabindex="-1"><a class="header-anchor" href="#_7-v-if-和-v-show-区别" aria-hidden="true">#</a> 7 v-if 和 v-show 区别</h2><ul><li>答：<code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code>；</li></ul><h2 id="_8-route和-router的区别" tabindex="-1"><a class="header-anchor" href="#_8-route和-router的区别" aria-hidden="true">#</a> 8<code>$route</code>和<code>$router</code>的区别</h2><ul><li><code>$route</code>是&quot;路由信息对象&quot;，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li><li>而<code>$router</code>是&quot;路由实例&quot;对象包括了路由的跳转方法，钩子函数等</li></ul><h2 id="_9-如何让css只在当前组件中起作用" tabindex="-1"><a class="header-anchor" href="#_9-如何让css只在当前组件中起作用" aria-hidden="true">#</a> 9 如何让CSS只在当前组件中起作用?</h2><blockquote><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p></blockquote><h2 id="_10-keep-alive-keep-alive-的作用是什么" tabindex="-1"><a class="header-anchor" href="#_10-keep-alive-keep-alive-的作用是什么" aria-hidden="true">#</a> 10<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的作用是什么?</h2><blockquote><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p></blockquote><ul><li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染</li></ul><blockquote><p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情...这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p></blockquote><ul><li>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存</li><li>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态</li></ul><h2 id="_11-指令v-el的作用是什么" tabindex="-1"><a class="header-anchor" href="#_11-指令v-el的作用是什么" aria-hidden="true">#</a> 11 指令v-el的作用是什么?</h2><blockquote><p>提供一个在页面上已存在的 <code>DOM</code>元素作为 <code>Vue</code>实例的挂载目标.可以是 CSS 选择器，也可以是一个 <code>HTMLElement</code> 实例,</p></blockquote><h2 id="_12-在vue中使用插件的步骤" tabindex="-1"><a class="header-anchor" href="#_12-在vue中使用插件的步骤" aria-hidden="true">#</a> 12 在Vue中使用插件的步骤</h2><ul><li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li><li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, { someOption: true })</code></li></ul><h2 id="_13-请列举出3个vue中常用的生命周期钩子函数" tabindex="-1"><a class="header-anchor" href="#_13-请列举出3个vue中常用的生命周期钩子函数" aria-hidden="true">#</a> 13 请列举出3个Vue中常用的生命周期钩子函数?</h2><ul><li><code>created</code>: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, <code>watch/event</code>事件回调. 然而, 挂载阶段还没有开始, <code>$el</code>属性目前还不可见</li><li><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code>被调用时 <code>vm.$el</code> 也在文档内。</li><li><code>activated</code>: <code>keep-alive</code>组件激活时调用</li></ul><h2 id="_14-vue-cli-工程技术集合介绍" tabindex="-1"><a class="header-anchor" href="#_14-vue-cli-工程技术集合介绍" aria-hidden="true">#</a> 14 vue-cli 工程技术集合介绍</h2><p>问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</p><ul><li><code>vue.js</code>：<code>vue-cli</code>工程的核心，主要特点是 双向数据绑定 和 组件系统。</li><li><code>vue-router</code>：<code>vue</code>官方推荐使用的路由框架。</li><li><code>vuex</code>：专为 <code>Vue.js</code> 应用项目开发的状态管理器，主要用于维护<code>vue</code>组件间共用的一些 变量 和 方法。</li><li><code>axios</code>（ 或者 <code>fetch</code> 、<code>ajax</code> ）：用于发起 <code>GET</code> 、或 <code>POST</code> 等 <code>http</code>请求，基于 <code>Promise</code> 设计。</li><li><code>vuex</code>等：一个专为<code>vue</code>设计的移动端UI组件库。</li><li>创建一个<code>emit.js</code>文件，用于<code>vue</code>事件机制的管理。</li><li><code>webpack</code>：模块加载和<code>vue-cli</code>工程打包器。</li></ul><p>问题二：vue-cli 工程常用的 npm 命令有哪些？</p><ul><li>下载 <code>node_modules</code> 资源包的命令：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>npm install

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>启动 <code>vue-cli</code> 开发环境的 npm命令：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>npm run dev

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>vue-cli</code> 生成 生产环境部署资源 的 <code>npm</code>命令：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>npm run build

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>用于查看 <code>vue-cli</code> 生产环境部署资源文件大小的 <code>npm</code>命令：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>npm run build --report

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在浏览器上自动弹出一个 展示 <code>vue-cli</code> 工程打包后 <code>app.js</code>、<code>manifest.js</code>、<code>vendor.js</code> 文件里面所包含代码的页面。可以具此优化 <code>vue-cli</code> 生产环境部署的静态资源，提升 页面 的加载速度</p></blockquote><h2 id="_15-nexttick" tabindex="-1"><a class="header-anchor" href="#_15-nexttick" aria-hidden="true">#</a> 15 NextTick</h2><blockquote><p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p></blockquote><ul><li>新版本中默认是<code>mincrotasks</code>, <code>v-on</code>中会使用<code>macrotasks</code></li><li><code>macrotasks</code>任务的实现: <ul><li><code>setImmediate / MessageChannel / setTimeout</code></li></ul></li></ul><h2 id="_16-vue的优点是什么" tabindex="-1"><a class="header-anchor" href="#_16-vue的优点是什么" aria-hidden="true">#</a> 16 vue的优点是什么？</h2><ul><li>低耦合。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>ViewModel</code>可以绑定到不同的<code>&quot;View&quot;</code>上，当View变化的时候Model可以不变，当<code>Model</code>变化的时候<code>View</code>也可以不变</li><li>可重用性。你可以把一些视图逻辑放在一个<code>ViewModel</code>里面，让很多<code>view</code>重用这段视图逻辑</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对<code>ViewModel</code>来写</li></ul><h2 id="_17-路由之间跳转" tabindex="-1"><a class="header-anchor" href="#_17-路由之间跳转" aria-hidden="true">#</a> 17 路由之间跳转？</h2><p>声明式（标签跳转）</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;router-link :to=&quot;index&quot;&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>编程式（ js跳转）</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>router.push(&#39;index&#39;)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_18-实现-vue-ssr" tabindex="-1"><a class="header-anchor" href="#_18-实现-vue-ssr" aria-hidden="true">#</a> 18 实现 Vue SSR</h2><p>其基本实现原理</p><ul><li><code>app.js</code> 作为客户端与服务端的公用入口，导出 <code>Vue</code> 根实例，供客户端 <code>entry</code> 与服务端 <code>entry</code> 使用。客户端 <code>entry</code> 主要作用挂载到 <code>DOM</code> 上，服务端 <code>entry</code> 除了创建和返回实例，还进行路由匹配与数据预获取。</li><li><code>webpack</code> 为客服端打包一个 <code>Client Bundle</code> ，为服务端打包一个 <code>Server Bundle</code> 。</li><li>服务器接收请求时，会根据 <code>url</code>，加载相应组件，获取和解析异步数据，创建一个读取 <code>Server Bundle</code> 的 <code>BundleRenderer</code>，然后生成 <code>html</code> 发送给客户端。</li><li>客户端混合，客户端收到从服务端传来的 <code>DOM</code> 与自己的生成的 DOM 进行对比，把不相同的 <code>DOM</code> 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 <code>stroe</code> 里，这样，在客户端挂载到 <code>DOM</code> 之前，可以直接从 <code>store</code>里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__</code>发送到客户端</li></ul><blockquote><p><code>Vue SSR</code> 的实现，主要就是把 <code>Vue</code> 的组件输出成一个完整 <code>HTML</code>, <code>vue-server-renderer</code> 就是干这事的</p></blockquote><ul><li><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至 <code>HTML</code>、客户端混合（<code>hydration</code>）、缓存等等。 相比于其他模板引擎（<code>ejs</code>, <code>jade</code> 等），最终要实现的目的是一样的，性能上可能要差点</li></ul><h2 id="_19-vue-组件-data-为什么必须是函数" tabindex="-1"><a class="header-anchor" href="#_19-vue-组件-data-为什么必须是函数" aria-hidden="true">#</a> 19 Vue 组件 data 为什么必须是函数</h2><ul><li>每个组件都是 <code>Vue</code> 的实例。</li><li>组件共享 <code>data</code> 属性，当 <code>data</code> 的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul><h2 id="_20-vue-computed-实现" tabindex="-1"><a class="header-anchor" href="#_20-vue-computed-实现" aria-hidden="true">#</a> 20 Vue computed 实现</h2><ul><li>建立与其他属性（如：<code>data</code>、 <code>Store</code>）的联系；</li><li>属性改变后，通知计算属性重新计算</li></ul><blockquote><p>实现时，主要如下</p></blockquote><ul><li>初始化 <code>data</code>， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li><li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 <code>computed</code> 属性都是一个 <code>watch</code> 实例。每个属性提供的函数作为属性的 <code>getter</code>，使用 <code>Object.defineProperty</code> 转化。</li><li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li><li>若出现当前 <code>computed</code> 计算属性嵌套其他 <code>computed</code> 计算属性时，先进行其他的依赖收集</li></ul><h2 id="_21-vue-complier-实现" tabindex="-1"><a class="header-anchor" href="#_21-vue-complier-实现" aria-hidden="true">#</a> 21 Vue complier 实现</h2><ul><li>模板解析这种事，本质是将数据转化为一段 <code>html</code> ，最开始出现在后端，经过各种处理吐给前端。随着各种 <code>mv*</code> 的兴起，模板解析交由前端处理。</li><li>总的来说，<code>Vue complier</code> 是将 <code>template</code> 转化成一个 <code>render</code> 字符串。</li></ul><blockquote><p>可以简单理解成以下步骤：</p></blockquote><ul><li><code>parse</code> 过程，将 <code>template</code> 利用正则转化成<code>AST</code> 抽象语法树。</li><li><code>optimize</code> 过程，标记静态节点，后 <code>diff</code> 过程跳过静态节点，提升性能。</li><li><code>generate</code> 过程，生成 <code>render</code> 字符串</li></ul><h2 id="_22-怎么快速定位哪个组件出现性能问题" tabindex="-1"><a class="header-anchor" href="#_22-怎么快速定位哪个组件出现性能问题" aria-hidden="true">#</a> 22 怎么快速定位哪个组件出现性能问题</h2><blockquote><p>用 <code>timeline</code> 工具。 大意是通过 <code>timeline</code> 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote><h2 id="_23-开发中常用的指令有哪些" tabindex="-1"><a class="header-anchor" href="#_23-开发中常用的指令有哪些" aria-hidden="true">#</a> 23 开发中常用的指令有哪些</h2><ul><li><code>v-model</code> :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定</li><li><code>v-html</code>: 更新元素的 <code>innerHTML</code></li><li><code>v-show</code> 与 <code>v-if</code>: 条件渲染, 注意二者区别</li></ul><blockquote><p>使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏</p></blockquote><ul><li><code>v-on</code> : <code>click</code>: 可以简写为<code>@click</code>,<code>@</code>绑定一个事件。如果事件触发了，就可以指定事件的处理函数</li><li><code>v-for</code>:基于源数据多次渲染元素或模板块</li><li><code>v-bind</code>: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 <code>DOM</code></li></ul><blockquote><p>语法：<code>v-bind:title=&quot;msg&quot;</code>简写：<code>:title=&quot;msg&quot;</code></p></blockquote><h2 id="_24-proxy-相比于-defineproperty-的优势" tabindex="-1"><a class="header-anchor" href="#_24-proxy-相比于-defineproperty-的优势" aria-hidden="true">#</a> 24 Proxy 相比于 defineProperty 的优势</h2><blockquote><p>Object.defineProperty() 的问题主要有三个：</p></blockquote><ul><li>不能监听数组的变化</li><li>必须遍历对象的每个属性</li><li>必须深层遍历嵌套的对象</li></ul><blockquote><p>Proxy 在 ES2015 规范中被正式加入，它有以下几个特点</p></blockquote><ul><li>针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题</li><li>支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。</li></ul><blockquote><p>除了上述两点之外，Proxy 还拥有以下优势：</p></blockquote><ul><li>Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富</li><li>Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。</li></ul><h2 id="_25-vue-router-有哪几种导航守卫" tabindex="-1"><a class="header-anchor" href="#_25-vue-router-有哪几种导航守卫" aria-hidden="true">#</a> 25 vue-router 有哪几种导航守卫?</h2><ul><li>全局守卫</li><li>路由独享守卫</li><li>路由组件内的守卫</li></ul><p>全局守卫</p><blockquote><p>vue-router全局有三个守卫</p></blockquote><ul><li><code>router.beforeEach</code> 全局前置守卫 进入路由之前</li><li><code>router.beforeResolve</code> 全局解析守卫(2.5.0+) 在<code>beforeRouteEnter</code>调用之后调用</li><li><code>router.afterEach</code> 全局后置钩子 进入路由之后</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// main.js 入口文件
import router from &#39;./router&#39;; // 引入路由
router.beforeEach((to, from, next) =&gt; {
  next();
});
router.beforeResolve((to, from, next) =&gt; {
  next();
});
router.afterEach((to, from) =&gt; {
  console.log(&#39;afterEach 全局后置钩子&#39;);
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>路由独享守卫</p><blockquote><p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    {
      path: &#39;/foo&#39;,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
        // ...
      }
    }
  ]
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>路由组件内的守卫</p><ul><li>beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建</li><li>beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this</li><li>beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this</li></ul><h2 id="_26-组件之间的传值通信" tabindex="-1"><a class="header-anchor" href="#_26-组件之间的传值通信" aria-hidden="true">#</a> 26 组件之间的传值通信</h2><blockquote><p>组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯</p></blockquote><p>1. 父组件给子组件传值</p><ul><li>使用<code>props</code>，父组件可以使用<code>props</code>向子组件传递数据。</li><li>父组件<code>vue</code>模板<code>father.vue</code>:</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
    &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;
&lt;/template&gt;

&lt;script&gt;
import child from &#39;./child.vue&#39;;
export default {
    components: {
        child
    },
    data () {
        return {
            message: &#39;father message&#39;;
        }
    }
}
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>子组件vue模板child.vue:</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
    &lt;div&gt;{{msg}}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    }
}
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2. 子组件向父组件通信</p><blockquote><p>父组件向子组件传递事件方法，子组件通过<code>$emit</code>触发事件，回调给父组件</p></blockquote><p>父组件vue模板father.vue:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
    &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt;
&lt;/template&gt;

&lt;script&gt;
import child from &#39;./child.vue&#39;;
export default {
    components: {
        child
    },
    methods: {
        func (msg) {
            console.log(msg);
        }
    }
}
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>子组件vue模板child.vue:</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    },
    methods () {
        handleClick () {
            //........
            this.$emit(&#39;msgFunc&#39;);
        }
    }
}
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3. 非父子, 兄弟组件之间通信</p><blockquote><p>vue2中废弃了broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。Bus.js可以是这样:</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import Vue from &#39;vue&#39;
export default new Vue()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在需要通信的组件都引入Bus.js:</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
	&lt;button @click=&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
import Bus from &#39;../common/js/bus.js&#39;
export default{
	methods: {
	    toBus () {
	        Bus.$emit(&#39;on&#39;, &#39;来自兄弟组件&#39;)
	    }
	  }
}
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>另一个组件也import Bus.js 在钩子函数中监听on事件</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import Bus from &#39;../common/js/bus.js&#39;
export default {
    data() {
      return {
        message: &#39;&#39;
      }
    },
    mounted() {
       Bus.$on(&#39;on&#39;, (msg) =&gt; {
         this.message = msg
       })
     }
   }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_27-vue与angular以及react的区别" tabindex="-1"><a class="header-anchor" href="#_27-vue与angular以及react的区别" aria-hidden="true">#</a> 27 Vue与Angular以及React的区别？</h2><p>Vue与AngularJS的区别</p><ul><li>Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript</li><li>AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li><li>AngularJS社区完善, Vue的学习成本较小</li></ul><p>Vue与React的区别</p><ul><li>vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用；</li><li>props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图；</li><li>子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制；</li><li>每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现；</li><li>使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板；</li><li>多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法；</li><li>Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现；</li><li>react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</li><li>react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。</li><li>react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin</li></ul><h2 id="_28-vuex是什么-怎么使用-哪种功能场景使用它" tabindex="-1"><a class="header-anchor" href="#_28-vuex是什么-怎么使用-哪种功能场景使用它" aria-hidden="true">#</a> 28 vuex是什么？怎么使用？哪种功能场景使用它？</h2><ul><li>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</li><li>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</li><li>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li></ul><blockquote><p>vuex的使用借助官方提供的一张图来说明:</p></blockquote><p><img src="/assets/65.1ca6c9b1.png" alt=""></p><blockquote><p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p></blockquote><p>state</p><blockquote><p><code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p></blockquote><p>mutations</p><blockquote><p><code>mutations</code>定义的方法动态修改Vuex 的 store 中的状态或数据。</p></blockquote><p>getters</p><blockquote><p>类似vue的计算属性，主要用来过滤一些数据</p></blockquote><p>action</p><ul><li>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li><li>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。</li><li>使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题</li><li>vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个&quot;数据库&quot;的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 1、组件之间全局共享的数据 2、通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态</li></ul><blockquote><p>一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题：</p></blockquote><ul><li>开发时，改变数组或者对象的数据，但是页面没有更新如何解决？</li><li>vue弹窗后如何禁止滚动条滚动？</li><li>如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件</li></ul><h2 id="_28-watch与computed的区别" tabindex="-1"><a class="header-anchor" href="#_28-watch与computed的区别" aria-hidden="true">#</a> 28 watch与computed的区别</h2><p>computed:</p><ul><li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li><li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景</li></ul><p>watch:</p><ul><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ul><p>小结:</p><ul><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li><li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ul><h2 id="_29、vue是如何实现双向绑定的" tabindex="-1"><a class="header-anchor" href="#_29、vue是如何实现双向绑定的" aria-hidden="true">#</a> 29、Vue是如何实现双向绑定的?</h2><blockquote><p>利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 这是将要被劫持的对象
const data = {
  name: &#39;&#39;,
};

function say(name) {
  if (name === &#39;古天乐&#39;) {
    console.log(&#39;给大家推荐一款超好玩的游戏&#39;);
  } else if (name === &#39;渣渣辉&#39;) {
    console.log(&#39;戏我演过很多,可游戏我只玩贪玩懒月&#39;);
  } else {
    console.log(&#39;来做我的兄弟&#39;);
  }
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function(key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      console.log(&#39;get&#39;);
    },
    set: function(newVal) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`大家好,我系${newVal}`);
      say(newVal);
    },
  });
});

data.name = &#39;渣渣辉&#39;;
//大家好,我系渣渣辉
//戏我演过很多,可游戏我只玩贪玩懒月

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_29-vue2-x-响应式原理" tabindex="-1"><a class="header-anchor" href="#_29-vue2-x-响应式原理" aria-hidden="true">#</a> 29 Vue2.x 响应式原理</h2><blockquote><p>Vue 采用数据劫持结合发布---订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p></blockquote><p><img src="/assets/20220307225439.d612213d.jpeg" alt=""></p><ul><li><code>Observer</code> 遍历数据对象，给所有属性加上 <code>setter</code> 和 <code>getter</code>，监听数据的变化</li><li><code>compile</code> 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li></ul><blockquote><p><code>Watcher</code> 订阅者是 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情</p></blockquote><ul><li>在自身实例化时往属性订阅器 (<code>dep</code>) 里面添加自己</li><li>待属性变动 <code>dep.notice()</code> 通知时，调用自身的 <code>update()</code> 方法，并触发 <code>Compile</code> 中绑定的回调</li></ul><p>Vue3.x响应式数据原理</p><blockquote><p><code>Vue3.x</code>改用<code>Proxy</code>替代<code>Object.defineProperty</code>。因为<code>Proxy</code>可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p></blockquote><p><code>Proxy</code>只会代理对象的第一层，那么<code>Vue3</code>又是怎样处理这个问题的呢？</p><blockquote><p>判断当前<code>Reflect.get的</code>返回值是否为<code>Object</code>，如果是则再通过<code>reactive</code>方法做代理， 这样就实现了深度观测。</p></blockquote><p>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</p><blockquote><p>我们可以判断<code>key</code>是否为当前被代理对象<code>target</code>自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行<code>trigger</code></p></blockquote><h2 id="_30-v-model双向绑定原理" tabindex="-1"><a class="header-anchor" href="#_30-v-model双向绑定原理" aria-hidden="true">#</a> 30 v-model双向绑定原理</h2><blockquote><p><code>v-model</code>本质上是语法糖，<code>v-model</code>在内部为不同的输入元素使用不同的属性并抛出不同的事件</p></blockquote><ul><li><code>text</code> 和 <code>textarea</code> 元素使用 value 属性和 input 事件</li><li><code>checkbox</code> 和 <code>radio</code> 使用 checked 属性和 change 事件</li><li><code>select</code> 字段将 value 作为 prop 并将 change 作为事件</li></ul><p>所以我们可以v-model进行如下改写：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;input v-model=&quot;sth&quot; /&gt;
//  等同于
&lt;input :value=&quot;sth&quot; @input=&quot;sth = $event.target.value&quot; /&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个语法糖必须是固定的，也就是说属性必须为<code>value</code>，方法名必须为：<code>input</code>。</li><li>知道了<code>v-model</code>的原理，我们可以在自定义组件上实现<code>v-model</code></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//Parent
&lt;template&gt;
    {{num}}
    &lt;Child v-model=&quot;num&quot;&gt;
&lt;/template&gt;
export default {
    data(){
        return {
            num: 0
        }
    }
}

//Child
&lt;template&gt;
    &lt;div @click=&quot;add&quot;&gt;Add&lt;/div&gt;
&lt;/template&gt;
export default {
    props: [&#39;value&#39;],
    methods:{
        add(){
            this.$emit(&#39;input&#39;, this.value + 1)
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_31-scoped样式穿透" tabindex="-1"><a class="header-anchor" href="#_31-scoped样式穿透" aria-hidden="true">#</a> 31 scoped样式穿透</h2><blockquote><p><code>scoped</code>虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除<code>scoped</code>属性</p></blockquote><ol><li>使用<code>/deep/</code></li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//Parent
&lt;template&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;Child /&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
.wrap /deep/ .box{
    background: red;
}
&lt;/style&gt;

//Child
&lt;template&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>使用两个style标签</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//Parent
&lt;template&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;Child /&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
//其他样式
&lt;/style&gt;
&lt;style lang=&quot;scss&quot;&gt;
.wrap .box{
    background: red;
}
&lt;/style&gt;

//Child
&lt;template&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_32-ref的作用" tabindex="-1"><a class="header-anchor" href="#_32-ref的作用" aria-hidden="true">#</a> 32 ref的作用</h2><ul><li>获取<code>dom</code>元素<code>this.$refs.box</code></li><li>获取子组件中的<code>datathis.$refs.box.msg</code></li><li>调用子组件中的方法<code>this.$refs.box.open()</code></li></ul><h2 id="_33-computed和watch区别" tabindex="-1"><a class="header-anchor" href="#_33-computed和watch区别" aria-hidden="true">#</a> 33 computed和watch区别</h2><ol><li>当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed</li></ol><blockquote><p><code>Computed</code>本质是一个具备缓存的<code>watcher</code>，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理</p></blockquote><p><img src="/assets/25.6e21d711.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;{{fullName}}&lt;/template&gt;
export default {
    data(){
        return {
            firstName: &#39;xie&#39;,
            lastName: &#39;yu fei&#39;,
        }
    },
    computed:{
        fullName: function(){
            return this.firstName + &#39; &#39; + this.lastName
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><code>watch</code>用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么<code>watch</code>为最佳选择</li></ol><blockquote><p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用<code>unWatch</code>手动注销</p></blockquote><p><img src="/assets/26.eecfef66.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;{{fullName}}&lt;/template&gt;
export default {
    data(){
        return {
            firstName: &#39;xie&#39;,
            lastName: &#39;xiao fei&#39;,
            fullName: &#39;xie xiao fei&#39;
        }
    },
    watch:{
        firstName(val) {
            this.fullName = val + &#39; &#39; + this.lastName
        },
        lastName(val) {
            this.fullName = this.firstName + &#39; &#39; + val
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_34-vue-router守卫" tabindex="-1"><a class="header-anchor" href="#_34-vue-router守卫" aria-hidden="true">#</a> 34 vue-router守卫</h2><blockquote><p>导航守卫 <code>router.beforeEach</code> 全局前置守卫</p></blockquote><ul><li><code>to: Route</code>: 即将要进入的目标（路由对象）</li><li><code>from: Route</code>: 当前导航正要离开的路由</li><li><code>next: Function</code>: 一定要调用该方法来 <code>resolve</code> 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截）</li><li>执行效果依赖 next 方法的调用参数。</li><li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li><code>next(false)</code>:取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// main.js 入口文件
import router from &#39;./router&#39;; // 引入路由
router.beforeEach((to, from, next) =&gt; {
  next();
});
router.beforeResolve((to, from, next) =&gt; {
  next();
});
router.afterEach((to, from) =&gt; {
  console.log(&#39;afterEach 全局后置钩子&#39;);
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>路由独享的守卫 你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const router = new VueRouter({
  routes: [
    {
      path: &#39;/foo&#39;,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>组件内的守卫你可以在路由组件内直接定义以下路由导航守卫</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_35-vue修饰符" tabindex="-1"><a class="header-anchor" href="#_35-vue修饰符" aria-hidden="true">#</a> 35 vue修饰符</h2><ul><li><code>stop</code>：阻止事件的冒泡</li><li><code>prevent</code>：阻止事件的默认行为</li><li><code>once</code>：只触发一次</li><li><code>self</code>：只触发自己的事件行为时，才会执行</li></ul><h2 id="_36-vue项目中的性能优化" tabindex="-1"><a class="header-anchor" href="#_36-vue项目中的性能优化" aria-hidden="true">#</a> 36 vue项目中的性能优化</h2><ul><li>不要在模板里面写过多表达式</li><li>循环调用子组件时添加key</li><li>频繁切换的使用v-show，不频繁切换的使用v-if</li><li>尽量少用float，可以用flex</li><li>按需加载，可以用require或者import()按需加载需要的组件</li><li>路由懒加载</li></ul><h2 id="_37-vue-extend和vue-component" tabindex="-1"><a class="header-anchor" href="#_37-vue-extend和vue-component" aria-hidden="true">#</a> 37 vue.extend和vue.component</h2><ul><li><code>extend</code>是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li><li><code>Vue.component</code>你可以创建 ，也可以取组件。</li></ul><h2 id="_38-vue的spa-如何优化加载速度" tabindex="-1"><a class="header-anchor" href="#_38-vue的spa-如何优化加载速度" aria-hidden="true">#</a> 38 Vue的SPA 如何优化加载速度</h2><ul><li>减少入口文件体积</li><li>静态资源本地缓存</li><li>开启Gzip压缩</li><li>使用SSR,nuxt.js</li></ul><h2 id="_39-移动端如何设计一个比较友好的header组件" tabindex="-1"><a class="header-anchor" href="#_39-移动端如何设计一个比较友好的header组件" aria-hidden="true">#</a> 39 移动端如何设计一个比较友好的Header组件？</h2><blockquote><p>当时的思路是头部(Header)一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过vue props的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过vue slot插槽的方式对外暴露以实现多样化，同时也可以提供default slot默认插槽来统一页面风格</p></blockquote><h2 id="_40-proxy与object-defineproperty的优劣对比" tabindex="-1"><a class="header-anchor" href="#_40-proxy与object-defineproperty的优劣对比" aria-hidden="true">#</a> 40 Proxy与Object.defineProperty的优劣对比?</h2><p>Proxy的优势如下:</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化</li><li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li><li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li></ul><p>Object.defineProperty的优势如下:</p><p>兼容性好,支持IE9</p><h2 id="_41-你是如何理解vue的响应式系统的" tabindex="-1"><a class="header-anchor" href="#_41-你是如何理解vue的响应式系统的" aria-hidden="true">#</a> 41 你是如何理解Vue的响应式系统的?</h2><p><img src="/assets/66.853fc7d8.png" alt=""></p><p>响应式系统简述:</p><ul><li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li><li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li><li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li><li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li></ul><h2 id="_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异" tabindex="-1"><a class="header-anchor" href="#_42-既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异" aria-hidden="true">#</a> 42 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?</h2><blockquote><p>现代前端框架有两种方式侦测变化,一种是pull一种是push</p></blockquote><ul><li>pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</li><li>push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的</li></ul><h2 id="_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期" tabindex="-1"><a class="header-anchor" href="#_43-vue为什么没有类似于react中shouldcomponentupdate的生命周期" aria-hidden="true">#</a> 43 Vue为什么没有类似于React中shouldComponentUpdate的生命周期？</h2><p>考点: Vue的变化侦测原理</p><p>前置知识: 依赖收集、虚拟DOM、响应式系统</p><blockquote><p>根本原因是Vue与React的变化侦测方式有所不同</p></blockquote><ul><li>React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.</li><li>Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.</li></ul><h2 id="_44-vue中的key到底有什么用" tabindex="-1"><a class="header-anchor" href="#_44-vue中的key到底有什么用" aria-hidden="true">#</a> 44 Vue中的key到底有什么用？</h2><ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li><li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul><blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p></blockquote><blockquote><p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code>.</p></blockquote><p><img src="/assets/67.feaed759.png" alt=""></p><h2 id="_45-vue-项目性能优化" tabindex="-1"><a class="header-anchor" href="#_45-vue-项目性能优化" aria-hidden="true">#</a> 45 vue 项目性能优化</h2><p>代码层面：</p><ul><li>合理使用 <code>v-if</code> 和 <code>v-show</code></li><li>区分 <code>computed</code> 和 <code>watch</code> 的使用</li><li><code>v-for</code> 遍历为 <code>item</code> 添加 <code>key</code></li><li><code>v-for</code> 遍历避免同时使用 <code>v-if</code></li><li>通过 <code>addEventListener</code>添加的事件在组件销毁时要用 <code>removeEventListener</code> 手动移除这些事件的监听</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件按需引入</li><li><code>SSR</code>服务端渲染，首屏加载速度快，<code>SEO</code>效果好</li></ul><p>Webpack 层面优化：</p><ul><li>对图片进行压缩</li><li>使用 <code>CommonsChunkPlugin</code> 插件提取公共代码</li><li>提取组件的 CSS</li><li>优化 <code>SourceMap</code></li><li>构建结果输出分析，利用 <code>webpack-bundle-analyzer</code> 可视化分析工具</li></ul><h2 id="_46-nexttick" tabindex="-1"><a class="header-anchor" href="#_46-nexttick" aria-hidden="true">#</a> 46 nextTick</h2><blockquote><p><code>nextTick</code> 可以让我们在下次 <code>DOM</code> 更新循环结束之后执行延迟回调，用于获得更新后的 <code>DOM</code></p></blockquote><p><code>nextTick</code>主要使用了宏任务和微任务。根据执行环境分别尝试采用</p><ul><li><code>Promise</code></li><li><code>MutationObserver</code></li><li><code>setImmediate</code></li><li>如果以上都不行则采用<code>setTimeout</code></li></ul><blockquote><p>定义了一个异步方法，多次调用<code>nextTick</code>会将方法存入队列中，通过这个异步方法清空当前队列</p></blockquote><h2 id="_47-说一下vue2-x中如何监测数组变化" tabindex="-1"><a class="header-anchor" href="#_47-说一下vue2-x中如何监测数组变化" aria-hidden="true">#</a> 47 说一下vue2.x中如何监测数组变化</h2><blockquote><p>使用了函数劫持的方式，重写了数组的方法，<code>Vue</code>将<code>data</code>中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p></blockquote><h2 id="_48-你的接口请求一般放在哪个生命周期中" tabindex="-1"><a class="header-anchor" href="#_48-你的接口请求一般放在哪个生命周期中" aria-hidden="true">#</a> 48 你的接口请求一般放在哪个生命周期中</h2><blockquote><p>接口请求一般放在<code>mounted</code>中，但需要注意的是服务端渲染时不支持<code>mounted</code>，需要放到<code>created</code>中</p></blockquote><h2 id="_49-组件中的data为什么是一个函数" tabindex="-1"><a class="header-anchor" href="#_49-组件中的data为什么是一个函数" aria-hidden="true">#</a> 49 组件中的data为什么是一个函数</h2><blockquote><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果<code>data</code>是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间d<code>ata</code>不冲突，data必须是一个函数</p></blockquote><h2 id="_50-说一下v-model的原理" tabindex="-1"><a class="header-anchor" href="#_50-说一下v-model的原理" aria-hidden="true">#</a> 50 说一下v-model的原理</h2><blockquote><p><code>v-model</code>本质就是一个语法糖，可以看成是<code>value + input</code>方法的语法糖。 可以通过<code>model</code>属性的<code>prop</code>和<code>event</code>属性来进行自定义。原生的<code>v-model</code>，会根据标签的不同生成不同的事件和属性</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;input v-model=&#39;searchData&#39;&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;input
	v-bind:value = &#39;searchData&#39;
	v-on:input = &#39;searchData = $event.target.value&#39;
&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当在input元素中使用<code>v-model</code>实现双数据绑定，其实就是在输入的时候触发元素的input事件，通过这个语法糖，实现了数据的双向绑定。</p><h2 id="_51-vue事件绑定原理说一下" tabindex="-1"><a class="header-anchor" href="#_51-vue事件绑定原理说一下" aria-hidden="true">#</a> 51 Vue事件绑定原理说一下</h2><blockquote><p>原生事件绑定是通过<code>addEventListener</code>绑定给真实元素的，组件事件绑定是通过<code>Vue</code>自定义的<code>$on</code>实现的</p></blockquote><h2 id="_52-vue模版编译原理知道吗-能简单说一下吗" tabindex="-1"><a class="header-anchor" href="#_52-vue模版编译原理知道吗-能简单说一下吗" aria-hidden="true">#</a> 52 Vue模版编译原理知道吗，能简单说一下吗？</h2><blockquote><p>简单说，<code>Vue</code>的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p></blockquote><ul><li><p>生成<code>AST</code>树</p></li><li><p>优化</p></li><li><p><code>codegen</code></p></li><li><p>首先解析模版，生成<code>AST</code>语法树(一种用J<code>avaScript</code>对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p></li><li><p><code>Vue</code>的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p></li><li><p>编译的最后一步是将优化后的<code>AST</code>树转换为可执行的代码</p></li></ul><h2 id="_53-vue2-x和vue3-x渲染器的diff算法分别说一下" tabindex="-1"><a class="header-anchor" href="#_53-vue2-x和vue3-x渲染器的diff算法分别说一下" aria-hidden="true">#</a> 53 Vue2.x和Vue3.x渲染器的diff算法分别说一下</h2><blockquote><p>简单来说，<code>diff</code>算法有以下过程</p></blockquote><ul><li><p>同级比较，再比较子节点</p></li><li><p>先判断一方有子节点一方没有子节点的情况(如果新的<code>children</code>没有子节点，将旧的子节点移除)</p></li><li><p>比较都有子节点的情况(核心<code>diff</code>)</p></li><li><p>递归比较子节点</p></li><li><p>正常<code>Diff</code>两个树的时间复杂度是<code>O(n^3)</code>，但实际情况下我们很少会进行跨层级的移动<code>DOM</code>，所以<code>Vue</code>将<code>Diff</code>进行了优化，从<code>O(n^3) -&gt; O(n)</code>，只有当新旧<code>children</code>都为多个子节点时才需要用核心的<code>Diff</code>算法进行同层级比较。</p></li><li><p><code>Vue2</code>的核心<code>Diff</code>算法采用了双端比较的算法，同时从新旧<code>children</code>的两端开始进行比较，借助<code>key</code>值找到可复用的节点，再进行相关操作。相比<code>React</code>的<code>Diff</code>算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅</p></li><li><p>在创建<code>VNode</code>时就确定其类型，以及在<code>mount/patch</code>的过程中采用位运算来判断一个<code>VNode</code>的类型，在这个基础之上再配合核心的<code>Diff</code>算法，使得性能上较<code>Vue2.x</code>有了提升</p></li></ul><h2 id="_54-再说一下虚拟dom以及key属性的作用" tabindex="-1"><a class="header-anchor" href="#_54-再说一下虚拟dom以及key属性的作用" aria-hidden="true">#</a> 54 再说一下虚拟Dom以及key属性的作用</h2><ul><li>由于在浏览器中操作<code>DOM</code>是很昂贵的。频繁的操作<code>DOM</code>，会产生一定的性能问题。这就是虚拟Dom的产生原因</li><li><code>Virtual DOM</code>本质就是用一个原生的JS对象去描述一个<code>DOM</code>节点。是对真实DOM的一层抽象</li><li><code>VirtualDOM</code>映射到真实DOM要经历<code>VNode</code>的<code>create</code>、<code>diff</code>、<code>patch</code>等阶段</li></ul><p>key的作用是尽可能的复用 DOM 元素</p><ul><li>新旧 <code>children</code> 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的</li><li>需要在新旧 <code>children</code> 的节点中保存映射关系，以便能够在旧 <code>children</code> 的节点中找到可复用的节点。<code>key</code>也就是<code>children</code>中节点的唯一标识</li></ul><h2 id="_55-vue中组件生命周期调用顺序说一下" tabindex="-1"><a class="header-anchor" href="#_55-vue中组件生命周期调用顺序说一下" aria-hidden="true">#</a> 55 Vue中组件生命周期调用顺序说一下</h2><ul><li>渲染顺序：先父后子，完成顺序：先子后父</li><li>更新顺序：父更新导致子更新，子更新完成后父</li><li>销毁顺序：先父后子，完成顺序：先子后父</li></ul><p>加载渲染过程</p><blockquote><p><code>父beforeCreate</code>-&gt;<code>父created</code>-&gt;<code>父beforeMount</code>-&gt;<code>子beforeCreate</code>-&gt;<code>子created</code>-&gt;<code>子beforeMount</code>- &gt;<code>子mounted</code>-&gt;<code>父mounted</code></p></blockquote><p>子组件更新过程</p><blockquote><p><code>父beforeUpdate</code>-&gt;<code>子beforeUpdate</code>-&gt;<code>子updated</code>-&gt;<code>父updated</code></p></blockquote><p>父组件更新过程</p><blockquote><p><code>父 beforeUpdate</code> -&gt; <code>父 updated</code></p></blockquote><p>销毁过程</p><blockquote><p><code>父beforeDestroy</code>-&gt;<code>子beforeDestroy</code>-&gt;<code>子destroyed</code>-&gt;<code>父destroyed</code></p></blockquote><h2 id="_56-ssr了解吗" tabindex="-1"><a class="header-anchor" href="#_56-ssr了解吗" aria-hidden="true">#</a> 56 SSR了解吗</h2><blockquote><p><code>SSR</code>也就是服务端渲染，也就是将<code>Vue</code>在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p></blockquote><p><code>SSR</code>有着更好的<code>SEO</code>、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持<code>beforeCreate</code>和<code>created</code>两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于<code>Node.js</code>的运行环境。还有就是服务器会有更大的负载需求</p><h2 id="_57-你都做过哪些vue的性能优化" tabindex="-1"><a class="header-anchor" href="#_57-你都做过哪些vue的性能优化" aria-hidden="true">#</a> 57 你都做过哪些Vue的性能优化</h2><p>编码阶段</p><ul><li>尽量减少<code>data</code>中的数据，<code>data</code>中的数据都会增加<code>getter</code>和<code>setter</code>，会收集对应的<code>watcher</code></li><li><code>v-if</code>和<code>v-for</code>不能连用</li><li>如果需要使用<code>v-for</code>给每项元素绑定事件时使用事件代理</li><li><code>SPA</code> 页面采用<code>keep-alive</code>缓存组件</li><li>在更多的情况下，使用<code>v-if</code>替代<code>v-show</code></li><li><code>key</code>保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p>SEO优化</p><ul><li>预渲染</li><li>服务端渲染<code>SSR</code></li></ul><p>打包优化</p><ul><li>压缩代码</li><li><code>Tree Shaking/Scope Hoisting</code></li><li>使用<code>cdn</code>加载第三方模块</li><li>多线程打包<code>happypack</code></li><li><code>splitChunks</code>抽离公共文件</li><li><code>sourceMap</code>优化</li></ul><p>用户体验</p><ul><li>骨架屏</li><li><code>PWA</code></li></ul><blockquote><p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启<code>gzip</code>压缩等。</p></blockquote><h2 id="_58-vue-js特点" tabindex="-1"><a class="header-anchor" href="#_58-vue-js特点" aria-hidden="true">#</a> 58 Vue.js特点</h2><ul><li>简洁：页面由<code>HTML</code>模板+Json数据+<code>Vue</code>实例组成</li><li>数据驱动：自动计算属性和追踪依赖的模板表达式</li><li>组件化：用可复用、解耦的组件来构造页面</li><li>轻量：代码量小，不依赖其他库</li><li>快速：精确有效批量DOM更新</li><li>模板友好：可通过npm，bower等多种方式安装，很容易融入</li></ul><h2 id="_59-请说出vue-cli项目中src目录每个文件夹和文件的用法" tabindex="-1"><a class="header-anchor" href="#_59-请说出vue-cli项目中src目录每个文件夹和文件的用法" aria-hidden="true">#</a> 59 请说出vue.cli项目中src目录每个文件夹和文件的用法</h2><ul><li><code>assets</code>文件夹是放静态资源；</li><li><code>components</code>是放组件；</li><li><code>router</code>是定义路由相关的配置;</li><li><code>view</code>视图；</li><li><code>app.vue</code>是一个应用主组件；</li><li><code>main.js</code>是入口文件</li></ul><h2 id="_60-vue路由传参数" tabindex="-1"><a class="header-anchor" href="#_60-vue路由传参数" aria-hidden="true">#</a> 60 vue路由传参数</h2><ul><li>使用<code>query</code>方法传入的参数使用<code>this.$route.query</code>接受</li><li>使用<code>params</code>方式传入的参数使用<code>this.$route.params</code>接受</li></ul><h2 id="_61-vuex-是什么-有哪几种属性" tabindex="-1"><a class="header-anchor" href="#_61-vuex-是什么-有哪几种属性" aria-hidden="true">#</a> 61 vuex 是什么？ 有哪几种属性？</h2><blockquote><ul><li><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。</li><li>有 5 种，分别是 <code>state</code>、<code>getter</code>、<code>mutation</code>、<code>action</code>、<code>module</code></li></ul></blockquote><ul><li><code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。</li><li>有 5 种，分别是 <code>state</code>、<code>getter</code>、<code>mutation</code>、<code>action</code>、<code>module</code></li><li><code>vuex</code> 的 <code>store</code> 是什么？</li><li><code>vuex</code> 就是一个仓库，仓库里放了很多对象。其中 <code>state</code> 就是数据源存放地，对应于一般 vue 对象里面的 <code>datastate</code> 里面存放的数据是响应式的，<code>vue</code> 组件从 <code>store</code> 读取数据，若是 <code>store</code> 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 <code>mapState</code> 把全局的 <code>state</code> 和 <code>getters</code> 映射到当前组件的 <code>computed</code> 计算属性</li></ul><p>vuex 的 getter 是什么？</p><ul><li><code>getter</code> 可以对 <code>state</code> 进行计算操作，它就是 <code>store</code> 的计算属性虽然在组件内也可以做计算属性，但是 <code>getters</code> 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 <code>getters</code></li></ul><p>vuex 的 mutation 是什么？</p><ul><li>更改<code>Vuex</code>的<code>store</code>中的状态的唯一方法是提交<code>mutation</code></li></ul><p>vuex 的 action 是什么？</p><ul><li><code>action</code> 类似于 <code>muation</code>, 不同在于：<code>action</code> 提交的是 <code>mutation</code>,而不是直接变更状态<code>action</code> 可以包含任意异步操作</li><li><code>vue</code> 中 <code>ajax</code> 请求代码应该写在组件的 <code>methods</code> 中还是 <code>vuex</code> 的 <code>action</code> 中</li><li><code>vuex</code> 的 <code>module</code> 是什么？</li></ul><blockquote><p>面对复杂的应用程序，当管理的状态比较多时；我们需要将<code>vuex</code>的<code>store</code>对象分割成模块(<code>modules</code>)。</p></blockquote><blockquote><p>如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 <code>vuex</code> 的 <code>state</code> 里如果被其他地方复用，请将请求放入 <code>action</code> 里，方便复用，并包装成 <code>promise</code> 返回</p></blockquote><h2 id="_62-如何让css只在当前组件中起作用" tabindex="-1"><a class="header-anchor" href="#_62-如何让css只在当前组件中起作用" aria-hidden="true">#</a> 62 如何让CSS只在当前组件中起作用？</h2><blockquote><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p></blockquote><h2 id="_63-delete和vue-delete删除数组的区别" tabindex="-1"><a class="header-anchor" href="#_63-delete和vue-delete删除数组的区别" aria-hidden="true">#</a> 63 delete和Vue.delete删除数组的区别？</h2><ul><li><code>delete</code>只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code>直接删除了数组 改变了数组的键值。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a=[1,2,3,4]
var b=[1,2,3,4]
delete a[0]
console.log(a)  //[empty,2,3,4]
this.$delete(b,0)
console.log(b)  //[2,3,4]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_64-v-on可以监听多个方法吗" tabindex="-1"><a class="header-anchor" href="#_64-v-on可以监听多个方法吗" aria-hidden="true">#</a> 64 v-on可以监听多个方法吗？</h2><p>可以</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;onInput&quot; @focus=&quot;onFocus&quot; @blur=&quot;onBlur&quot; /&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>v-on 常用修饰符</p><ul><li><code>.stop</code> 该修饰符将阻止事件向上冒泡。同理于调用 <code>event.stopPropagation()</code> 方法</li><li><code>.prevent</code> 该修饰符会阻止当前事件的默认行为。同理于调用 <code>event.preventDefault()</code> 方法</li><li><code>.self</code> 该指令只当事件是从事件绑定的元素本身触发时才触发回调</li><li><code>.once</code> 该修饰符表示绑定的事件只会被触发一次</li></ul><h2 id="_65-vue子组件调用父组件的方法" tabindex="-1"><a class="header-anchor" href="#_65-vue子组件调用父组件的方法" aria-hidden="true">#</a> 65 Vue子组件调用父组件的方法</h2><ul><li>第一种方法是直接在子组件中通过<code>this.$parent.event</code>来调用父组件的方法</li><li>第二种方法是在子组件里用<code>$emit</code>向父组件触发一个事件，父组件监听这个事件就行了。</li></ul><h2 id="_66-vue如何兼容ie的问题" tabindex="-1"><a class="header-anchor" href="#_66-vue如何兼容ie的问题" aria-hidden="true">#</a> 66 vue如何兼容ie的问题</h2><blockquote><p>babel-polyfill插件</p></blockquote><h2 id="_67-vue-改变数组触发视图更新" tabindex="-1"><a class="header-anchor" href="#_67-vue-改变数组触发视图更新" aria-hidden="true">#</a> 67 Vue 改变数组触发视图更新</h2><blockquote><p>以下方法调用会改变原始数组：<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code>, <code>reverse()</code>,<code>Vue.set( target, key, value )</code></p></blockquote><ul><li>调用方法：<code>Vue.set( target, key, value )</code><ul><li><code>target</code>：要更改的数据源(可以是对象或者数组)</li><li><code>key</code>：要更改的具体数据</li><li><code>value</code> ：重新赋的值</li></ul></li></ul><h2 id="_68-dom-渲染在哪个周期中就已经完成" tabindex="-1"><a class="header-anchor" href="#_68-dom-渲染在哪个周期中就已经完成" aria-hidden="true">#</a> 68 DOM 渲染在哪个周期中就已经完成？</h2><blockquote><p>在<code>mounted</code></p></blockquote><p>注意 <code>mounted</code> 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>mounted</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_69-简述每个周期具体适合哪些场景" tabindex="-1"><a class="header-anchor" href="#_69-简述每个周期具体适合哪些场景" aria-hidden="true">#</a> 69 简述每个周期具体适合哪些场景</h2><ul><li><code>beforecreate</code> : 可以在这加个<code>loading</code>事件，在加载实例时触发</li><li><code>created</code> : 初始化完成时的事件写在这里，如在这结束<code>loading</code>事件，异步请求也适宜在这里调用</li><li><code>mounted</code> : 挂载元素，获取到DOM节点 <code>updated</code> : 如果对数据统一处理，在这里写上相应函数</li><li><code>beforeDestroy</code> : 可以做一个确认停止事件的确认框</li></ul><p>第一次加载会触发哪几个钩子</p><blockquote><p>会触发<code>beforeCreate</code> , <code>created</code> ,<code>beforeMount</code> ,<code>mounted</code></p></blockquote><h2 id="_70-动态绑定class" tabindex="-1"><a class="header-anchor" href="#_70-动态绑定class" aria-hidden="true">#</a> 70 动态绑定class</h2><blockquote><p><code>active</code> <code>classname</code>， <code>isActive</code> 变量</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;div :class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_71-vue3-0-是如何变得更快的" tabindex="-1"><a class="header-anchor" href="#_71-vue3-0-是如何变得更快的" aria-hidden="true">#</a> 71 Vue3.0 是如何变得更快的</h2><h3 id="diff-方法优化" tabindex="-1"><a class="header-anchor" href="#diff-方法优化" aria-hidden="true">#</a> diff 方法优化</h3><ul><li><code>Vue2.x</code> 中的虚拟 dom 是进行全量的对比。</li><li><code>Vue3.0</code> 中新增了静态标记(PatchFlag):在与上次虚拟结点进行对比的时候，值对比 带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化</li></ul><h3 id="hoiststatic-静态提升" tabindex="-1"><a class="header-anchor" href="#hoiststatic-静态提升" aria-hidden="true">#</a> hoistStatic 静态提升</h3><ul><li><code>Vue2.x</code> : 无论元素是否参与更新，每次都会重新创建。</li><li><code>Vue3.0</code> : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用</li></ul><h3 id="cachehandlers-事件侦听器缓存" tabindex="-1"><a class="header-anchor" href="#cachehandlers-事件侦听器缓存" aria-hidden="true">#</a> cacheHandlers 事件侦听器缓存</h3><p>默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一 个函数，所以没有追踪变化，直接缓存起来复用即可</p><h2 id="_72-说说你对-proxy-的理解" tabindex="-1"><a class="header-anchor" href="#_72-说说你对-proxy-的理解" aria-hidden="true">#</a> 72 说说你对 proxy 的理解</h2><p>vue 的数据劫持有两个缺点</p><ul><li>无法监听通过索引修改数组的值的变化</li><li>无法监听 object 也就是对象的值的变化</li><li>所以 vue2.x 中才会有<code>$set</code> 属性的存在</li><li>proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 <code>object.defineproperty</code>。</li></ul><h2 id="_73-生命周期详解" tabindex="-1"><a class="header-anchor" href="#_73-生命周期详解" aria-hidden="true">#</a> 73 生命周期详解</h2><p><em>init</em></p><ul><li><code>initLifecycle/Event</code>，往vm上挂载各种属性</li><li><code>callHook: beforeCreated</code>: 实例刚创建</li><li><code>initInjection/initState</code>: 初始化注入和 <code>data</code> 响应性</li><li><code>created: 创建完成，属性已经绑定， 但还未生成真实</code>dom`</li><li>进行元素的挂载： <code>$el / vm.$mount()</code></li><li>是否有<code>template</code>: 解析成 <code>render function</code><ul><li><code>*.vue</code>文件: <code>vue-loader</code>会将<code>&lt;template&gt;</code>编译成<code>render function</code></li></ul></li><li><code>beforeMount</code>: 模板编译/挂载之前</li><li>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</li><li><code>mounted</code>: 组件已挂载</li></ul><p>update</p><ul><li>执行<code>diff</code>算法，比对改变是否需要触发<code>UI</code>更新</li><li><code>flushScheduleQueue</code></li><li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子 - <code>watcher.run()</code>: 执行<code>watcher</code>中的 <code>notify</code>，通知所有依赖项更新UI</li><li>触发<code>updated</code>钩子: 组件已更新</li><li><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</li><li><code>destroy</code><ul><li><code>beforeDestroy</code>: 销毁开始</li><li>销毁自身且递归销毁子组件以及事件监听 <ul><li><code>remove()</code>: 删除节点</li><li><code>watcher.teardown()</code>: 清空依赖</li><li><code>vm.$off()</code>: 解绑监听</li></ul></li><li><code>destroyed</code>: 完成后触发钩子</li></ul></li></ul><blockquote><p>上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>
new Vue({})

// 初始化Vue实例
function _init() {
	 // 挂载属性
    initLifeCycle(vm)
    // 初始化事件系统，钩子函数等
    initEvent(vm)
    // 编译slot、vnode
    initRender(vm)
    // 触发钩子
    callHook(vm, &#39;beforeCreate&#39;)
    // 添加inject功能
    initInjection(vm)
    // 完成数据响应性 props/data/watch/computed/methods
    initState(vm)
    // 添加 provide 功能
    initProvide(vm)
    // 触发钩子
    callHook(vm, &#39;created&#39;)

	 // 挂载节点
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}

// 挂载节点实现
function mountComponent(vm) {
	 // 获取 render function
    if (!this.options.render) {
        // template to render
        // Vue.compile = compileToFunctions
        let { render } = compileToFunctions()
        this.options.render = render
    }
    // 触发钩子
    callHook(&#39;beforeMounte&#39;)
    // 初始化观察者
    // render 渲染 vdom，
    vdom = vm.render()
    // update: 根据 diff 出的 patchs 挂载成真实的 dom
    vm._update(vdom)
    // 触发钩子
    callHook(vm, &#39;mounted&#39;)
}

// 更新节点实现
funtion queueWatcher(watcher) {
	nextTick(flushScheduleQueue)
}

// 清空队列
function flushScheduleQueue() {
	 // 遍历队列中所有修改
    for(){
	    // beforeUpdate
        watcher.before()

        // 依赖局部更新节点
        watcher.update()
        callHook(&#39;updated&#39;)
    }
}

// 销毁实例实现
Vue.prototype.$destory = function() {
	 // 触发钩子
    callHook(vm, &#39;beforeDestory&#39;)
    // 自身及子节点
    remove()
    // 删除依赖
    watcher.teardown()
    // 删除监听
    vm.$off()
    // 触发钩子
    callHook(vm, &#39;destoryed&#39;)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_74-proxy-相比于-defineproperty-的优势" tabindex="-1"><a class="header-anchor" href="#_74-proxy-相比于-defineproperty-的优势" aria-hidden="true">#</a> 74 Proxy 相比于 defineProperty 的优势</h2><ul><li>数组变化也能监听到</li><li>不需要深度遍历监听</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let data = { a: 1 }
let reactiveData = new Proxy(data, {
	get: function(target, name){
		// ...
	},
	// ...
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_75-vue-router" tabindex="-1"><a class="header-anchor" href="#_75-vue-router" aria-hidden="true">#</a> 75 vue-router</h2><p>mode</p><ul><li><code>hash</code></li><li><code>history</code></li></ul><p>跳转</p><ul><li><code>this.$router.push()</code></li><li><code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li></ul><p>占位</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;router-view&gt;&lt;/router-view&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_76-vuex总结" tabindex="-1"><a class="header-anchor" href="#_76-vuex总结" aria-hidden="true">#</a> 76 vuex总结</h2><ul><li><code>state</code>: 状态中心</li><li><code>mutations</code>: 更改状态</li><li><code>actions</code>: 异步更改状态</li><li><code>getters</code>: 获取状态</li><li><code>modules</code>: 将<code>state</code>分成多个<code>modules</code>，便于管理</li></ul><h2 id="_77-diff-算法" tabindex="-1"><a class="header-anchor" href="#_77-diff-算法" aria-hidden="true">#</a> 77 diff 算法</h2><p>时间复杂度： 个树的完全<code>diff</code> 算法是一个时间复杂度为<code>O(n*3）</code> ，vue进行优化转化成<code>O(n)</code> 。</p><p>理解：</p><ul><li>最小量更新，<code>key</code> 很重要。这个可以是这个节点的唯一标识，告诉<code>diff</code> 算法，在更改前后它们是同一个DOM节点 <ul><li>扩展<code>v-for</code> 为什么要有<code>key</code> ，没有<code>key</code> 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加<code>key</code> 只会移动减少操作DOM。</li></ul></li><li>只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。</li><li>只进行同层比较，不会进行跨层比较。</li></ul><p>diff算法的优化策略：四种命中查找，四个指针</p><ol><li>旧前与新前（先比开头，后插入和删除节点的这种情况）</li><li>旧后与新后（比结尾，前插入或删除的情况）</li><li>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</li><li>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</li></ol><h2 id="_78-vue-的响应式原理中-object-defineproperty-有什么缺陷" tabindex="-1"><a class="header-anchor" href="#_78-vue-的响应式原理中-object-defineproperty-有什么缺陷" aria-hidden="true">#</a> 78 Vue 的响应式原理中 Object.defineProperty 有什么缺陷</h2><ul><li><code>Object.defineProperty</code> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li><li><code>Object.defineProperty</code> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象</li><li><code>Proxy</code> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性</li></ul><h2 id="_79-composition-api" tabindex="-1"><a class="header-anchor" href="#_79-composition-api" aria-hidden="true">#</a> 79 Composition API</h2><ul><li><code>Composition API</code>出现就是为了解决Options API导致相同功能代码分散的现象</li></ul><p><img src="/assets/202203211356041.072e7bd9.png" alt=""><img src="/assets/202203211356611.8045fc67.png" alt=""></p><p>compositon api提供了以下几个函数：</p><ul><li><code>setup</code></li><li><code>ref</code></li><li><code>reactive</code></li><li><code>watchEffect</code></li><li><code>watch</code></li><li><code>computed</code></li><li><code>toRefs</code></li><li>生命周期的<code>hooks</code></li></ul><h2 id="_80-vue中是如何检测数组变化的呢" tabindex="-1"><a class="header-anchor" href="#_80-vue中是如何检测数组变化的呢" aria-hidden="true">#</a> 80 vue中是如何检测数组变化的呢</h2><blockquote><p>数组就是使用 <code>object.defineProperty</code> 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， <code>pop</code> 、 <code>push</code> 、 <code>shift</code> 、 <code>unshift</code> 、 <code>splice</code> 、 <code>sort</code> 、 <code>reverse</code> 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解</p></blockquote><ul><li>是用函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新</li><li>数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）</li></ul><blockquote><p><code>vue3</code>：改用 <code>proxy</code> ，可直接监听对象数组的变化</p></blockquote><h2 id="_81-vue的事件绑定原理" tabindex="-1"><a class="header-anchor" href="#_81-vue的事件绑定原理" aria-hidden="true">#</a> 81 Vue的事件绑定原理</h2><ul><li>原生 DOM 的绑定：Vue在创建真实DOM时会调用 <code>createElm</code> ，默认会调用 <code>invokeCreateHooks</code> 。会遍历当前平台下相对的属性处理代码，其中就有 <code>updateDOMLListeners</code>方法，内部会传入 <code>add（）</code> 方法</li><li>组件绑定事件，原生事件，自定义事件；组件绑定之间是通过<code>Vue</code>中自定义的 <code>$on</code> 方法实现的</li></ul><blockquote><p>可以理解为：组件的 <code>nativeOnOn</code> 等价于 普通元素on 组件的on会单独处理</p></blockquote><h2 id="_82-v-model中的实现原理及如何自定义v-model" tabindex="-1"><a class="header-anchor" href="#_82-v-model中的实现原理及如何自定义v-model" aria-hidden="true">#</a> 82 v-model中的实现原理及如何自定义v-model</h2><blockquote><p><code>v-model</code> 可以看成是 <code>value+input</code> 方法的语法糖（组件）。原生的 <code>v-model</code> ，会根据标签的不同生成不同的事件与属性。解析一个指令来</p></blockquote><p>自定义：自己写 <code>model</code> 属性，里面放上 <code>prop</code> 和 <code>event</code></p><h2 id="_83-为什么vue采用异步渲染呢" tabindex="-1"><a class="header-anchor" href="#_83-为什么vue采用异步渲染呢" aria-hidden="true">#</a> 83 为什么Vue采用异步渲染呢</h2><blockquote><p>Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 <code>nextTick</code></p></blockquote><p><code>dep.notify（）</code> 通知 <code>watcher</code>进行更新， subs[i].update 依次调用 <code>watcher</code> 的 <code>update</code> ， <code>queueWatcher</code> 将<code>watcher</code> 去重放入队列， nextTick（ flushSchedulerQueue ）在下一<code>tick</code>中刷新<code>watcher</code>队列（异步）</p><h2 id="_84-vuex-工作原理" tabindex="-1"><a class="header-anchor" href="#_84-vuex-工作原理" aria-hidden="true">#</a> 84 Vuex 工作原理</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p><p>状态自管理应用包含以下几个部分：</p><ul><li>state，驱动应用的数据源；</li><li>view，以声明方式将 state 映射到视图；</li><li>actions，响应在 view 上的用户输入导致的状态变化。下图单向数据流示意图：</li></ul><p><img src="/assets/image-20210220193818922.6dc29f6f.png" alt=""></p><p>vuex，多组件共享状态，因-单向数据流简洁性很容易被破坏：</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态</li></ul><p><img src="/assets/202203211356439.939d172f.png" alt=""></p><h2 id="_85-如何从真实dom到虚拟dom" tabindex="-1"><a class="header-anchor" href="#_85-如何从真实dom到虚拟dom" aria-hidden="true">#</a> 85 如何从真实DOM到虚拟DOM</h2><p>涉及到Vue中的模板编译原理，主要过程：</p><ol><li>将模板转换成<code>ast</code> 树，<code>ast</code> 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）</li><li>优化树</li><li>将<code>ast</code> 树生成代码</li></ol><h2 id="_86-computed-watch-和-method" tabindex="-1"><a class="header-anchor" href="#_86-computed-watch-和-method" aria-hidden="true">#</a> 86 Computed watch 和 method</h2><ul><li>computed：默认<code>computed</code>也是一个<code>watcher</code>具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用<code>computed</code></li><li>watch：每次都需要执行函数。 <code>watch</code> 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。</li><li>method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大</li></ul><h2 id="_87-为什么要使用异步组件" tabindex="-1"><a class="header-anchor" href="#_87-为什么要使用异步组件" aria-hidden="true">#</a> 87 为什么要使用异步组件？</h2><ol><li>节省打包出的结果，异步组件分开打包，采用<code>jsonp</code>的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖<code>import（）</code> 语法，可以实现文件的分割加载。</li></ol><h2 id="_88-action-与-mutation-的区别" tabindex="-1"><a class="header-anchor" href="#_88-action-与-mutation-的区别" aria-hidden="true">#</a> 88 action 与 mutation 的区别</h2><ul><li><code>mutation</code> 是同步更新，<code>$watch</code> 严格模式下会报错</li><li><code>action</code> 是同步操作，可以获取数据后调用<code>mutation</code> 提交最终数据</li></ul><h2 id="_89-插槽与作用域插槽的区别" tabindex="-1"><a class="header-anchor" href="#_89-插槽与作用域插槽的区别" aria-hidden="true">#</a> 89 插槽与作用域插槽的区别</h2><p>插槽</p><ul><li>创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类<code>{a:[vnode],b[vnode]}</code></li><li>渲染组件时会拿对应的<code>slot</code> 属性的节点进行替换操作。（插槽的作用域为父组件）</li></ul><p>作用域插槽</p><ul><li>作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。</li><li>普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。</li></ul><h2 id="_90-vue中相同逻辑如何抽离" tabindex="-1"><a class="header-anchor" href="#_90-vue中相同逻辑如何抽离" aria-hidden="true">#</a> 90 vue中相同逻辑如何抽离</h2><blockquote><p>其实就是考察<code>vue.mixin</code> 用法，给组件每个生命周期，函数都混入一些公共逻辑。</p></blockquote><h2 id="_91-谈谈对keep-alive的了解" tabindex="-1"><a class="header-anchor" href="#_91-谈谈对keep-alive的了解" aria-hidden="true">#</a> 91 谈谈对keep-alive的了解</h2><blockquote><p><code>keep-alive</code> 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性<code>include/exclude</code> ，2个生命周期<code>activated</code> ，<code>deactivated</code></p></blockquote><h2 id="_92-vue性能优化" tabindex="-1"><a class="header-anchor" href="#_92-vue性能优化" aria-hidden="true">#</a> 92 Vue性能优化</h2><p>编码优化：</p><ul><li>事件代理</li><li><code>keep-alive</code></li><li>拆分组件</li><li><code>key</code> 保证唯一性</li><li>路由懒加载、异步组件</li><li>防抖节流</li></ul><p>Vue加载性能优化</p><ul><li>第三方模块按需导入（<code>babel-plugin-component</code> ）</li><li>图片懒加载</li></ul><p>用户体验</p><ul><li><code>app-skeleton</code> 骨架屏</li><li><code>shellap</code> p壳</li><li><code>pwa</code></li></ul><p>SEO优化</p><ul><li>预渲染</li></ul><h2 id="_93-vue3-0相对于vue2-x有哪些不同" tabindex="-1"><a class="header-anchor" href="#_93-vue3-0相对于vue2-x有哪些不同" aria-hidden="true">#</a> 93 Vue3.0相对于Vue2.x有哪些不同？</h2><p>performance</p><p>首先在性能(performance)上有了更多的优化，一方面表现在<code>virtual dom</code>的生成上更快了，另外在底层还做了一些监听的缓存，也就是事件在被创建的时候会被推进一个缓存中，后续没有改变会直接取缓存。</p><p>tree-shaking</p><p>tree-shaking它表示的是在打包的时候会去除一些无用的代码。而在Vue3中对它的支持更加友好了，例如像transition、v-model、computed等功能没有用到的话，那么最后打包产生的代码就会将它们去除。也就是说，如果你的Vue项目只写了一个Hello Word的话，那么最后打包的代码中就只有一些核心的代码，如更新算法、响应式等，打包生成的文件可能就只有13.5kb。</p><p>Fragments</p><p>碎片(Fragments)，原本在Vue2.x中每个template下只能允许有一个根节点，但是在Vue3中它可以允许你有多个，用尤大大的话来说就是会将这些内容自动变为一个碎片。</p><p>TS</p><p>再者就是对TS的支持度很好。虽然Vue3本来就是用TS写的，但是不一定要用TS。另外它也支持Class Component，不过不是第一推荐。</p><p>Component API</p><p>语法上，对模版语法是零改变的。只不过更加推荐用Component API来写JS部分。Component API它并不是语法，而是新增的API。它带来的好处一个是逻辑重用，方便我们把一些功能的部分抽离出来。另一个它相对于options来说更加集中，用options来写代码想要追寻一个变量的变化比较麻烦。</p><p>关于兼容性</p><p>目前的Vue3.beta版本是不支持IE11的，因为核心的响应式原理用到了ES6的Proxy，但是以后会去兼容IE11。后面我们在创建一个Vue项目的时候，可以选择不同的版本，支持IE11和不支持IE11的。</p><p>什么时候能使用</p><p>现在的beta版本其实已经可以用了，对于一些新的小的项目可以试试水，这个可以自己评估。正式能够投入到生产使用中可能要等到年中 (终？)。</p><h2 id="_94-vue中hash模式和history模式的区别" tabindex="-1"><a class="header-anchor" href="#_94-vue中hash模式和history模式的区别" aria-hidden="true">#</a> 94 Vue中hash模式和history模式的区别</h2><ul><li>最明显的是在显示上，<code>hash</code>模式的<code>URL</code>中会夹杂着<code>#</code>号，而<code>history</code>没有。</li><li><code>Vue</code>底层对它们的实现方式不同。<code>hash</code>模式是依靠<code>onhashchange</code>事件(监听<code>location.hash</code>的改变)，而<code>history</code>模式是主要是依靠的<code>HTML5 history</code>中新增的两个方法，<code>pushState()</code>可以改变<code>url</code>地址且不会发送请求，<code>replaceState()</code>可以读取历史记录栈,还可以对浏览器记录进行修改。</li><li>当真正需要通过<code>URL</code>向后端发送<code>HTTP</code>请求的时候，比如常见的用户手动输入<code>URL</code>后回车，或者是刷新(重启)浏览器，这时候<code>history</code>模式需要后端的支持。因为<code>history</code>模式下，前端的<code>URL</code>必须和实际向后端发送请求的<code>URL</code>一致，例如有一个<code>URL</code>是带有路径<code>path</code>的(例如<code>www.lindaidai.wang/blogs/id</code>)，如果后端没有对这个路径做处理的话，就会返回<code>404</code>错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个<code>404</code>页面。</li></ul><p><code>hash:</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>window.onhashchange = function(event){
  // location.hash获取到的是包括#号的，如&quot;#heading-3&quot;
  // 所以可以截取一下
	let hash = location.hash.slice(1);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_95-了解history有哪些方法吗-说下它们的区别" tabindex="-1"><a class="header-anchor" href="#_95-了解history有哪些方法吗-说下它们的区别" aria-hidden="true">#</a> 95 了解history有哪些方法吗？说下它们的区别</h2><p>history 这个对象在html5的时候新加入两个api history.pushState() 和 history.repalceState() 这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。</p><p>从参数上来说：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, &#39;./qq/&#39;)，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, &#39;/qq/&#39;)，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外还有：</p><ul><li><code>window.history.back()</code> 后退</li><li><code>window.history.forward()</code>前进</li><li><code>window.history.go(1)</code> 前进或者后退几步</li></ul><p>从触发事件的监听上来说：</p><ul><li><code>pushState()</code>和<code>replaceState()</code>不能被<code>popstate</code>事件所监听</li><li>而后面三者可以，且用户点击浏览器前进后退键时也可以</li></ul><h2 id="_96-如何监听-pushstate-和-replacestate-的变化呢" tabindex="-1"><a class="header-anchor" href="#_96-如何监听-pushstate-和-replacestate-的变化呢" aria-hidden="true">#</a> 96 如何监听 pushState 和 replaceState 的变化呢？</h2><p>利用自定义事件<code>new Event()</code>创建这两个事件，并全局监听：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;body&gt;
  &lt;button onclick=&quot;goPage2()&quot;&gt;去page2&lt;/button&gt;
  &lt;div&gt;Page1&lt;/div&gt;
  &lt;script&gt;
    let count = 0;
    function goPage2 () {
      history.pushState({ count: count++ }, `bb${count}`,&#39;page1.html&#39;)
      console.log(history)
    }
    // 这个不能监听到 pushState
    // window.addEventListener(&#39;popstate&#39;, function (event) {
    //   console.log(event)
    // })
    function createHistoryEvent (type) {
      var fn = history[type]
      return function () {
        // 这里的 arguments 就是调用 pushState 时的三个参数集合
        var res = fn.apply(this, arguments)
        let e = new Event(type)
        e.arguments = arguments
        window.dispatchEvent(e)
        return res
      }
    }
    history.pushState = createHistoryEvent(&#39;pushState&#39;)
    history.replaceState = createHistoryEvent(&#39;replaceState&#39;)
    window.addEventListener(&#39;pushState&#39;, function (event) {
      // { type: &#39;pushState&#39;, arguments: [...], target: Window, ... }
      console.log(event)
    })
    window.addEventListener(&#39;replaceState&#39;, function (event) {
      console.log(event)
    })
  &lt;/script&gt;
&lt;/body&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_97-vue组件内的导航守卫有哪几个" tabindex="-1"><a class="header-anchor" href="#_97-vue组件内的导航守卫有哪几个" aria-hidden="true">#</a> 97 Vue组件内的导航守卫有哪几个？</h2><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code></li><li><code>beforeLeave</code></li></ul><h2 id="_98-beforerouteenter和另外两个有什么不同吗" tabindex="-1"><a class="header-anchor" href="#_98-beforerouteenter和另外两个有什么不同吗" aria-hidden="true">#</a> 98 beforeRouteEnter和另外两个有什么不同吗？</h2><p><code>beforeRouteEnter</code>是支持给<code>next</code>传递参数的唯一守卫，因为在这个路由守卫中还不能访问this，而为了能让我们访问组件实例，可以通过传一个回调给<code>next</code>：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>beforeRouteEnter(to, from, next) {
	next(vm =&gt; {
		// vm 就是组件实例
	})	
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而对于另外两个，<code>this</code>已经可用，所以不支持传递回调：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>离开守卫<code>beforeRouteLeave</code>通常用来禁止用户还未保存修改之前离开，可以通过<code>next(false)</code>来取消：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>beforeRouteLeave (to, from, next) {
  const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)
  if (answer) {
    next()
  } else {
    next(false)
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_99-完整的导航解析流程" tabindex="-1"><a class="header-anchor" href="#_99-完整的导航解析流程" aria-hidden="true">#</a> 99 完整的导航解析流程</h2><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol><h2 id="_100-你是怎么看vue和react的" tabindex="-1"><a class="header-anchor" href="#_100-你是怎么看vue和react的" aria-hidden="true">#</a> 100 你是怎么看Vue和React的？</h2><p>首先它们都是当今比较流行的前端框架。</p><p>相同点：</p><ol><li><code>Virtual DOM</code>。其中最大的一个相似之处就是都使用了<code>Virtual DOM</code>。(当然<code>Vue</code>是在<code>Vue2.x</code>才引用的)也就是能让我们通过操作数据的方式来改变真实的<code>DOM</code>状态。因为其实<code>Virtual DOM</code>的本质就是一个<code>JS</code>对象，它保存了对真实<code>DOM</code>的所有描述，是真实<code>DOM</code>的一个映射，所以当我们在进行频繁更新元素的时候，改变这个<code>JS</code>对象的开销远比直接改变真实<code>DOM</code>要小得多。</li><li>组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。</li><li><code>Props</code>。<code>Vue</code>和<code>React</code>中都有<code>props</code>的概念，允许父组件向子组件传递数据。</li><li>构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，<code>React</code>中可以使用<code>CRA</code>，<code>Vue</code>中可以使用对应的脚手架<code>vue-cli</code>。对于配套框架<code>Vue</code>中有<code>vuex、vue-router</code>，<code>React</code>中有<code>react-router、redux</code>。</li></ol><p>不同点</p><ol><li>模版的编写。最大的不同就是模版的编写，<code>Vue</code>鼓励你去写近似常规<code>HTML</code>的模板，<code>React</code>推荐你使用<code>JSX</code>去书写。</li><li>状态管理与对象属性。在<code>React</code>中，应用的状态是比较关键的概念，也就是<code>state</code>对象，它允许你使用<code>setState</code>去更新状态。但是在<code>Vue</code>中，<code>state</code>对象并不是必须的，数据是由<code>data</code>属性在<code>Vue</code>对象中进行管理。</li><li>虚拟<code>DOM</code>的处理方式不同。<code>Vue</code>中的虚拟<code>DOM</code>控制了颗粒度，组件层面走<code>watcher</code>通知，而组件内部走<code>vdom</code>做<code>diff</code>，这样，既不会有太多<code>watcher</code>，也不会让<code>vdom</code>的规模过大。而<code>React</code>走了类似于<code>CPU</code>调度的逻辑，把<code>vdom</code>这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做<code>diff</code>。</li></ol></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/selected/React%E6%A8%A1%E5%9D%97.html" class="" aria-label="React模块"><!--[--><!--]--> React模块 <!--[--><!--]--></a></span><span class="next"><a href="/selected/Node%E6%A8%A1%E5%9D%97.html" class="" aria-label="Node模块"><!--[--><!--]--> Node模块 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.12353158.js" defer></script>
  </body>
</html>
