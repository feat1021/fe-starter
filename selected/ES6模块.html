<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>ES6模块 | Frontend Starter</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.12353158.js"><link rel="modulepreload" href="/assets/ES6模块.html.2ea3507a.js"><link rel="modulepreload" href="/assets/ES6模块.html.0f2bfddb.js"><link rel="prefetch" href="/assets/index.html.ee998a26.js"><link rel="prefetch" href="/assets/CSS.html.c64e9431.js"><link rel="prefetch" href="/assets/HTML.html.a70e4433.js"><link rel="prefetch" href="/assets/HTTP.html.6dbdd949.js"><link rel="prefetch" href="/assets/JS基础.html.0a913d15.js"><link rel="prefetch" href="/assets/React.html.6802a56c.js"><link rel="prefetch" href="/assets/Vue.html.a81339b7.js"><link rel="prefetch" href="/assets/工程化.html.0c152696.js"><link rel="prefetch" href="/assets/性能.html.090fde92.js"><link rel="prefetch" href="/assets/框架通识.html.1a3f58ab.js"><link rel="prefetch" href="/assets/浏览器.html.2ec19a51.js"><link rel="prefetch" href="/assets/设计模式.html.5761cd54.js"><link rel="prefetch" href="/assets/Bootstrap.html.86ad9734.js"><link rel="prefetch" href="/assets/CSS.html.e3ee6176.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.6603dd61.js"><link rel="prefetch" href="/assets/JavaScript.html.14aca0a4.js"><link rel="prefetch" href="/assets/Webpack.html.f773c5e1.js"><link rel="prefetch" href="/assets/jQuery.html.c3b9972e.js"><link rel="prefetch" href="/assets/其他.html.c716f6ee.js"><link rel="prefetch" href="/assets/微信小程序.html.0335a142.js"><link rel="prefetch" href="/assets/综合.html.5dfe757e.js"><link rel="prefetch" href="/assets/编程题.html.cbfc1c8c.js"><link rel="prefetch" href="/assets/性能优化.html.30c3f1c5.js"><link rel="prefetch" href="/assets/高频考点.html.2ee4efd2.js"><link rel="prefetch" href="/assets/handwritten.html.879fcb5e.js"><link rel="prefetch" href="/assets/JavaScript.html.bcb5a0d9.js"><link rel="prefetch" href="/assets/Node.html.be9ed4e1.js"><link rel="prefetch" href="/assets/React.html.36beeb6b.js"><link rel="prefetch" href="/assets/Vue.html.b739e835.js"><link rel="prefetch" href="/assets/Webpack.html.b34fb870.js"><link rel="prefetch" href="/assets/综合.html.30e0bc70.js"><link rel="prefetch" href="/assets/CSS模块.html.99bd45d7.js"><link rel="prefetch" href="/assets/HTML模块.html.4fb65265.js"><link rel="prefetch" href="/assets/HTTP模块.html.b4ce19f7.js"><link rel="prefetch" href="/assets/JS模块.html.015ff251.js"><link rel="prefetch" href="/assets/Node模块.html.b1985276.js"><link rel="prefetch" href="/assets/React模块.html.f53e1f03.js"><link rel="prefetch" href="/assets/Vue模块.html.785747a6.js"><link rel="prefetch" href="/assets/前端安全模块.html.f0f98ff3.js"><link rel="prefetch" href="/assets/前端工程相关.html.183e2c9f.js"><link rel="prefetch" href="/assets/小程序模块.html.f7ab4d91.js"><link rel="prefetch" href="/assets/常用设计模式.html.03f9722f.js"><link rel="prefetch" href="/assets/性能优化相关.html.12e8a2e3.js"><link rel="prefetch" href="/assets/排序算法.html.40481e91.js"><link rel="prefetch" href="/assets/框架通识.html.c3c3096b.js"><link rel="prefetch" href="/assets/浏览器模块.html.24652566.js"><link rel="prefetch" href="/assets/移动多端开发.html.8636371c.js"><link rel="prefetch" href="/assets/计算机通识.html.728b7ceb.js"><link rel="prefetch" href="/assets/404.html.93c18560.js"><link rel="prefetch" href="/assets/index.html.60500264.js"><link rel="prefetch" href="/assets/CSS.html.02fa634c.js"><link rel="prefetch" href="/assets/HTML.html.3a31cd64.js"><link rel="prefetch" href="/assets/HTTP.html.a1df6d3a.js"><link rel="prefetch" href="/assets/JS基础.html.b88ab559.js"><link rel="prefetch" href="/assets/React.html.4ec983c7.js"><link rel="prefetch" href="/assets/Vue.html.5c58cab9.js"><link rel="prefetch" href="/assets/工程化.html.863e35db.js"><link rel="prefetch" href="/assets/性能.html.470e0a6f.js"><link rel="prefetch" href="/assets/框架通识.html.32d2fbab.js"><link rel="prefetch" href="/assets/浏览器.html.8279ebd9.js"><link rel="prefetch" href="/assets/设计模式.html.6afe6cf3.js"><link rel="prefetch" href="/assets/Bootstrap.html.2cc414a0.js"><link rel="prefetch" href="/assets/CSS.html.5d66e791.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.bbea8927.js"><link rel="prefetch" href="/assets/JavaScript.html.07acfd24.js"><link rel="prefetch" href="/assets/Webpack.html.a1c5dce1.js"><link rel="prefetch" href="/assets/jQuery.html.4e2f3899.js"><link rel="prefetch" href="/assets/其他.html.929587e1.js"><link rel="prefetch" href="/assets/微信小程序.html.69cc86fd.js"><link rel="prefetch" href="/assets/综合.html.1c892aa5.js"><link rel="prefetch" href="/assets/编程题.html.5478af99.js"><link rel="prefetch" href="/assets/性能优化.html.337c4654.js"><link rel="prefetch" href="/assets/高频考点.html.8772c401.js"><link rel="prefetch" href="/assets/handwritten.html.0f0ee7e3.js"><link rel="prefetch" href="/assets/JavaScript.html.5dd72bd0.js"><link rel="prefetch" href="/assets/Node.html.7eac5124.js"><link rel="prefetch" href="/assets/React.html.d8ccb952.js"><link rel="prefetch" href="/assets/Vue.html.47efbab1.js"><link rel="prefetch" href="/assets/Webpack.html.793df544.js"><link rel="prefetch" href="/assets/综合.html.ff78888d.js"><link rel="prefetch" href="/assets/CSS模块.html.bcc3cfc7.js"><link rel="prefetch" href="/assets/HTML模块.html.6b729342.js"><link rel="prefetch" href="/assets/HTTP模块.html.2c6adffa.js"><link rel="prefetch" href="/assets/JS模块.html.28259fe6.js"><link rel="prefetch" href="/assets/Node模块.html.c36cd1fb.js"><link rel="prefetch" href="/assets/React模块.html.b09a5954.js"><link rel="prefetch" href="/assets/Vue模块.html.a27ab950.js"><link rel="prefetch" href="/assets/前端安全模块.html.e3aebe2f.js"><link rel="prefetch" href="/assets/前端工程相关.html.281b6ffe.js"><link rel="prefetch" href="/assets/小程序模块.html.493268db.js"><link rel="prefetch" href="/assets/常用设计模式.html.a600f326.js"><link rel="prefetch" href="/assets/性能优化相关.html.aff23982.js"><link rel="prefetch" href="/assets/排序算法.html.361967d5.js"><link rel="prefetch" href="/assets/框架通识.html.7719e539.js"><link rel="prefetch" href="/assets/浏览器模块.html.ac4e495d.js"><link rel="prefetch" href="/assets/移动多端开发.html.d8fc5993.js"><link rel="prefetch" href="/assets/计算机通识.html.0e8ab127.js"><link rel="prefetch" href="/assets/404.html.232c3875.js"><link rel="prefetch" href="/assets/404.176778df.js"><link rel="prefetch" href="/assets/Layout.ac3a6e88.js">
    <link rel="stylesheet" href="/assets/style.20e644be.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Frontend Starter</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">基础 Basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/basic/HTTP%20&amp;%20HTML.html" class="sidebar-item" aria-label="HTML、HTTP、Web"><!--[--><!--]--> HTML、HTTP、Web <!--[--><!--]--></a><!----></li><li><a href="/basic/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/basic/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/basic/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/basic/Bootstrap.html" class="sidebar-item" aria-label="Bootstrap"><!--[--><!--]--> Bootstrap <!--[--><!--]--></a><!----></li><li><a href="/basic/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BC%96%E7%A8%8B%E9%A2%98.html" class="sidebar-item" aria-label="编程题"><!--[--><!--]--> 编程题 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%85%B6%E4%BB%96.html" class="sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">进阶 Advanced <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/advanced/JS%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/advanced/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%B5%8F%E8%A7%88%E5%99%A8.html" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/advanced/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/advanced/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%80%A7%E8%83%BD.html" class="sidebar-item" aria-label="性能"><!--[--><!--]--> 性能 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="sidebar-item" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">精选 Selected <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/selected/HTML%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTML模块"><!--[--><!--]--> HTML模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/CSS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="CSS模块"><!--[--><!--]--> CSS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/JS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="JS模块"><!--[--><!--]--> JS模块 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="ES6模块"><!--[--><!--]--> ES6模块 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_1-es5、es6和es2015有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 ES5、ES6和ES2015有什么区别?"><!--[--><!--]--> 1 ES5、ES6和ES2015有什么区别? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_2-babel是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 babel是什么，有什么作用?"><!--[--><!--]--> 2 babel是什么，有什么作用? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_3-let有什么用-有了var为什么还要用let" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 let有什么用，有了var为什么还要用let？"><!--[--><!--]--> 3 let有什么用，有了var为什么还要用let？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_4-举一些es6对string字符串类型做的常用升级优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 举一些ES6对String字符串类型做的常用升级优化?"><!--[--><!--]--> 4 举一些ES6对String字符串类型做的常用升级优化? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_5-举一些es6对array数组类型做的常用升级优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 举一些ES6对Array数组类型做的常用升级优化"><!--[--><!--]--> 5 举一些ES6对Array数组类型做的常用升级优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_6-举一些es6对number数字类型做的常用升级优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 举一些ES6对Number数字类型做的常用升级优化"><!--[--><!--]--> 6 举一些ES6对Number数字类型做的常用升级优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_7-举一些es6对object类型做的常用升级优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="7 举一些ES6对Object类型做的常用升级优化"><!--[--><!--]--> 7 举一些ES6对Object类型做的常用升级优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_8-举一些es6对function函数类型做的常用升级优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="8 举一些ES6对Function函数类型做的常用升级优化?"><!--[--><!--]--> 8 举一些ES6对Function函数类型做的常用升级优化? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_9-symbol是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="9 Symbol是什么，有什么作用？"><!--[--><!--]--> 9 Symbol是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_10-set是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="10 Set是什么，有什么作用？"><!--[--><!--]--> 10 Set是什么，有什么作用？ <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#介绍下-set、map、weakset-和-weakmap-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="介绍下 Set、Map、WeakSet 和 WeakMap 的区别"><!--[--><!--]--> 介绍下 Set、Map、WeakSet 和 WeakMap 的区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_11-map是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="11 Map是什么，有什么作用？"><!--[--><!--]--> 11 Map是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_12-proxy是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="12 Proxy是什么，有什么作用？"><!--[--><!--]--> 12 Proxy是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_13-reflect是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="13 Reflect是什么，有什么作用？"><!--[--><!--]--> 13 Reflect是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_14-promise是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="14 Promise是什么，有什么作用？"><!--[--><!--]--> 14 Promise是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_15-iterator是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="15 Iterator是什么，有什么作用？"><!--[--><!--]--> 15 Iterator是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_16-for-in-和for-of有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="16 for...in 和for...of有什么区别？"><!--[--><!--]--> 16 for...in 和for...of有什么区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_17-generator函数是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="17 Generator函数是什么，有什么作用？"><!--[--><!--]--> 17 Generator函数是什么，有什么作用？ <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#generator-原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="generator 原理"><!--[--><!--]--> generator 原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#generator-实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="Generator 实现"><!--[--><!--]--> Generator 实现 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_18-async函数是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="18 async函数是什么，有什么作用？"><!--[--><!--]--> 18 async函数是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_19-class、extends是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="19 Class、extends是什么，有什么作用？"><!--[--><!--]--> 19 Class、extends是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_20-module、export、import是什么-有什么作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="20 module、export、import是什么，有什么作用？"><!--[--><!--]--> 20 module、export、import是什么，有什么作用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_21-日常前端代码开发中-有哪些值得用es6去改进的编程优化或者规范" class="router-link-active router-link-exact-active sidebar-item" aria-label="21 日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"><!--[--><!--]--> 21 日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_22-es6的了解" class="router-link-active router-link-exact-active sidebar-item" aria-label="22 ES6的了解"><!--[--><!--]--> 22 ES6的了解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_23-说说你对promise的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="23 说说你对Promise的理解"><!--[--><!--]--> 23 说说你对Promise的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_24-promise-的构造函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="24 Promise 的构造函数"><!--[--><!--]--> 24 Promise 的构造函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_25-谈一谈你了解ecmascript6的新特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="25 谈一谈你了解ECMAScript6的新特性？"><!--[--><!--]--> 25 谈一谈你了解ECMAScript6的新特性？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_26-object-is-与原来的比较操作符-、-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="26 Object.is() 与原来的比较操作符 ===、== 的区别？"><!--[--><!--]--> 26 Object.is() 与原来的比较操作符 ===、== 的区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_27-什么是-babel" class="router-link-active router-link-exact-active sidebar-item" aria-label="27 什么是 Babel"><!--[--><!--]--> 27 什么是 Babel <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_28-symbol-有什么用处" class="router-link-active router-link-exact-active sidebar-item" aria-label="28 symbol 有什么用处"><!--[--><!--]--> 28 symbol 有什么用处 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_29-模块化" class="router-link-active router-link-exact-active sidebar-item" aria-label="29 模块化"><!--[--><!--]--> 29 模块化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_30-箭头函数的特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="30 箭头函数的特点"><!--[--><!--]--> 30 箭头函数的特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_31-es5-es6-的继承除了写法以外还有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="31 ES5 / ES6 的继承除了写法以外还有什么区别"><!--[--><!--]--> 31 ES5 / ES6 的继承除了写法以外还有什么区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_32-全局作用域中-用-const-和-let-声明的变量不在-window-上-那到底在哪里-如何去获取" class="router-link-active router-link-exact-active sidebar-item" aria-label="32 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？"><!--[--><!--]--> 32 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_33-介绍下-set、map、weakset-和-weakmap-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="33 介绍下 Set、Map、WeakSet 和 WeakMap 的区别"><!--[--><!--]--> 33 介绍下 Set、Map、WeakSet 和 WeakMap 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#_34-promise-all-和-promise-allsettled-的比较" class="router-link-active router-link-exact-active sidebar-item" aria-label="34 Promise.all() 和 Promise.allSettled()的比较"><!--[--><!--]--> 34 Promise.all() 和 Promise.allSettled()的比较 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#promise-allsettled" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.allSettled()"><!--[--><!--]--> Promise.allSettled() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/selected/ES6%E6%A8%A1%E5%9D%97.html#promise-all" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.all()"><!--[--><!--]--> Promise.all() <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/selected/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="浏览器模块"><!--[--><!--]--> 浏览器模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/React%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="React模块"><!--[--><!--]--> React模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Vue%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Vue模块"><!--[--><!--]--> Vue模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Node%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Node模块"><!--[--><!--]--> Node模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="前端工程相关"><!--[--><!--]--> 前端工程相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="移动多端开发"><!--[--><!--]--> 移动多端开发 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="小程序模块"><!--[--><!--]--> 小程序模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="前端安全模块"><!--[--><!--]--> 前端安全模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="性能优化相关"><!--[--><!--]--> 性能优化相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/HTTP%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTTP模块"><!--[--><!--]--> HTTP模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="常用设计模式"><!--[--><!--]--> 常用设计模式 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="计算机通识"><!--[--><!--]--> 计算机通识 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">高频 Frequency <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/frequency/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" class="sidebar-item" aria-label="高频考点"><!--[--><!--]--> 高频考点 <!--[--><!--]--></a><!----></li><li><a href="/frequency/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">原理 Principle <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/principle/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/principle/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/principle/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/principle/Node.html" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><li><a href="/principle/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/principle/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="es6模块" tabindex="-1"><a class="header-anchor" href="#es6模块" aria-hidden="true">#</a> ES6模块</h1><hr><h2 id="_1-es5、es6和es2015有什么区别" tabindex="-1"><a class="header-anchor" href="#_1-es5、es6和es2015有什么区别" aria-hidden="true">#</a> 1 ES5、ES6和ES2015有什么区别?</h2><blockquote><p><code>ES2015</code>特指在<code>2015</code>年发布的新一代<code>JS</code>语言标准，<code>ES6</code>泛指下一代JS语言标准，包含<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>等。现阶段在绝大部分场景下，<code>ES2015</code>默认等同<code>ES6</code>。<code>ES5</code>泛指上一代语言标准。<code>ES2015</code>可以理解为<code>ES5</code>和<code>ES6</code>的时间分界线</p></blockquote><h2 id="_2-babel是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_2-babel是什么-有什么作用" aria-hidden="true">#</a> 2 babel是什么，有什么作用?</h2><blockquote><p><code>babel</code>是一个 <code>ES6</code> 转码器，可以将 <code>ES6</code> 代码转为 <code>ES5</code> 代码，以便兼容那些还没支持<code>ES6</code>的平台</p></blockquote><h2 id="_3-let有什么用-有了var为什么还要用let" tabindex="-1"><a class="header-anchor" href="#_3-let有什么用-有了var为什么还要用let" aria-hidden="true">#</a> 3 let有什么用，有了var为什么还要用let？</h2><blockquote><p>在<code>ES6</code>之前，声明变量只能用<code>var</code>，<code>var</code>方式声明变量其实是很不合理的，准确的说，是因为<code>ES5</code>里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如<code>for</code>循环<code>var</code>变量泄露，变量覆盖等问题。<code>let</code>声明的变量拥有自己的块级作用域，且修复了<code>var</code>声明变量带来的变量提升问题。</p></blockquote><h2 id="_4-举一些es6对string字符串类型做的常用升级优化" tabindex="-1"><a class="header-anchor" href="#_4-举一些es6对string字符串类型做的常用升级优化" aria-hidden="true">#</a> 4 举一些ES6对String字符串类型做的常用升级优化?</h2><p>优化部分</p><blockquote><p><code>ES6</code>新增了字符串模板，在拼接大段字符串时，用反斜杠<code>(</code>)`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅</p></blockquote><p>升级部分</p><blockquote><p><code>ES6</code>在<code>String</code>原型上新增了<code>includes()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含字符的方法(<code>indexOf</code>返回<code>-1</code>表示没查到不如<code>includes</code>方法返回<code>false</code>更明确，语义更清晰), 此外还新增了<code>startsWith()</code>, <code>endsWith(),</code> <code>padStart()</code>,<code>padEnd()</code>,<code>repeat()</code>等方法，可方便的用于查找，补全字符串</p></blockquote><h2 id="_5-举一些es6对array数组类型做的常用升级优化" tabindex="-1"><a class="header-anchor" href="#_5-举一些es6对array数组类型做的常用升级优化" aria-hidden="true">#</a> 5 举一些ES6对Array数组类型做的常用升级优化</h2><p>优化部分</p><ul><li>数组解构赋值。<code>ES6</code>可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多<code>let(var),</code>且映射关系清晰，且支持赋默认值</li><li>扩展运算符。<code>ES6</code>新增的扩展运算符(<code>...</code>)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代<code>arguments</code>对象和<code>apply</code>方法，轻松获取未知参数个数情况下的参数集合。（尤其是在<code>ES5</code>中，<code>arguments</code>并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]</code>; <code>let b = [...a]</code>）</li></ul><p>升级部分</p><blockquote><p><code>ES6</code>在<code>Array</code>原型上新增了<code>find()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含数组项目的方法,且修复了<code>indexOf</code>查找不到<code>NaN的bug([NaN].indexOf(NaN) === -1)</code>.此外还新增了<code>copyWithin()</code>,<code>includes()</code>, <code>fill()</code>,<code>flat()</code>等方法，可方便的用于字符串的查找，补全,转换等</p></blockquote><h2 id="_6-举一些es6对number数字类型做的常用升级优化" tabindex="-1"><a class="header-anchor" href="#_6-举一些es6对number数字类型做的常用升级优化" aria-hidden="true">#</a> 6 举一些ES6对Number数字类型做的常用升级优化</h2><p>优化部分</p><blockquote><p>ES6在<code>Number</code>原型上新增了<code>isFinite()</code>, <code>isNaN()</code>方法，用来取代传统的全局<code>isFinite(),</code> <code>isNaN()</code>方法检测数值是否有限、是否是<code>NaN</code>。<code>ES5</code>的<code>isFinite()</code>, <code>isNaN()</code>方法都会先将非数值类型的参数转化为<code>Number</code>类型再做判断，这其实是不合理的，最造成i<code>sNaN(&#39;NaN&#39;) === true</code>的奇怪行为<code>--&#39;NaN&#39;</code>是一个字符串，但是<code>isNaN</code>却说这就是<code>NaN</code>。而<code>Number.isFinite()</code>和<code>Number.isNaN()</code>则不会有此类问题(<code>Number.isNaN(&#39;NaN&#39;) === false</code>)。（<code>isFinite()</code>同上）</p></blockquote><p>升级部分</p><blockquote><p><code>ES6</code>在<code>Math</code>对象上新增了<code>Math.cbrt()</code>，<code>trunc()</code>，<code>hypot()</code>等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算</p></blockquote><h2 id="_7-举一些es6对object类型做的常用升级优化" tabindex="-1"><a class="header-anchor" href="#_7-举一些es6对object类型做的常用升级优化" aria-hidden="true">#</a> 7 举一些ES6对Object类型做的常用升级优化</h2><p>优化部分</p><blockquote><p>对象属性变量式声明。<code>ES6</code>可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let [apple, orange] = [&#39;red appe&#39;, &#39;yellow orange&#39;];
let myFruits = {apple, orange};    // let myFruits = {apple: &#39;red appe&#39;, orange: &#39;yellow orange&#39;};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let {keys, values, entries} = Object;
let MyOwnMethods = {keys, values, entries}; // let MyOwnMethods = {keys: keys, values: values, entries: entries}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let es5Fun = {
    method: function(){}
};
let es6Fun = {
    method(){}
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对象的解构赋值。 <code>ES6</code>对象也可以像数组解构赋值那样，进行变量的解构赋值</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let {apple, orange} = {apple: &#39;red appe&#39;, orange: &#39;yellow orange&#39;};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对象的扩展运算符(<code>...</code>)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let {apple, orange, ...otherFruits} = {apple: &#39;red apple&#39;, orange: &#39;yellow orange&#39;, grape: &#39;purple grape&#39;, peach: &#39;sweet peach&#39;};
// otherFruits  {grape: &#39;purple grape&#39;, peach: &#39;sweet peach&#39;}
// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)
let moreFruits = {watermelon: &#39;nice watermelon&#39;};
let allFruits = {apple, orange, ...otherFruits, ...moreFruits};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>super</code> 关键字。<code>ES6</code>在<code>Class</code>类里新增了类似<code>this</code>的关键字<code>super</code>。同<code>this</code>总是指向当前函数所在的对象不同，<code>super</code>关键字总是指向当前函数所在对象的原型对象</p></blockquote><p>升级部分</p><blockquote><p><code>ES6</code>在<code>Object</code>原型上新增了<code>is()</code>方法，做两个目标对象的相等比较，用来完善<code>&#39;===&#39;</code>方法。<code>&#39;===&#39;</code>方法中<code>NaN === NaN //false</code>其实是不合理的，<code>Object.is</code>修复了这个小<code>bug</code>。<code>(Object.is(NaN, NaN) // true)</code></p></blockquote><blockquote><p><code>ES6</code>在<code>Object</code>原型上新增了<code>assign()</code>方法，用于对象新增属性或者多个对象合并</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意: <code>assign</code>合并的对象<code>target</code>只能合并<code>source1</code>、s<code>ource2</code>中的自身属性，并不会合并<code>source1</code>、<code>source2</code>中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行<code>get/set</code>函数，取<code>return</code>的值）</p></blockquote><ul><li><code>ES6</code>在<code>Object</code>原型上新增了<code>getOwnPropertyDescriptors()</code>方法，此方法增强了<code>ES5</code>中<code>getOwnPropertyDescriptor()</code>方法，可以获取指定对象所有自身属性的描述对象。结合<code>defineProperties()</code>方法，可以完美复制对象，包括复制<code>get</code>和<code>set</code>属性</li><li><code>ES6</code>在<code>Object</code>原型上新增了<code>getPrototypeOf()</code>和<code>setPrototypeOf()</code>方法，用来获取或设置当前对象的<code>prototype</code>对象。这个方法存在的意义在于，<code>ES5</code>中获取设置<code>prototype</code>对像是通过<code>__proto__</code>属性来实现的，然而<code>__proto__</code>属性并不是ES规范中的明文规定的属性，只是浏览器各大产商&quot;私自&quot;加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的<code>prototype</code>对象时，都应该采用ES6新增的标准用法</li><li><code>ES6</code>在<code>Object</code>原型上还新增了<code>Object.keys()</code>，<code>Object.values()</code>，<code>Object.entries()</code>方法，用来获取对象的所有键、所有值和所有键值对数组</li></ul><h2 id="_8-举一些es6对function函数类型做的常用升级优化" tabindex="-1"><a class="header-anchor" href="#_8-举一些es6对function函数类型做的常用升级优化" aria-hidden="true">#</a> 8 举一些ES6对Function函数类型做的常用升级优化?</h2><p>优化部分</p><blockquote><p>箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点</p></blockquote><ul><li>箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下<code>this</code>的指向变得很难理解，尤其是非严格模式情况下，<code>this</code>有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的<code>this</code>,这也就导致了<code>this</code>总是指向上一层的<code>this</code>，如果上一层还是箭头函数，则继续向上指，直到指向到有自己<code>this</code>的函数为止，并作为自己的<code>this</code></li><li>箭头函数不能用作构造函数，因为它没有自己的<code>this</code>，无法实例化</li><li>也是因为箭头函数没有自己的this,所以箭头函数 内也不存在<code>arguments</code>对象。（可以用扩展运算符代替）</li><li>函数默认赋值。<code>ES6</code>之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。<code>ES6</code>以更简洁更明确的方式进行函数默认赋值</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function es6Fuc (x, y = &#39;default&#39;) {
    console.log(x, y);
}
es6Fuc(4) // 4, default

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>升级部分</p><blockquote><p>ES6新增了双冒号运算符，用来取代以往的<code>bind</code>，<code>call</code>,和<code>apply</code>。(浏览器暂不支持，<code>Babel</code>已经支持转码)</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-symbol是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_9-symbol是什么-有什么作用" aria-hidden="true">#</a> 9 Symbol是什么，有什么作用？</h2><blockquote><p><code>Symbol</code>是<code>ES6</code>引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中<code>Symbol()</code>属性不能被<code>for...in</code>遍历，但是也不是私有属性</p></blockquote><h2 id="_10-set是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_10-set是什么-有什么作用" aria-hidden="true">#</a> 10 Set是什么，有什么作用？</h2><blockquote><p><code>Set</code>是<code>ES6</code>引入的一种类似<code>Array</code>的新的数据结构，<code>Set</code>实例的成员类似于数组<code>item</code>成员，区别是<code>Set</code>实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重</p></blockquote><h3 id="介绍下-set、map、weakset-和-weakmap-的区别" tabindex="-1"><a class="header-anchor" href="#介绍下-set、map、weakset-和-weakmap-的区别" aria-hidden="true">#</a> 介绍下 Set、Map、WeakSet 和 WeakMap 的区别</h3><ul><li>Set------对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用</li><li>WeakSet------成员都是对象；成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；</li><li>Map------本质上是键值对的集合，类似集合；可以遍历，方法很多，可以跟各种数据格式转换。</li><li>WeakMap------只接受对象最为键名（null 除外），不接受其他类型的值作为键名；键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；不能遍历，方法有 get、set、has、delet</li></ul><h2 id="_11-map是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_11-map是什么-有什么作用" aria-hidden="true">#</a> 11 Map是什么，有什么作用？</h2><blockquote><p><code>Map</code>是<code>ES6</code>引入的一种类似<code>Object</code>的新的数据结构，<code>Map</code>可以理解为是<code>Object</code>的超集，打破了以传统键值对形式定义对象，对象的<code>key</code>不再局限于字符串，也可以是<code>Object</code>。可以更加全面的描述对象的属性</p></blockquote><h2 id="_12-proxy是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_12-proxy是什么-有什么作用" aria-hidden="true">#</a> 12 Proxy是什么，有什么作用？</h2><blockquote><p><code>Proxy</code>是<code>ES6</code>新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的<code>get/set</code>等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的<code>get/set</code>方法，可以轻松地定制自己想要的<code>key</code>或者<code>value</code>。下面的例子可以看到，随便定义一个<code>myOwnObj</code>的<code>key</code>,都可以变成自己想要的函数`</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function createMyOwnObj() {
	//想把所有的key都变成函数，或者Promise,或者anything
	return new Proxy({}, {
		get(target, propKey, receiver) {
			return new Promise((resolve, reject) =&gt; {
				setTimeout(() =&gt; {
					let randomBoolean = Math.random() &gt; 0.5;
					let Message;
					if (randomBoolean) {
						Message = `你的${propKey}运气不错，成功了`;
						resolve(Message);
					} else {
						Message = `你的${propKey}运气不行，失败了`;
						reject(Message);
					}
				}, 1000);
			});
		}
	});
}

let myOwnObj = createMyOwnObj();

myOwnObj.hahaha.then(result =&gt; {
	console.log(result) //你的hahaha运气不错，成功了
}).catch(error =&gt; {
	console.log(error) //你的hahaha运气不行，失败了
})

myOwnObj.wuwuwu.then(result =&gt; {
	console.log(result) //你的wuwuwu运气不错，成功了
}).catch(error =&gt; {
	console.log(error) //你的wuwuwu运气不行，失败了
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_13-reflect是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_13-reflect是什么-有什么作用" aria-hidden="true">#</a> 13 Reflect是什么，有什么作用？</h2><blockquote><p><code>Reflect</code>是<code>ES6</code>引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在<code>Object</code>、<code>Function</code>或者全局函数里的方法(如<code>apply</code>、<code>delete</code>、<code>get</code>、<code>set</code>等等)，统一整合到<code>Reflect</code>上，这样可以更加方便更加统一的管理一些原生<code>API</code>。其次就是因为<code>Proxy</code>可以改写默认的原生API，如果一旦原生<code>API</code>别改写可能就找不到了，所以<code>Reflect</code>也可以起到备份原生API的作用，使得即使原生<code>API</code>被改写了之后，也可以在被改写之后的<code>API</code>用上默认的<code>API</code></p></blockquote><h2 id="_14-promise是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_14-promise是什么-有什么作用" aria-hidden="true">#</a> 14 Promise是什么，有什么作用？</h2><blockquote><p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的&quot;回调地狱&quot;。它并不是什么突破性的<code>API</code>，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用</p></blockquote><h2 id="_15-iterator是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_15-iterator是什么-有什么作用" aria-hidden="true">#</a> 15 Iterator是什么，有什么作用？</h2><ul><li><code>Iterator</code>是<code>ES6</code>中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为<code>ES6</code>新增了<code>Set</code>、<code>Map</code>类型，他们和<code>Array</code>、<code>Object</code>类型很像，<code>Array</code>、<code>Object</code>都是可以遍历的，但是<code>Set</code>、<code>Map</code>都不能用for循环遍历，解决这个问题有两种方案，一种是为<code>Set</code>、<code>Map</code>单独新增一个用来遍历的<code>API</code>，另一种是为<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>Object</code>新增一个统一的遍历<code>API</code>，显然，第二种更好，<code>ES6</code>也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。<code>Iterator</code>正是这样一种标准。或者说是一种规范理念</li><li>就好像<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现一样，<code>Iterator</code>标准的具体实现是<code>Iterator</code>遍历器。<code>Iterator</code>标准规定，所有部署了<code>key</code>值为<code>[Symbol.iterator]</code>，且<code>[Symbol.iterator]</code>的<code>value</code>是标准的<code>Iterator</code>接口函数(标准的<code>Iterator</code>接口函数: 该函数必须返回一个对象，且对象中包含<code>next</code>方法，且执行<code>next()</code>能返回包含<code>value/done</code>属性的<code>Iterator</code>对象)的对象，都称之为可遍历对象，<code>next()</code>后返回的<code>Iterator</code>对象也就是<code>Iterator</code>遍历器</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。
//obj.[Symbol.iterator]() 就是Iterator遍历器
let obj = {
  data: [ &#39;hello&#39;, &#39;world&#39; ],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index &lt; self.data.length) {
          return {
            value: self.data[index++],
            done: false
          };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>ES6</code>给<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>都加上了<code>[Symbol.iterator]</code>方法，且<code>[Symbol.iterator]</code>方法函数也符合标准的<code>Iterator</code>接口规范，所以<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>默认都是可以遍历的</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//Array
let array = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];
array[Symbol.iterator]() //Iterator遍历器
array[Symbol.iterator]().next() //{value: &quot;red&quot;, done: false}

//String
let string = &#39;1122334455&#39;;
string[Symbol.iterator]() //Iterator遍历器
string[Symbol.iterator]().next() //{value: &quot;1&quot;, done: false}

//set
let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
set[Symbol.iterator]() //Iterator遍历器
set[Symbol.iterator]().next() //{value: &quot;red&quot;, done: false}

//Map
let map = new Map();
let obj= {map: &#39;map&#39;};
map.set(obj, &#39;mapValue&#39;);
map[Symbol.iterator]().next()  {value: Array(2), done: false}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_16-for-in-和for-of有什么区别" tabindex="-1"><a class="header-anchor" href="#_16-for-in-和for-of有什么区别" aria-hidden="true">#</a> 16 for...in 和for...of有什么区别？</h2><blockquote><p>如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用<code>for...of</code>。ES6规定，有所部署了载了<code>Iterator</code>接口的对象(可遍历对象)都可以通过<code>for...of</code>去遍历，而<code>for..in</code>仅仅可以遍历对象</p></blockquote><ul><li>这也就意味着，数组也可以用<code>for...of</code>遍历，这极大地方便了数组的取值，且避免了很多程序用<code>for..in</code>去遍历数组的恶习</li></ul><h2 id="_17-generator函数是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_17-generator函数是什么-有什么作用" aria-hidden="true">#</a> 17 Generator函数是什么，有什么作用？</h2><ul><li>如果说<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现、<code>Iterator</code>遍历器是<code>Iterator</code>的具体实现，那么<code>Generator</code>函数可以说是<code>Iterator</code>接口的具体实现方式。</li><li>执行<code>Generator</code>函数会返回一个遍历器对象，每一次<code>Generator</code>函数里面的<code>yield</code>都相当一次遍历器对象的<code>next()</code>方法，并且可以通过<code>next(value)</code>方法传入自定义的value,来改变<code>Generator</code>函数的行为。</li><li><code>Generator</code>函数可以通过配合<code>Thunk</code> 函数更轻松更优雅的实现异步编程和控制流管理。</li></ul><h3 id="generator-原理" tabindex="-1"><a class="header-anchor" href="#generator-原理" aria-hidden="true">#</a> generator 原理</h3><blockquote><p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 使用 * 表示这是一个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调用 next 恢复执行
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // &gt;  { value: 2, done: false }
console.log(b.next()); // &gt;  { value: 3, done: false }
console.log(b.next()); // &gt;  { value: undefined, done: true }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从以上代码可以发现，加上 <code>*</code>的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function() {
    var object = {
      next: 0,
      stop: function() {}
    };

    return {
      next: function() {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false
        };
      }
    };
  })();
}
// 如果你使用 babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function(_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成几块
        // 每次执行 next 函数就执行一块代码
        // 并且表明下次需要执行哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
		// 执行完毕
        case 6:
        case &quot;end&quot;:
          return _context.stop();
      }
    }
  });
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="generator-实现" tabindex="-1"><a class="header-anchor" href="#generator-实现" aria-hidden="true">#</a> Generator 实现</h3><blockquote><p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 使用 * 表示这是一个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调用 next 恢复执行
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // &gt;  { value: 2, done: false }
console.log(b.next()); // &gt;  { value: 3, done: false }
console.log(b.next()); // &gt;  { value: undefined, done: true }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code>函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code>函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function() {
    var object = {
      next: 0,
      stop: function() {}
    };

    return {
      next: function() {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false
        };
      }
    };
  })();
}
// 如果你使用 babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function(_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成几块
        // 每次执行 next 函数就执行一块代码
        // 并且表明下次需要执行哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
		// 执行完毕
        case 6:
        case &quot;end&quot;:
          return _context.stop();
      }
    }
  });
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_18-async函数是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_18-async函数是什么-有什么作用" aria-hidden="true">#</a> 18 async函数是什么，有什么作用？</h2><blockquote><p><code>async</code>函数可以理解为内置自动执行器的<code>Generator</code>函数语法糖，它配合<code>ES6</code>的<code>Promise</code>近乎完美的实现了异步编程解决方案</p></blockquote><p>async、await 优缺点</p><blockquote><p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></blockquote><p>下面来看一个使用 <code>await</code> 的代码。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 0
var b = async () =&gt; {
  a = a + await 10
  console.log(&#39;2&#39;, a) // -&gt; &#39;2&#39; 10
  a = (await 10) + a
  console.log(&#39;3&#39;, a) // -&gt; &#39;3&#39; 20
}
b()
a++
console.log(&#39;1&#39;, a) // -&gt; &#39;1&#39; 1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>首先函数<code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 <code>0</code>，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，遇到<code>await</code>就会立即返回一个<code>pending</code>状态的<code>Promise</code>对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li><li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li><li>然后后面就是常规执行代码了</li></ul><h2 id="_19-class、extends是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_19-class、extends是什么-有什么作用" aria-hidden="true">#</a> 19 Class、extends是什么，有什么作用？</h2><blockquote><p><code>ES6</code> 的<code>class</code>可以看作只是一个<code>ES5</code>生成实例对象的构造函数的语法糖。它参考了<code>java</code>语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。<code>Class</code>类可以通过<code>extends</code>实现继承。它和ES5构造函数的不同点</p></blockquote><p>类的内部定义的所有方法，都是不可枚举的</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>///ES5
function ES5Fun (x, y) {
	this.x = x;
	this.y = y;
}
ES5Fun.prototype.toString = function () {
	 return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
}
var p = new ES5Fun(1, 3);
p.toString();
Object.keys(ES5Fun.prototype); //[&#39;toString&#39;]

//ES6
class ES6Fun {
	constructor (x, y) {
		this.x = x;
		this.y = y;
	}
	toString () {
		return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
	}
}

Object.keys(ES6Fun.prototype); //[]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>ES6</code>的<code>class</code>类必须用<code>new</code>命令操作，而<code>ES5</code>的构造函数不用<code>new</code>也可以执行。</li><li><code>ES6</code>的<code>class</code>类不存在变量提升，必须先定义<code>class</code>之后才能实例化，不像<code>ES5</code>中可以将构造函数写在实例化之后。</li><li><code>ES5</code> 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面。<code>ES6</code> 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li></ul><h2 id="_20-module、export、import是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_20-module、export、import是什么-有什么作用" aria-hidden="true">#</a> 20 module、export、import是什么，有什么作用？</h2><ul><li><code>module</code>、<code>export</code>、<code>import</code>是<code>ES6</code>用来统一前端模块化方案的设计思路和实现方案。<code>export</code>、<code>import</code>的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的<code>AMD/CMD</code>、<code>requireJS</code>、<code>seaJS</code>、<code>commondJS</code>等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，<code>JS</code>也能更加能实现大型的应用程序开发。</li><li><code>import</code>引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</li><li><code>import</code>引入<code>export</code>导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li></ul><h2 id="_21-日常前端代码开发中-有哪些值得用es6去改进的编程优化或者规范" tabindex="-1"><a class="header-anchor" href="#_21-日常前端代码开发中-有哪些值得用es6去改进的编程优化或者规范" aria-hidden="true">#</a> 21 日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</h2><ul><li>常用箭头函数来取代<code>var self = this</code>;的做法。</li><li>常用<code>let</code>取代<code>var</code>命令。</li><li>常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。</li><li>在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。</li><li>用<code>Class</code>类取代传统的构造函数，来生成实例化对象。</li><li>在大型应用开发中，要保持<code>module</code>模块化开发思维，分清模块之间的关系，常用<code>import</code>、<code>export</code>方法。</li></ul><h2 id="_22-es6的了解" tabindex="-1"><a class="header-anchor" href="#_22-es6的了解" aria-hidden="true">#</a> 22 ES6的了解</h2><blockquote><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据---例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念</p></blockquote><h2 id="_23-说说你对promise的理解" tabindex="-1"><a class="header-anchor" href="#_23-说说你对promise的理解" aria-hidden="true">#</a> 23 说说你对Promise的理解</h2><ul><li>依照 <code>Promise/A+</code> 的定义，Promise 有四种状态： <ul><li><code>pending</code>: 初始状态, 非 <code>fulfilled</code> 或 <code>rejected.</code></li><li><code>fulfilled</code>: 成功的操作.</li><li><code>rejected</code>: 失败的操作.</li><li><code>settled</code>: <code>Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li></ul></li><li>另外， <code>fulfilled</code> 与 <code>rejected</code> 一起合称 settled</li><li><code>Promise</code> 对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code> ) 计算</li><li>可以把 <code>Promise</code>看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code>，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</li><li><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code>调用就失去意义了</li></ul><h2 id="_24-promise-的构造函数" tabindex="-1"><a class="header-anchor" href="#_24-promise-的构造函数" aria-hidden="true">#</a> 24 Promise 的构造函数</h2><blockquote><p>构造一个 <code>Promise</code>，最基本的用法如下：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var promise = new Promise(function(resolve, reject) {

        if (...) {  // succeed

            resolve(result);

        } else {   // fails

            reject(Error(errMessage));

        }
    });

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>Promise</code> 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>promise.then(onFulfilled, onRejected)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是 future，<code>onFulfilled</code> 对应 <code>resolve</code>, <code>onRejected</code> 对应 <code>reject</code></p></blockquote><p>什么是 Promise ？</p><ul><li>Promise 就是一个对象，用来表示并传递异步操作的最终结果</li><li>Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因</li><li>Promise 代码书写上的表现：以&quot;链式调用&quot;代替回调函数层层嵌套（回调地狱）</li></ul><h2 id="_25-谈一谈你了解ecmascript6的新特性" tabindex="-1"><a class="header-anchor" href="#_25-谈一谈你了解ecmascript6的新特性" aria-hidden="true">#</a> 25 谈一谈你了解ECMAScript6的新特性？</h2><ul><li>块级作用区域 <code>let a = 1;</code></li><li>可定义常量 <code>const PI = 3.141592654;</code></li><li>变量解构赋值 <code>var [a, b, c] = [1, 2, 3];</code></li><li>字符串的扩展(模板字符串) <code>var sum =</code>${a + b}<code>;</code></li><li>数组的扩展(转换数组类型) <code>Array.from($(&#39;li&#39;));</code></li><li>函数的扩展(扩展运算符) <code>[1, 2].push(...[3, 4, 5]);</code></li><li>对象的扩展(同值相等算法) <code>Object.is(NaN, NaN);</code></li><li>新增数据类型(Symbol) <code>let uid = Symbol(&#39;uid&#39;);</code></li><li>新增数据结构(Map) <code>let set = new Set([1, 2, 2, 3]);</code></li><li>for...of循环 <code>for(let val of arr){};</code></li><li>Promise对象 <code>var promise = new Promise(func);</code></li><li>Generator函数 <code>function* foo(x){yield x; return x*x;}</code></li><li>引入Class(类) <code>class Foo {}</code></li><li>引入模块体系 <code>export default func;</code></li><li>引入async函数[ES7]</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>async function asyncPrint(value, ms) {
      await timeout(ms);
      console.log(value)
     }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_26-object-is-与原来的比较操作符-、-的区别" tabindex="-1"><a class="header-anchor" href="#_26-object-is-与原来的比较操作符-、-的区别" aria-hidden="true">#</a> 26 Object.is() 与原来的比较操作符 ===、== 的区别？</h2><ul><li><code>==</code> 相等运算符，比较时会自动进行数据类型转换</li><li><code>===</code> 严格相等运算符，比较时不进行隐式类型转换</li><li><code>Object.is</code> 同值相等算法，在 <code>===</code> 基础上对 <code>0</code> 和 <code>NaN</code> 特别处理</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_27-什么是-babel" tabindex="-1"><a class="header-anchor" href="#_27-什么是-babel" aria-hidden="true">#</a> 27 什么是 Babel</h2><ul><li><code>Babel</code> 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。 这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。</li><li><code>Babel</code> 默认只转换新的 JS 句法(syntax)，而不转换新的API。</li></ul><h2 id="_28-symbol-有什么用处" tabindex="-1"><a class="header-anchor" href="#_28-symbol-有什么用处" aria-hidden="true">#</a> 28 symbol 有什么用处</h2><blockquote><p>可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗？我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。</p></blockquote><p>主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for---of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</p><blockquote><p><code>Symbol.for()</code> 可以在全局访问 <code>symbol</code></p></blockquote><h2 id="_29-模块化" tabindex="-1"><a class="header-anchor" href="#_29-模块化" aria-hidden="true">#</a> 29 模块化</h2><blockquote><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code>的模块化</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import {a, b} from &#39;./a.js&#39;
import XXX from &#39;./b.js&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CommonJS</p><blockquote><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code>解析了。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require(&#39;./a.js&#39;)
module.a // -&gt; log 1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var module = require(&#39;./a.js&#39;)
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// 基本实现
var module = {
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>再来说说 <code>module.exports</code> 和<code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p></blockquote><blockquote><p>对于 <code>CommonJS</code> 和 <code>ES6</code> 中的模块化的两者区别是：</p></blockquote><ul><li>前者支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 <code>require/exports</code> 来执行的</li></ul><p>AMD</p><blockquote><p><code>AMD</code> 是由 <code>RequireJS</code> 提出的</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// AMD
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {
    a.do()
    b.do()
})
define(function(require, exports, module) {
    var a = require(&#39;./a&#39;)
    a.doSomething()
    var b = require(&#39;./b&#39;)
    b.doSomething()
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_30-箭头函数的特点" tabindex="-1"><a class="header-anchor" href="#_30-箭头函数的特点" aria-hidden="true">#</a> 30 箭头函数的特点</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function a() {
    return () =&gt; {
        return () =&gt; {
        	console.log(this)
        }
    }
}
console.log(a()()())

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code>。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是<code>window</code>。并且 <code>this</code>一旦绑定了上下文，就不会被任何代码改变</p></blockquote><h2 id="_31-es5-es6-的继承除了写法以外还有什么区别" tabindex="-1"><a class="header-anchor" href="#_31-es5-es6-的继承除了写法以外还有什么区别" aria-hidden="true">#</a> 31 ES5 / ES6 的继承除了写法以外还有什么区别</h2><ul><li>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）</li><li>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。</li><li>ES5 的继承时通过原型或构造函数机制来实现。</li><li>ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。</li><li>子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</li><li>注意 super 关键字指代父类的实例，即父类的 this 对象。</li><li>注意：在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。function 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量</li></ul><h2 id="_32-全局作用域中-用-const-和-let-声明的变量不在-window-上-那到底在哪里-如何去获取" tabindex="-1"><a class="header-anchor" href="#_32-全局作用域中-用-const-和-let-声明的变量不在-window-上-那到底在哪里-如何去获取" aria-hidden="true">#</a> 32 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。
var a = 12;
function f(){};
console.log(window.a);
// 12console.log(window.f);
// f(){}

// 但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。
let aa = 1;
const bb = 2;
console.log(window.aa);
// undefinedconsole.log(window.bb);
// undefined

// 在哪里？怎么获取？通过在设置断点，看看浏览器是怎么处理的：
//通过上图也可以看到，在全局作用域中，用 let 和 const 声明的全局变量并没
//有在全局对象中，只是一个块级作用域（Script）中怎么获取？在定义变量的块级作用域中就能获取啊，既然不属于顶层对象，那就不加 window（global）呗。
let aa = 1;
const bb = 2;
console.log(aa);
// 1console.log(bb);
// 2

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_33-介绍下-set、map、weakset-和-weakmap-的区别" tabindex="-1"><a class="header-anchor" href="#_33-介绍下-set、map、weakset-和-weakmap-的区别" aria-hidden="true">#</a> 33 介绍下 Set、Map、WeakSet 和 WeakMap 的区别</h2><p>Set</p><ul><li>成员不能重复</li><li>只有健值，没有健名，有点类似数组</li><li>可以遍历，方法有<code>add</code>, <code>delete</code>,<code>has</code></li></ul><p>weakSet</p><ul><li>成员都是对象</li><li>成员都是弱引用，随时可以消失。 可以用来保存DOM节点，不容易造成内存泄漏</li><li>不能遍历，方法有<code>add</code>, <code>delete</code>,<code>has</code></li></ul><p>Map</p><ul><li>本质上是健值对的集合，类似集合</li><li>可以遍历，方法很多，可以干跟各种数据格式转换</li></ul><p>weakMap</p><ul><li>直接受对象作为健名（<code>null</code>除外），不接受其他类型的值作为健名</li><li>健名所指向的对象，不计入垃圾回收机制</li><li>不能遍历，方法同<code>get</code>,<code>set</code>,<code>has</code>,<code>delete</code></li></ul><h2 id="_34-promise-all-和-promise-allsettled-的比较" tabindex="-1"><a class="header-anchor" href="#_34-promise-all-和-promise-allsettled-的比较" aria-hidden="true">#</a> 34 Promise.all() 和 Promise.allSettled()的比较</h2><h3 id="promise-allsettled" tabindex="-1"><a class="header-anchor" href="#promise-allsettled" aria-hidden="true">#</a> Promise.allSettled()</h3><blockquote><p>接受的结果与入参时的promise实例一一对应，且结果的每一项都是一个对象，告诉你结果和值，对象内都有一个属性叫&quot;status&quot;，用来明确知道对应的这个promise实例的状态（fulfilled或rejected），fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: &#39;fulfilled&#39;, value: 42 },
//    { status: &#39;rejected&#39;, reason: -1 }
// ]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>重要的一点是，他不论接受入参的promise本身的状态，会返回所有promise的结果，但这一点<code>Promise.all</code>做不到，如果你需要知道所有入参的异步操作的所有结果，或者需要知道这些异步操作是否全部结束，应该使用<code>promise.allSettled()</code></p></blockquote><h3 id="promise-all" tabindex="-1"><a class="header-anchor" href="#promise-all" aria-hidden="true">#</a> Promise.all()</h3><blockquote><p>只有当所有入参的promise实例都是<code>fulfilled</code>状态，才会在<code>Promise.all().then()</code>方法中结果，返回结果也是与入参一一对应，结果中只包含实际的<code>resolve</code>的结果，不包含类似<code>allSettled</code>的<code>status</code>和<code>value</code>属性。</p></blockquote></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/selected/JS%E6%A8%A1%E5%9D%97.html" class="" aria-label="JS模块"><!--[--><!--]--> JS模块 <!--[--><!--]--></a></span><span class="next"><a href="/selected/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97.html" class="" aria-label="浏览器模块"><!--[--><!--]--> 浏览器模块 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.12353158.js" defer></script>
  </body>
</html>
