<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>React | Frontend Starter</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.12353158.js"><link rel="modulepreload" href="/assets/React.html.4ec983c7.js"><link rel="modulepreload" href="/assets/React.html.6802a56c.js"><link rel="prefetch" href="/assets/index.html.ee998a26.js"><link rel="prefetch" href="/assets/CSS.html.c64e9431.js"><link rel="prefetch" href="/assets/HTML.html.a70e4433.js"><link rel="prefetch" href="/assets/HTTP.html.6dbdd949.js"><link rel="prefetch" href="/assets/JS基础.html.0a913d15.js"><link rel="prefetch" href="/assets/Vue.html.a81339b7.js"><link rel="prefetch" href="/assets/工程化.html.0c152696.js"><link rel="prefetch" href="/assets/性能.html.090fde92.js"><link rel="prefetch" href="/assets/框架通识.html.1a3f58ab.js"><link rel="prefetch" href="/assets/浏览器.html.2ec19a51.js"><link rel="prefetch" href="/assets/设计模式.html.5761cd54.js"><link rel="prefetch" href="/assets/Bootstrap.html.86ad9734.js"><link rel="prefetch" href="/assets/CSS.html.e3ee6176.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.6603dd61.js"><link rel="prefetch" href="/assets/JavaScript.html.14aca0a4.js"><link rel="prefetch" href="/assets/Webpack.html.f773c5e1.js"><link rel="prefetch" href="/assets/jQuery.html.c3b9972e.js"><link rel="prefetch" href="/assets/其他.html.c716f6ee.js"><link rel="prefetch" href="/assets/微信小程序.html.0335a142.js"><link rel="prefetch" href="/assets/综合.html.5dfe757e.js"><link rel="prefetch" href="/assets/编程题.html.cbfc1c8c.js"><link rel="prefetch" href="/assets/性能优化.html.30c3f1c5.js"><link rel="prefetch" href="/assets/高频考点.html.2ee4efd2.js"><link rel="prefetch" href="/assets/handwritten.html.879fcb5e.js"><link rel="prefetch" href="/assets/JavaScript.html.bcb5a0d9.js"><link rel="prefetch" href="/assets/Node.html.be9ed4e1.js"><link rel="prefetch" href="/assets/React.html.36beeb6b.js"><link rel="prefetch" href="/assets/Vue.html.b739e835.js"><link rel="prefetch" href="/assets/Webpack.html.b34fb870.js"><link rel="prefetch" href="/assets/综合.html.30e0bc70.js"><link rel="prefetch" href="/assets/CSS模块.html.99bd45d7.js"><link rel="prefetch" href="/assets/ES6模块.html.0f2bfddb.js"><link rel="prefetch" href="/assets/HTML模块.html.4fb65265.js"><link rel="prefetch" href="/assets/HTTP模块.html.b4ce19f7.js"><link rel="prefetch" href="/assets/JS模块.html.015ff251.js"><link rel="prefetch" href="/assets/Node模块.html.b1985276.js"><link rel="prefetch" href="/assets/React模块.html.f53e1f03.js"><link rel="prefetch" href="/assets/Vue模块.html.785747a6.js"><link rel="prefetch" href="/assets/前端安全模块.html.f0f98ff3.js"><link rel="prefetch" href="/assets/前端工程相关.html.183e2c9f.js"><link rel="prefetch" href="/assets/小程序模块.html.f7ab4d91.js"><link rel="prefetch" href="/assets/常用设计模式.html.03f9722f.js"><link rel="prefetch" href="/assets/性能优化相关.html.12e8a2e3.js"><link rel="prefetch" href="/assets/排序算法.html.40481e91.js"><link rel="prefetch" href="/assets/框架通识.html.c3c3096b.js"><link rel="prefetch" href="/assets/浏览器模块.html.24652566.js"><link rel="prefetch" href="/assets/移动多端开发.html.8636371c.js"><link rel="prefetch" href="/assets/计算机通识.html.728b7ceb.js"><link rel="prefetch" href="/assets/404.html.93c18560.js"><link rel="prefetch" href="/assets/index.html.60500264.js"><link rel="prefetch" href="/assets/CSS.html.02fa634c.js"><link rel="prefetch" href="/assets/HTML.html.3a31cd64.js"><link rel="prefetch" href="/assets/HTTP.html.a1df6d3a.js"><link rel="prefetch" href="/assets/JS基础.html.b88ab559.js"><link rel="prefetch" href="/assets/Vue.html.5c58cab9.js"><link rel="prefetch" href="/assets/工程化.html.863e35db.js"><link rel="prefetch" href="/assets/性能.html.470e0a6f.js"><link rel="prefetch" href="/assets/框架通识.html.32d2fbab.js"><link rel="prefetch" href="/assets/浏览器.html.8279ebd9.js"><link rel="prefetch" href="/assets/设计模式.html.6afe6cf3.js"><link rel="prefetch" href="/assets/Bootstrap.html.2cc414a0.js"><link rel="prefetch" href="/assets/CSS.html.5d66e791.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.bbea8927.js"><link rel="prefetch" href="/assets/JavaScript.html.07acfd24.js"><link rel="prefetch" href="/assets/Webpack.html.a1c5dce1.js"><link rel="prefetch" href="/assets/jQuery.html.4e2f3899.js"><link rel="prefetch" href="/assets/其他.html.929587e1.js"><link rel="prefetch" href="/assets/微信小程序.html.69cc86fd.js"><link rel="prefetch" href="/assets/综合.html.1c892aa5.js"><link rel="prefetch" href="/assets/编程题.html.5478af99.js"><link rel="prefetch" href="/assets/性能优化.html.337c4654.js"><link rel="prefetch" href="/assets/高频考点.html.8772c401.js"><link rel="prefetch" href="/assets/handwritten.html.0f0ee7e3.js"><link rel="prefetch" href="/assets/JavaScript.html.5dd72bd0.js"><link rel="prefetch" href="/assets/Node.html.7eac5124.js"><link rel="prefetch" href="/assets/React.html.d8ccb952.js"><link rel="prefetch" href="/assets/Vue.html.47efbab1.js"><link rel="prefetch" href="/assets/Webpack.html.793df544.js"><link rel="prefetch" href="/assets/综合.html.ff78888d.js"><link rel="prefetch" href="/assets/CSS模块.html.bcc3cfc7.js"><link rel="prefetch" href="/assets/ES6模块.html.2ea3507a.js"><link rel="prefetch" href="/assets/HTML模块.html.6b729342.js"><link rel="prefetch" href="/assets/HTTP模块.html.2c6adffa.js"><link rel="prefetch" href="/assets/JS模块.html.28259fe6.js"><link rel="prefetch" href="/assets/Node模块.html.c36cd1fb.js"><link rel="prefetch" href="/assets/React模块.html.b09a5954.js"><link rel="prefetch" href="/assets/Vue模块.html.a27ab950.js"><link rel="prefetch" href="/assets/前端安全模块.html.e3aebe2f.js"><link rel="prefetch" href="/assets/前端工程相关.html.281b6ffe.js"><link rel="prefetch" href="/assets/小程序模块.html.493268db.js"><link rel="prefetch" href="/assets/常用设计模式.html.a600f326.js"><link rel="prefetch" href="/assets/性能优化相关.html.aff23982.js"><link rel="prefetch" href="/assets/排序算法.html.361967d5.js"><link rel="prefetch" href="/assets/框架通识.html.7719e539.js"><link rel="prefetch" href="/assets/浏览器模块.html.ac4e495d.js"><link rel="prefetch" href="/assets/移动多端开发.html.d8fc5993.js"><link rel="prefetch" href="/assets/计算机通识.html.0e8ab127.js"><link rel="prefetch" href="/assets/404.html.232c3875.js"><link rel="prefetch" href="/assets/404.176778df.js"><link rel="prefetch" href="/assets/Layout.ac3a6e88.js">
    <link rel="stylesheet" href="/assets/style.20e644be.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Frontend Starter</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">基础 Basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/basic/HTTP%20&amp;%20HTML.html" class="sidebar-item" aria-label="HTML、HTTP、Web"><!--[--><!--]--> HTML、HTTP、Web <!--[--><!--]--></a><!----></li><li><a href="/basic/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/basic/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/basic/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/basic/Bootstrap.html" class="sidebar-item" aria-label="Bootstrap"><!--[--><!--]--> Bootstrap <!--[--><!--]--></a><!----></li><li><a href="/basic/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BC%96%E7%A8%8B%E9%A2%98.html" class="sidebar-item" aria-label="编程题"><!--[--><!--]--> 编程题 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%85%B6%E4%BB%96.html" class="sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">进阶 Advanced <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/advanced/JS%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/advanced/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%B5%8F%E8%A7%88%E5%99%A8.html" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/advanced/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advanced/React.html#_0-对虚拟dom的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="0 对虚拟DOM的理解"><!--[--><!--]--> 0 对虚拟DOM的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_1-谈谈你对react的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 谈谈你对React的理解"><!--[--><!--]--> 1 谈谈你对React的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_2-如何避免react生命周期中的坑" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 如何避免React生命周期中的坑"><!--[--><!--]--> 2 如何避免React生命周期中的坑 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_3-react-fiber架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 React Fiber架构"><!--[--><!--]--> 3 React Fiber架构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_4-createelement过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 createElement过程"><!--[--><!--]--> 4 createElement过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_5-调和阶段-setstate内部干了什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 调和阶段 setState内部干了什么"><!--[--><!--]--> 5 调和阶段 setState内部干了什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_6-setstate" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 setState"><!--[--><!--]--> 6 setState <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_7-setstate原理分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="7 setState原理分析"><!--[--><!--]--> 7 setState原理分析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_8-react事务机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="8 React事务机制"><!--[--><!--]--> 8 React事务机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_9-react组件和渲染更新过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="9 React组件和渲染更新过程"><!--[--><!--]--> 9 React组件和渲染更新过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_10-如何解释-react-的渲染流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="10 如何解释 React 的渲染流程"><!--[--><!--]--> 10 如何解释 React 的渲染流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_11-diff算法是怎么运作" class="router-link-active router-link-exact-active sidebar-item" aria-label="11 diff算法是怎么运作"><!--[--><!--]--> 11 diff算法是怎么运作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_12-合成事件原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="12 合成事件原理"><!--[--><!--]--> 12 合成事件原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_13-jsx语法糖本质" class="router-link-active router-link-exact-active sidebar-item" aria-label="13 JSX语法糖本质"><!--[--><!--]--> 13 JSX语法糖本质 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_14-为什么-react-元素有一个-typeof-属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="14 为什么 React 元素有一个 $$typeof 属性"><!--[--><!--]--> 14 为什么 React 元素有一个 $$typeof 属性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_15-virtual-dom-的工作原理是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="15 Virtual DOM 的工作原理是什么"><!--[--><!--]--> 15 Virtual DOM 的工作原理是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_16-react有哪些优化性能的手段" class="router-link-active router-link-exact-active sidebar-item" aria-label="16 React有哪些优化性能的手段"><!--[--><!--]--> 16 React有哪些优化性能的手段 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_17-redux实现原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="17 Redux实现原理解析"><!--[--><!--]--> 17 Redux实现原理解析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_18-谈谈你对状态管理的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="18 谈谈你对状态管理的理解"><!--[--><!--]--> 18 谈谈你对状态管理的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_19-connect组件原理分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="19 connect组件原理分析"><!--[--><!--]--> 19 connect组件原理分析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_20-react-hooks" class="router-link-active router-link-exact-active sidebar-item" aria-label="20 React Hooks"><!--[--><!--]--> 20 React Hooks <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_21-受控组件和非受控组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="21 受控组件和非受控组件"><!--[--><!--]--> 21 受控组件和非受控组件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_22-如何避免ajax数据请求重新获取" class="router-link-active router-link-exact-active sidebar-item" aria-label="22 如何避免ajax数据请求重新获取"><!--[--><!--]--> 22 如何避免ajax数据请求重新获取 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_23-组件之间通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="23 组件之间通信"><!--[--><!--]--> 23 组件之间通信 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_24-类组件与函数组件有什么区别呢" class="router-link-active router-link-exact-active sidebar-item" aria-label="24 类组件与函数组件有什么区别呢？"><!--[--><!--]--> 24 类组件与函数组件有什么区别呢？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_25-如何设计react组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="25 如何设计React组件"><!--[--><!--]--> 25 如何设计React组件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_26-组件的协同及-不-可控组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="26 组件的协同及（不）可控组件"><!--[--><!--]--> 26 组件的协同及（不）可控组件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_27-react-router-的实现原理及工作方式分别是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="27 React-Router 的实现原理及工作方式分别是什么"><!--[--><!--]--> 27 React-Router 的实现原理及工作方式分别是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/React.html#_28-react-17-带来了哪些改变" class="router-link-active router-link-exact-active sidebar-item" aria-label="28 React 17 带来了哪些改变"><!--[--><!--]--> 28 React 17 带来了哪些改变 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/advanced/%E6%80%A7%E8%83%BD.html" class="sidebar-item" aria-label="性能"><!--[--><!--]--> 性能 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="sidebar-item" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">精选 Selected <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/selected/HTML%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTML模块"><!--[--><!--]--> HTML模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/CSS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="CSS模块"><!--[--><!--]--> CSS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/JS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="JS模块"><!--[--><!--]--> JS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/ES6%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="ES6模块"><!--[--><!--]--> ES6模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="浏览器模块"><!--[--><!--]--> 浏览器模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/React%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="React模块"><!--[--><!--]--> React模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Vue%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Vue模块"><!--[--><!--]--> Vue模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Node%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Node模块"><!--[--><!--]--> Node模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="前端工程相关"><!--[--><!--]--> 前端工程相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="移动多端开发"><!--[--><!--]--> 移动多端开发 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="小程序模块"><!--[--><!--]--> 小程序模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="前端安全模块"><!--[--><!--]--> 前端安全模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="性能优化相关"><!--[--><!--]--> 性能优化相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/HTTP%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTTP模块"><!--[--><!--]--> HTTP模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="常用设计模式"><!--[--><!--]--> 常用设计模式 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="计算机通识"><!--[--><!--]--> 计算机通识 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">高频 Frequency <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/frequency/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" class="sidebar-item" aria-label="高频考点"><!--[--><!--]--> 高频考点 <!--[--><!--]--></a><!----></li><li><a href="/frequency/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">原理 Principle <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/principle/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/principle/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/principle/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/principle/Node.html" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><li><a href="/principle/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/principle/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h1><hr><h3 id="_0-对虚拟dom的理解" tabindex="-1"><a class="header-anchor" href="#_0-对虚拟dom的理解" aria-hidden="true">#</a> 0 对虚拟DOM的理解</h3><blockquote><p><code>虚拟dom从来不是用来和直接操作dom对比的</code>，它们俩最终殊途同归。<code>虚拟dom只不过是局部更新的一个环节而已</code>，整个环节的对比对象是全量更新。虚拟dom对于state＝UI的意义是，虚拟dom使diff成为可能（理论上也可以直接用dom对象diff，但是太臃肿），促进了新的开发思想，又不至于性能太差。但是性能再好也不可能好过直接操作dom，人脑连diff都省了。还有一个很重要的意义是，<code>对视图抽象，为跨平台助力</code></p></blockquote><p>其实我最终希望你明白的事情只有一件：<code>虚拟 DOM 的价值不在性能，而在别处</code>。因此想要从性能角度来把握虚拟 DOM 的优势，无异于南辕北辙。偏偏在面试场景下，10 个人里面有 9 个都走这条歧路，最后9个人里面自然没有一个能自圆其说，实在让人惋惜。</p><p><a href="http://interview.poetries.top/principle-docs/react/15-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM.html" target="_blank" rel="noopener noreferrer">真正理解虚拟DOM(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_1-谈谈你对react的理解" tabindex="-1"><a class="header-anchor" href="#_1-谈谈你对react的理解" aria-hidden="true">#</a> 1 谈谈你对React的理解</h3><blockquote><p>React 是一个网页 UI 框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</p></blockquote><ul><li>它的核心设计思路有三点，分别是<code>声明式、组件化与 通用性</code>。</li><li>声明式的优势在于直观与组合。</li><li>组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。</li><li>通用性在于一次学习，随处编写。比如 React Native，React 360 等， 这里主要靠虚拟 DOM 来保证实现。</li><li>这使得 React 的适用范围变得足够广，无论是 Web、Native、VR，甚至 Shell 应用都可以进行开发。这也是 React 的优势。</li><li>但作为一个视图层的框架，React 的劣势也十分明显。它并没有提供完整的一揽子解决方 案，在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但也为开发者在技术选型和学习适用上造成了一定的成本。</li><li>承接在优势后，可以再谈一下自己对于 React 优化的看法、对虚拟 DOM 的看法</li></ul><h3 id="_2-如何避免react生命周期中的坑" tabindex="-1"><a class="header-anchor" href="#_2-如何避免react生命周期中的坑" aria-hidden="true">#</a> 2 如何避免React生命周期中的坑</h3><p>16.3版本</p><p><img src="/assets/20210409153251.8807f30d.png" alt=""></p><blockquote><p>=16.4版本</p></blockquote><p><img src="/assets/20210409153312.696ee741.png" alt=""></p><p>在线查看：<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram" target="_blank" rel="noopener noreferrer">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><img src="/assets/20210425121355.54f3a495.png" alt=""></p><ul><li>避免生命周期中的坑需要做好两件事：不在恰当的时候调用了不该调用的代码；在需要调用时，不要忘了调用。</li><li>那么主要有这么 7 种情况容易造成生命周期的坑 <ul><li><code>getDerivedStateFromProps</code> 容易编写反模式代码，使受控组件与非受控组件区分模糊</li><li><code>componentWillMount</code> 在 React 中已被标记弃用，不推荐使用，主要原因是<code>新的异步渲染架构会导致它被多次调用</code>。所以网络请求及事件绑定代码应移至 <code>componentDidMount</code> 中。</li><li><code>componentWillReceiveProps</code> 同样被标记弃用，被 <code>getDerivedStateFromProps</code> 所取代，主要原因是性能问题</li><li><code>shouldComponentUpdate</code> 通过返回 <code>true</code> 或者 <code>false</code> 来确定是否需要触发新的渲染。主要用于性能优化</li><li><code>componentWillUpdate</code> 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 <code>getSnapshotBeforeUpdate</code> 与 <code>componentDidUpdate</code> 改造使用。</li><li>如果在 <code>componentWillUnmount</code> 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug</li><li>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加</li></ul></li></ul><p>&quot;React 的请求应该放在哪里，为什么?&quot; 这也是经常会被追问的问题。你可以这样回答。</p><p>对于异步请求，应该放在 <code>componentDidMount</code> 中去操作。从时间顺序来看，除了 <code>componentDidMount</code> 还可以有以下选择：</p><ul><li>constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，并不承载业务逻辑。而且随着类属性的流行，constructor 已经很少使用了</li><li>componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug，不利于未来 React 升级后的代码维护。</li><li>所以React 的请求放在 <code>componentDidMount 里是最好的选择</code>。</li></ul><p>透过现象看本质：React 16 缘何两次求变？</p><p>Fiber 架构简析</p><blockquote><p>Fiber 是 React 16 对 React 核心算法的一次重写。你只需要 get 到这一个点：<code>Fiber 会使原本同步的渲染过程变成异步的</code>。</p></blockquote><p>在 React 16 之前，每当我们触发一次组件的更新，React 都会构建一棵新的虚拟 DOM 树，通过与上一次的虚拟 DOM 树进行 diff，实现对 DOM 的定向更新。这个过程，是一个递归的过程。下面这张图形象地展示了这个过程的特征：</p><p><img src="/assets/20210426200953.9451f038.png" alt=""></p><p>如图所示，<code>同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回</code>。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：<code>同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成</code>。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。</p><p>而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：<code>Fiber 会将一个大的更新任务拆解为许多个小任务</code>。<code>每当执行完一个小任务时，渲染线程都会把主线程交回去</code>，看看有没有优先级更高的工作要处理，确保不会出现其他任务被&quot;饿死&quot;的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再&quot;一去不回头&quot;，而是可以被打断的，这就是所谓的&quot;异步渲染&quot;，它的执行过程如下图所示：</p><p><img src="/assets/20210426201045.9efe642a.png" alt=""></p><p>换个角度看生命周期工作流</p><p>Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个&quot;打断&quot;是有原则的，根据&quot;能否被打断&quot;这一标准，<code>React 16 的生命周期被划分为了 render 和 commit 两个阶段</code>，而 commit 阶段又被细分为了 <code>pre-commit 和 commit</code>。每个阶段所涵盖的生命周期如下图所示：</p><p><img src="/assets/20210426201155.2ab0cc5e.png" alt=""></p><p>我们先来看下三个阶段各自有哪些特征</p><ul><li><code>render 阶段</code>：纯净且没有副作用，可能会被 React 暂停、终止或重新启动。</li><li><code>pre-commit 阶段</code>：可以读取 DOM。</li><li><code>commit 阶段</code>：可以使用 DOM，运行副作用，安排更新。</li></ul><p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p><blockquote><p>为什么这样设计呢？简单来说，<code>由于 render 阶段的操作对用户来说其实是&quot;不可见&quot;的，所以就算打断再重启，对用户来说也是零感知</code>。而 <code>commit 阶段的操作则涉及真实 DOM 的渲染</code>，所以<code>这个过程必须用同步渲染来求稳</code>。</p></blockquote><p>为什么 React 16 要更改组件的生命周期详解</p><blockquote><ul><li><a href="https://interview2.poetries.top/principle-docs/react/11-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8A.html" target="_blank" rel="noopener noreferrer">React16为什么要更改生命周期(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://interview2.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html" target="_blank" rel="noopener noreferrer">React16为什么要更改生命周期(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></blockquote><h3 id="_3-react-fiber架构" tabindex="-1"><a class="header-anchor" href="#_3-react-fiber架构" aria-hidden="true">#</a> 3 React Fiber架构</h3><p>最主要的思想就是将任务拆分。</p><ul><li>DOM需要渲染时暂停，空闲时恢复。</li><li><code>window.requestIdleCallback</code></li><li>React内部实现的机制</li></ul><blockquote><p>React 追求的是 &quot;快速响应&quot;，那么，&quot;快速响应&quot;的制约因素都有什么呢</p></blockquote><ul><li><code>CPU</code>的瓶颈：当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。</li><li><code>IO</code>的瓶颈：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</li></ul><blockquote><p><code>fiber</code> 架构主要就是用来解决 <code>CPU</code> 和网络的问题，这两个问题一直也是最影响前端开发体验的地方，一个会造成卡顿，一个会造成白屏。为此 react 为前端引入了两个新概念：Time Slicing <code>时间分片</code>和<code>Suspense</code>。</p></blockquote><p>1. React 都做过哪些优化</p><ul><li>React渲染页面的两个阶段 <ul><li>调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 <code>Virtual DOM</code>，然后通过<code>Diff</code>算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。</li><li>渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上</li></ul></li><li>React 15 架构 <ul><li>React15架构可以分为两层 <ul><li>Reconciler（协调器）------ 负责找出变化的组件；</li><li>Renderer（渲染器）------ 负责将变化的组件渲染到页面上；</li></ul></li></ul></li></ul><blockquote><ul><li>在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。</li><li>为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。</li></ul></blockquote><ul><li><p>React 16 架构</p><ul><li>为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现Concurrent Mode（并发模式）。</li><li>从v15到v16，React团队花了两年时间将源码架构中的Stack Reconciler重构为Fiber Reconciler</li><li><code>React16架构可以分为三层</code>： <ul><li>Scheduler（调度器）------ 调度任务的优先级，高优任务优先进入Reconciler；</li><li>Reconciler（协调器）------ 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构；</li><li>Renderer（渲染器）------ 负责将变化的组件渲染到页面上。</li></ul></li></ul></li><li><p>React 17 优化</p><ul><li>使用Lane来管理任务的优先级。Lane用二进制位表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的&quot;赛道&quot;，而且存在批的概念，优先级越低，&quot;赛道&quot;越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。</li><li>Concurrent Mode的目的是实现一套可中断/恢复的更新机制。其由两部分组成： <ul><li>一套协程架构：Fiber Reconciler</li><li>基于协程架构的启发式更新算法：控制协程架构工作方式的算法</li></ul></li></ul></li></ul><p>2. 浏览器一帧都会干些什么以及requestIdleCallback的启示</p><blockquote><p>我们都知道，页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16.6ms 左右。那么在这一帧的（16.6ms） 过程中浏览器又干了些什么呢</p></blockquote><p><img src="/assets/20210407173320.70877264.png" alt=""></p><p>通过上面这张图可以清楚的知道，浏览器一帧会经过下面这几个过程：</p><ol><li>接受输入事件</li><li>执行事件回调</li><li>开始一帧</li><li>执行 RAF (RequestAnimationFrame)</li><li>页面布局，样式计算</li><li>绘制渲染</li><li>执行 RIC (RequestIdelCallback)</li></ol><blockquote><p>第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。</p></blockquote><blockquote><p><code>requestIdleCallback 的启示</code>：我们以浏览器是否有剩余时间作微任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>requestIdleCallback((deadline) =&gt; {
// deadline 有两个参数
  // timeRemaining(): 当前帧还剩下多少时间
  // didTimeout: 是否超时
// 另外 requestIdleCallback 后如果跟上第二个参数 {timeout: ...} 则会强制浏览器在当前帧执行完后执行。
 if (deadline.timeRemaining() &gt; 0) {
   // TODO
 } else {
  requestIdleCallback(otherTasks);
 }
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 用法示例
var tasksNum = 10000

requestIdleCallback(unImportWork)

function unImportWork(deadline) {
  while (deadline.timeRemaining() &amp;&amp; tasksNum &gt; 0) {
    console.log(`执行了${10000 - tasksNum + 1}个任务`)
    tasksNum--
  }
  if (tasksNum &gt; 0) { // 在未来的帧中继续执行
    requestIdleCallback(unImportWork)
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>其实部分浏览器已经实现了这个API，这就是requestIdleCallback。但是由于以下因素，Facebook 抛弃了 <code>requestIdleCallback</code>的原生 API：</p></blockquote><ul><li>浏览器兼容性；</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低。</li></ul><blockquote><p>基于以上原因，在React中实现了功能更完备的<code>requestIdleCallbackpolyfill</code>，这就是<code>Scheduler</code>。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置</p></blockquote><p>3. React Fiber是什么</p><blockquote><p><code>React Fiber</code>是对核心算法的一次重新实现。<code>React Fiber</code>把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会</p></blockquote><ol><li>在<code>React Fiber</code>中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来</li><li>因为一个更新过程可能被打断，所以<code>React Fiber</code>一个更新过程被分为两个阶段(<code>Phase</code>)：第一个阶段<code>Reconciliation Phase</code>和第二阶段<code>Commit Phase</code></li><li>在第一阶段<code>Reconciliation Phase</code>，<code>React Fiber</code>会找出需要更新哪些<code>DOM</code>，这个阶段是可以被打断的；但是到了第二阶段<code>Commit Phase</code>，那就一鼓作气把<code>DOM</code>更新完，绝不会被打断</li><li>这两个阶段大部分工作都是<code>React Fiber</code>做，和我们相关的也就是生命周期函数</li></ol><blockquote><p><code>React Fiber</code>改变了之前<code>react</code>的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程</p></blockquote><p>关键特性</p><ul><li>增量渲染（把渲染任务拆分成块，匀到多帧）</li><li>更新时能够暂停，终止，复用渲染任务</li><li>给不同类型的更新赋予优先级</li><li>并发方面新的基础能力</li></ul><blockquote><p>增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用</p></blockquote><p>4. 组件的渲染顺序</p><blockquote><p>假如有A,B,C,D组件，层级结构为：</p></blockquote><p><img src="/assets/20210407174007.4e07f972.png" alt=""></p><p>我们知道组件的生命周期为：</p><p>挂载阶段：</p><ul><li><code>constructor()</code></li><li><code>componentWillMount()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ul><p>更新阶段为：</p><ul><li><code>componentWillReceiveProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>componentWillUpdate()</code></li><li><code>render()</code></li><li><code>componentDidUpdate</code></li></ul><blockquote><p>那么在挂载阶段，<code>A,B,C,D</code>的生命周期渲染顺序是如何的呢？</p></blockquote><p>那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？</p><p><img src="/assets/20210407173933.d56ed985.png" alt=""></p><blockquote><p>以<code>render()</code>函数为分界线。从顶层组件开始，一直往下，直至最底层子组件。然后再往上</p></blockquote><p>组件<code>update</code>阶段同理</p><p>前面是<code>react16</code>以前的组建渲染方式。这就存在一个问题</p><blockquote><p>如果这是一个很大，层级很深的组件，<code>react</code>渲染它需要几十甚至几百毫秒，在这期间，<code>react</code>会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行</p></blockquote><p>Fiber架构就是为了解决这个问题</p><blockquote><p>看一下fiber架构 组建的渲染顺序</p></blockquote><p><img src="/assets/20210407173949.d540a942.png" alt=""></p><blockquote><p>加入<code>fiber</code>的<code>react</code>将组件更新分为两个时期</p></blockquote><p>这两个时期以render为分界</p><ul><li><code>render</code>前的生命周期为<code>phase1</code>,</li><li><code>render</code>后的生命周期为<code>phase2</code></li></ul><blockquote><ul><li><code>phase1</code>的生命周期是可以被打断的，每隔一段时间它会跳出当前渲染进程，去确定是否有其他更重要的任务。此过程，<code>React</code>在 <code>workingProgressTree</code> （并不是真实的<code>virtualDomTree</code>）上复用 <code>current</code> 上的 <code>Fiber</code> 数据结构来一步地（通过<code>requestIdleCallback</code>）来构建新的 tree，标记处需要更新的节点，放入队列中</li><li><code>phase2</code>的生命周期是不可被打断的，<code>React</code> 将其所有的变更一次性更新到<code>DOM</code>上</li></ul></blockquote><p>这里最重要的是phase1这是时期所做的事。因此我们需要具体了解phase1的机制</p><ul><li>如果不被打断，那么<code>phase1</code>执行完会直接进入<code>render</code>函数，构建真实的<code>virtualDomTree</code></li><li>如果组件再<code>phase1</code>过程中被打断，即当前组件只渲染到一半（也许是在<code>willMount</code>,也许是<code>willUpdate</code>~反正是在render之前的生命周期），那么<code>react</code>会怎么干呢？ <code>react</code>会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，<code>react</code>通过<code>callback</code>回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是<code>react</code>确实是这么干的）</li></ul><p>所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来</p><blockquote><p>这样的话，就和<code>react16</code>版本之前有很大区别了，因为可能会被执行多次，那么我们最好就得保证<code>phase1</code>的生命周期每一次执行的结果都是一样的，否则就会有问题，因此，最好都是纯函数</p></blockquote><ul><li>如果高优先级的任务一直存在，那么低优先级的任务则永远无法进行，组件永远无法继续渲染。这个问题facebook目前好像还没解决</li><li>所以，facebook在<code>react16</code>增加<code>fiber</code>结构，其实并不是为了减少组件的渲染时间，事实上也并不会减少，最重要的是现在可以使得一些更高优先级的任务，如用户的操作能够优先执行，提高用户的体验，至少用户不会感觉到卡顿</li></ul><p>5 React Fiber架构总结</p><p>React Fiber如何性能优化</p><ul><li>更新的两个阶段 <ul><li>调度算法阶段-执行diff算法，纯js计算</li><li>Commit阶段-将diff结果渲染dom</li></ul></li><li>可能会有性能问题 <ul><li>JS是单线程的，且和DOM渲染公用一个线程</li><li>当组件足够复杂，组件更新时计算和渲染压力都大</li><li>同时再有DOM操作需求（动画、鼠标拖拽等），将卡顿</li></ul></li><li>解决方案fiber <ul><li>将调度算法阶段阶段任务拆分（Commit无法拆分）</li><li>DOM需要渲染时暂停，空闲时恢复</li><li>分散执行: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code><ul><li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 <code>pollyfill</code>，而且拥有 <code>deadline</code> 参数，限制执行事件，以继续切分任务；</li><li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li></ul></li></ul></li></ul><p>React 的核心流程可以分为两个部分:</p><ul><li><code>reconciliation</code> (调度算法，也可称为 <code>render</code>) <ul><li>更新 <code>state</code> 与 <code>props</code>；</li><li>调用生命周期钩子；</li><li>生成 <code>virtual dom</code><ul><li>这里应该称为 <code>Fiber Tree</code> 更为符合；</li></ul></li><li>通过新旧 vdom 进行 diff 算法，获取 vdom change</li><li>确定是否需要重新渲染</li></ul></li><li><code>commit</code><ul><li>如需要，则操作 <code>dom</code> 节点更新</li></ul></li></ul><blockquote><p>要了解 Fiber，我们首先来看为什么需要它</p></blockquote><ul><li>问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。</li><li>解决方案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的</li><li>简述 <ul><li>在 <code>React V16</code> 将调度算法进行了重构， 将之前的 <code>stack reconciler</code> 重构成新版的 fiber <code>reconciler</code>，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启</li><li>这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</li></ul></li><li>核心 <ul><li><code>Fiber</code> 这里可以具象为一个 数据结构</li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Fiber {
	constructor(instance) {
		this.instance = instance
		// 指向第一个 child 节点
		this.child = child
		// 指向父节点
		this.return = parent
		// 指向第一个兄弟节点
		this.sibling = previous
	}	
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>链表树遍历算法: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提 <ul><li>首先通过不断遍历子节点，到树末尾；</li><li>开始通过 <code>sibling</code> 遍历兄弟节点；</li><li>return 返回父节点，继续执行2；</li><li>直到 root 节点后，跳出遍历；</li></ul></li><li>任务分割，React 中的渲染更新可以分成两个阶段 <ul><li>reconciliation 阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对</li><li>Commit 阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况</li></ul></li><li>分散执行: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code><ul><li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 <code>pollyfill</code>，而且拥有 <code>deadline</code> 参数，限制执行事件，以继续切分任务；</li><li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 类似于这样的方式
requestIdleCallback((deadline) =&gt; {
    // 当有空闲时间时，我们执行一个组件渲染；
    // 把任务塞到一个个碎片时间中去；
    while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; nextComponent) {
        nextComponent = performWork(nextComponent);
    }
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>优先级策略: 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li></ul><blockquote><ul><li>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。</li><li>核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</li><li>当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。</li></ul></blockquote><h3 id="_4-createelement过程" tabindex="-1"><a class="header-anchor" href="#_4-createelement过程" aria-hidden="true">#</a> 4 createElement过程</h3><blockquote><p>React.createElement()： 根据指定的第一个参数创建一个React元素</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>React.createElement(
  type,
  [props],
  [...children]
)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一个参数是必填，传入的是似HTML标签名称，eg: ul, li</li><li>第二个参数是选填，表示的是属性，eg: className</li><li>第三个参数是选填, 子节点，eg: 要显示的文本内容</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//写法一：

var child1 = React.createElement(&#39;li&#39;, null, &#39;one&#39;);
    var child2 = React.createElement(&#39;li&#39;, null, &#39;two&#39;);
    var content = React.createElement(&#39;ul&#39;, { className: &#39;teststyle&#39; }, child1, child2); // 第三个参数可以分开也可以写成一个数组
      ReactDOM.render(
          content,
        document.getElementById(&#39;example&#39;)
      );

//写法二：

var child1 = React.createElement(&#39;li&#39;, null, &#39;one&#39;);
    var child2 = React.createElement(&#39;li&#39;, null, &#39;two&#39;);
    var content = React.createElement(&#39;ul&#39;, { className: &#39;teststyle&#39; }, [child1, child2]);
      ReactDOM.render(
          content,
        document.getElementById(&#39;example&#39;)
      );

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-调和阶段-setstate内部干了什么" tabindex="-1"><a class="header-anchor" href="#_5-调和阶段-setstate内部干了什么" aria-hidden="true">#</a> 5 调和阶段 setState内部干了什么</h3><ul><li>当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态</li><li>这将启动一个称为和解（<code>reconciliation</code>）的过程。和解（<code>reconciliation</code>）的最终目标是以最有效的方式，根据这个新的状态来更新<code>UI</code>。 为此，<code>React</code>将构建一个新的 <code>React</code> 元素树（您可以将其视为 <code>UI</code> 的对象表示）</li><li>一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（ diff ）</li></ul><blockquote><p>通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间</p></blockquote><h3 id="_6-setstate" tabindex="-1"><a class="header-anchor" href="#_6-setstate" aria-hidden="true">#</a> 6 setState</h3><blockquote><p>在了解setState之前，我们先来简单了解下 React 一个包装结构: Transaction:</p></blockquote><p>事务 (Transaction)</p><blockquote><p>是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作</p></blockquote><ul><li>setState: React 中用于修改状态，更新视图。它具有以下特点:</li></ul><p>异步与同步: setState并不是单纯的异步或同步，这其实与调用时的环境相关:</p><ul><li>在合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是&quot;异步&quot;的； <ul><li>原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新； <ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li><li>在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；</li></ul></li><li>问题: 无法在setState后马上从this.state上获取更新后的值。</li><li>解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；</li></ul></li><li>在 原生事件 和 setTimeout 中，setState是同步的，可以马上获取更新后的值； <ul><li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li></ul></li><li>批量更新: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</li><li>函数式: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) =&gt; newState)； <ul><li>使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；</li></ul></li></ul><p>注意事项:</p><ul><li>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li><li>当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法 <ul><li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li><li>在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；</li></ul></li></ul><p>总结</p><blockquote><p>setState 并非真异步，只是看上去像异步。在源码中，通过 <code>isBatchingUpdates</code> 来判断</p></blockquote><ul><li><code>setState</code> 是先存进 <code>state</code> 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</li><li>那么什么情况下 <code>isBatchingUpdates</code> 会为 <code>true</code> 呢？在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li><li>但在 React 无法控制的地方，比如原生事件，具体就是在 <code>addEventListener</code> 、<code>setTimeout</code>、<code>setInterval</code> 等事件中，就只能同步更新。</li></ul><blockquote><p>一般认为，<code>做异步设计是为了性能优化、减少渲染次数</code>，React 团队还补充了两点。</p></blockquote><ul><li>保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</li><li>启用并发更新，完成异步渲染。</li></ul><p><img src="/assets/20210425140749.02634e75.png" alt=""></p><ol><li><code>setState</code> 只有在 React 自身的合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步的</li><li><code>setState</code> 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的异步。当然可以通过 setState 的第二个参数中的 callback 拿到更新后的结果</li><li><code>setState</code> 的批量更新优化也是建立在异步（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在异步中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，去最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</li></ol><ul><li>合成事件中是异步</li><li>钩子函数中的是异步</li><li>原生事件中是同步</li><li>setTimeout中是同步</li></ul><p><img src="/assets/20210409153900.ba5410ab.png" alt="">  <img src="/assets/20210409153914.cbce5559.png" alt="">  <img src="/assets/20210409153926.c0cb2805.png" alt="">  <img src="/assets/20210409153942.bebc8788.png" alt="">  <img src="/assets/20210409154004.2d55b130.png" alt="">  <img src="/assets/20210409154015.101414f0.png" alt=""></p><p>这是一道经常会出现的 React setState 笔试题：下面的代码输出什么呢？</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Test extends React.Component {
  state  = {
      count: 0
  };

    componentDidMount() {
    this.setState({count: this.state.count + 1});
    console.log(this.state.count);

    this.setState({count: this.state.count + 1});
    console.log(this.state.count);

    setTimeout(() =&gt; {
      this.setState({count: this.state.count + 1});
      console.log(this.state.count);

      this.setState({count: this.state.count + 1});
      console.log(this.state.count);
    }, 0);
  }

  render() {
    return null;
  }
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以进行如下的分析：</p><ul><li>首先第一次和第二次的 <code>console.log</code>，都在 React 的生命周期事件中，所以是异步的处理方式，则输出都为 <code>0</code>；</li><li>而在 <code>setTimeout</code> 中的 <code>console.log</code> 处于原生事件中，所以会同步的处理再输出结果，但需要注意，虽然 <code>count</code> 在前面经过了两次的 <code>this.state.count + 1</code>，但是每次获取的 <code>this.state.count</code> 都是初始化时的值，也就是 <code>0</code>；</li><li>所以此时 <code>count</code> 是 <code>1</code>，那么后续在 <code>setTimeout</code>中的输出则是 <code>2</code> 和 <code>3</code>。</li></ul><p>所以完整答案是 <code>0,0,2,3</code></p><p>同步场景</p><p>异步场景中的案例使我们建立了这样一个认知：setState 是异步的，但下面这个案例又会颠覆你的认知。如果我们将 setState 放在 setTimeout 事件中，那情况就完全不同了。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Test extends Component {
    state = {
        count: 0
    }

    componentDidMount(){
        this.setState({ count: this.state.count + 1 });
        console.log(this.state.count);
        setTimeout(() =&gt; {
          this.setState({ count: this.state.count + 1 });
          console.log(&quot;setTimeout: &quot; + this.state.count);
        }, 0);
    }

    render(){
        ...
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那这时输出的应该是什么呢？如果你认为是 0,0，那么又错了。</p><p>正确的结果是 <code>0,2</code>。因为 <code>setState</code> 并不是真正的异步函数，它实际上是通过队列延迟执行操作实现的，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新。值为 true 则执行异步操作，false 则直接同步更新</p><p>接下来这个案例的答案是什么呢</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Test extends Component {
    state = {
        count: 0
    }

    componentDidMount(){
        this.setState({
           count: this.state.count + 1
         }, () =&gt; {
            console.log(this.state.count)
         })
         this.setState({
           count: this.state.count + 1
         }, () =&gt; {
            console.log(this.state.count)
         })
    }

    render(){
        ...
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你觉得答案是 <code>1,2</code>，那肯定就错了。这种迷惑性极强的考题在面试中非常常见，因为它反直觉。</p><p>如果重新仔细思考，你会发现当前拿到的 <code>this.state.count</code> 的值并没有变化，都是 <code>0</code>，所以输出结果应该是 <code>1,1</code>。</p><p>当然，也可以在 <code>setState</code> 函数中获取修改后的 <code>state</code> 值进行修改。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Test extends Component {
    state = {
        count: 0
    }

    componentDidMount(){
        this.setState(
          preState=&gt; ({
            count:preState.count + 1
        }),()=&gt;{
           console.log(this.state.count)
        })
        this.setState(
          preState=&gt;({
            count:preState.count + 1
        }),()=&gt;{
           console.log(this.state.count)
        })
    }

    render(){
        ...
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些通通是异步的回调，如果你以为输出结果是 1,2，那就又错了，<code>实际上是 2,2</code>。</p><p>为什么会这样呢？当调用 <code>setState</code> 函数时，就会<code>把当前的操作放入队列中</code>。React 根据队列内容，合并 state 数据，完成后再逐一执行回调，根据结果更新虚拟 DOM，触发渲染。所以<code>回调时，state 已经合并计算完成了</code>，输出的结果就是 <code>2,2</code> 了。</p><h3 id="_7-setstate原理分析" tabindex="-1"><a class="header-anchor" href="#_7-setstate原理分析" aria-hidden="true">#</a> 7 setState原理分析</h3><p>1. setState异步更新</p><ul><li>我们都知道，<code>React</code>通过<code>this.state</code>来访问<code>state</code>，通过<code>this.setState()</code>方法来更新<code>state</code>。当<code>this.setState()</code>方法被调用的时候，<code>React</code>会重新调用<code>render</code>方法来重新渲染<code>UI</code></li><li>首先如果直接在<code>setState</code>后面获取<code>state</code>的值是获取不到的。在<code>React</code>内部机制能检测到的地方， <code>setState</code>就是异步的；<code>在React</code>检测不到的地方，例如<code>setInterval</code>,<code>setTimeout</code>，<code>setState</code>就是同步更新的</li></ul><p><img src="/assets/20220307225431.984f1290.png" alt="img"></p><blockquote><p>因为<code>setState</code>是可以接受两个参数的，一个<code>state</code>，一个回调函数。因此我们可以在回调函数里面获取值</p></blockquote><p><img src="/assets/20220307225432.0ee5b4e3.png" alt="img"></p><ul><li><code>setState</code>方法通过一个队列机制实现<code>state</code>更新，当执行<code>setState</code>的时候，会将需要更新的<code>state</code>合并之后放入状态队列，而不会立即更新<code>this.state</code></li><li>如果我们不使用<code>setState</code>而是使用<code>this.state.key</code>来修改，将不会触发组件的<code>re-render</code>。</li><li>如果将<code>this.state</code>赋值给一个新的对象引用，那么其他不在对象上的<code>state</code>将不会被放入状态队列中，当下次调用<code>setState</code>并对状态队列进行合并时，直接造成了<code>state</code>丢失</li></ul><p>1.1 setState批量更新的过程</p><blockquote><p>在<code>react</code>生命周期和合成事件执行前后都有相应的钩子，分别是<code>pre</code>钩子和<code>post</code>钩子，<code>pre</code>钩子会调用<code>batchedUpdate</code>方法将<code>isBatchingUpdates</code>变量置为<code>true</code>，开启批量更新，而<code>post</code>钩子会将<code>isBatchingUpdates</code>置为<code>false</code></p></blockquote><ul><li><code>isBatchingUpdates</code>变量置为<code>true</code>，则会走批量更新分支，<code>setState</code>的更新会被存入队列中，待同步代码执行完后，再执行队列中的<code>state</code>更新。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code>的组件）放入 <code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</li><li>而在原生事件和异步操作中，不会执行<code>pre</code>钩子，或者生命周期的中的异步操作之前执行了<code>pre</code>钩子，但是<code>pos</code>钩子也在异步操作之前执行完了，<code>isBatchingUpdates</code>必定为<code>false</code>，也就不会进行批量更新</li></ul><p><img src="/assets/20220307225434.6cd0da60.png" alt="img"></p><blockquote><p><code>enqueueUpdate</code>包含了<code>React</code>避免重复<code>render</code>的逻辑。<code>mountComponent</code>和<code>updateComponent</code>方法在执行的最开始，会调用到<code>batchedUpdates</code>进行批处理更新，此时会将<code>isBatchingUpdates</code>设置为<code>true</code>，也就是将状态标记为现在正处于更新阶段了。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code> 的组件）放入<code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</p></blockquote><p>1.2 为什么直接修改this.state无效</p><ul><li>要知道<code>setState</code>本质是通过一个队列机制实现<code>state</code>更新的。 执行<code>setState</code>时，会将需要更新的state合并后放入状态队列，而不会立刻更新<code>state</code>，队列机制可以批量更新<code>state</code>。</li><li>如果不通过<code>setState</code>而直接修改<code>this.state</code>，那么这个<code>state</code>不会放入状态队列中，下次调用<code>setState</code>时对状态队列进行合并时，会忽略之前直接被修改的<code>state</code>，这样我们就无法合并了，而且实际也没有把你想要的<code>state</code>更新上去</li></ul><p>1.3 什么是批量更新 Batch Update</p><blockquote><p>在一些<code>mv*</code>框架中，，就是将一段时间内对<code>model</code>的修改批量更新到<code>view</code>的机制。比如那前端比较火的<code>React</code>、<code>vue</code>（<code>nextTick</code>机制,视图的更新以及实现）</p></blockquote><p>1.4 setState之后发生的事情</p><ul><li><code>setState</code>操作并不保证是同步的，也可以认为是异步的</li><li><code>React</code>在<code>setState</code>之后，会经对<code>state</code>进行<code>diff</code>，判断是否有改变，然后去<code>diff dom</code>决定是否要更新<code>UI</code>。如果这一系列过程立刻发生在每一个<code>setState</code>之后，就可能会有性能问题</li><li>在短时间内频繁<code>setState</code>。<code>React</code>会将<code>state</code>的改变压入栈中，在合适的时机，批量更新<code>state</code>和视图，达到提高性能的效果</li></ul><p>1.5 如何知道state已经被更新</p><blockquote><p>传入回调函数</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>setState({
    index: 1
}}, function(){
    console.log(this.state.index);
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在钩子函数中体现</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>componentDidUpdate(){
    console.log(this.state.index);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2. setState循环调用风险</p><ul><li>当调用<code>setState</code>时，实际上会执行<code>enqueueSetState</code>方法，并对<code>partialState</code>以及<code>_pending-StateQueue</code>更新队列进行合并操作，最终通过<code>enqueueUpdate</code>执行<code>state</code>更新</li><li>而<code>performUpdateIfNecessary</code>方法会获<code>取_pendingElement</code>,<code>_pendingStateQueue</code>，<code>_pending-ForceUpdate</code>，并调用<code>receiveComponent</code>和<code>updateComponent</code>方法进行组件更新</li><li>如果在<code>shouldComponentUpdate</code>或者<code>componentWillUpdate</code>方法中调用<code>setState</code>，此时<code>this._pending-StateQueue != null</code>，就会造成循环调用，使得浏览器内存占满后崩溃</li></ul><p>3 事务</p><ul><li>事务就是将需要执行的方法使用<code>wrapper</code>封装起来，再通过事务提供的<code>perform</code>方法执行，先执行<code>wrapper</code>中的<code>initialize</code>方法，执行完<code>perform</code>之后，在执行所有的<code>close</code>方法，一组<code>initialize</code>及<code>close</code>方法称为一个<code>wrapper</code>。</li><li>那么事务和<code>setState</code>方法的不同表现有什么关系，首先我们把<code>4</code>次<code>setStat</code>e简单归类，前两次属于一类，因为它们在同一调用栈中执行，<code>setTimeout</code>中的两次<code>setState</code>属于另一类</li><li>在<code>setState</code>调用之前，已经处在<code>batchedUpdates</code>执行的事务中了。那么这次<code>batchedUpdates</code>方法是谁调用的呢，原来是<code>ReactMount.js</code>中的<code>_renderNewRootComponent</code>方法。也就是说，整个将<code>React</code>组件渲染到<code>DOM</code>中的过程就是处于一个大的事务中。而在<code>componentDidMount</code>中调用<code>setState</code>时，<code>batchingStrategy</code>的<code>isBatchingUpdates</code>已经被设为了<code>true</code>，所以两次<code>setState</code>的结果没有立即生效</li><li>再反观<code>setTimeout</code>中的两次<code>setState</code>，因为没有前置的<code>batchedUpdates</code>调用，所以导致了新的<code>state</code>马上生效</li></ul><p>4. 总结</p><ul><li>通过<code>setState</code>去更新<code>this.state</code>，不要直接操作<code>this.state</code>，请把它当成不可变的</li><li>调用<code>setState</code>更新<code>this.state</code>不是马上生效的，它是异步的，所以不要天真以为执行完<code>setState</code>后<code>this.state</code>就是最新的值了</li><li>多个顺序执行的<code>setState</code>不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行，即批处理</li></ul><h3 id="_8-react事务机制" tabindex="-1"><a class="header-anchor" href="#_8-react事务机制" aria-hidden="true">#</a> 8 React事务机制</h3><p><img src="/assets/20210409154118.03700342.png" alt="">  <img src="/assets/20210409154127.114a0399.png" alt="">  <img src="/assets/20210409154136.32266af2.png" alt=""></p><h3 id="_9-react组件和渲染更新过程" tabindex="-1"><a class="header-anchor" href="#_9-react组件和渲染更新过程" aria-hidden="true">#</a> 9 React组件和渲染更新过程</h3><p>渲染和更新过程</p><ul><li>jsx如何渲染为页面</li><li>setState之后如何更新页面</li><li>面试考察全流程</li></ul><p>JSX本质和vdom</p><ul><li>JSX即<code>createElement</code>函数</li><li>执行生成vnode</li><li><code>patch(elem,vnode)</code>和<code>patch(vnode,newNode)</code></li></ul><p>组件渲染过程</p><ul><li><code>props state</code></li><li><code>render()</code>生成<code>vnode</code></li><li><code>patch(elem, vnode)</code></li></ul><p>组件更新过程</p><ul><li><code>setState--&gt;dirtyComponents</code>(可能有子组件)</li><li><code>render</code>生成<code>newVnode</code></li><li><code>patch(vnode, newVnode)</code></li></ul><h3 id="_10-如何解释-react-的渲染流程" tabindex="-1"><a class="header-anchor" href="#_10-如何解释-react-的渲染流程" aria-hidden="true">#</a> 10 如何解释 React 的渲染流程</h3><p><img src="/assets/20210425210718.ddc9830d.png" alt=""></p><ul><li>React 的渲染过程大致一致，但协调并不相同，以 <code>React 16</code> 为分界线，分为 <code>Stack Reconciler</code> 和 <code>Fiber Reconciler</code>。这里的协调从狭义上来讲，特指 React 的 diff 算法，广义上来讲，有时候也指 React 的 <code>reconciler</code> 模块，它通常包含了 <code>diff</code> 算法和一些公共逻辑。</li><li>回到 <code>Stack Reconciler</code> 中，<code>Stack Reconciler</code> 的<code>核心调度方式是递归</code>。<code>调度的基本处理单位是事务</code>，它的事务基类是 <code>Transaction</code>，这里的<code>事务是 React 团队从后端开发中加入的概念</code>。在 React 16 以前，<code>挂载主要通过 ReactMount 模块完成</code>，更新通过 <code>ReactUpdate</code> 模块完成，模块之间相互分离，落脚执行点也是事务。</li><li>在 <code>React 16</code> 及以后，协调改为了 <code>Fiber Reconciler</code>。它的调度方式主要有两个特点，<code>第一个是协作式多任务模式</code>，在这个模式下，线程会定时放弃自己的运行权利，交还给主线程，通过<code>requestIdleCallback</code> 实现。<code>第二个特点是策略优先级</code>，调度任务通过标记 <code>tag</code> 的方式分优先级执行，比如动画，或者标记为 <code>high</code> 的任务可以优先执行。<code>Fiber Reconciler</code>的基本单位是 <code>Fiber</code>，<code>Fiber</code> 基于过去的 <code>React Element</code> 提供了二次封装，提供了指向父、子、兄弟节点的引用，为 <code>diff</code> 工作的双链表实现提供了基础。</li><li>在新的架构下，整个生命周期被划分为 <code>Render 和 Commit 两个阶段</code>。<code>Render 阶段的执行特点是可中断、可停止、无副作用</code>，主要是通过构造 <code>workInProgress</code> 树计算出 <code>diff</code>。以 <code>current</code> 树为基础，将每个 <code>Fiber</code>作为一个基本单位，自下而上逐个节点检查并构造 workInProgress 树。这个过程不再是递归，而是基于循环来完成</li><li>在执行上通过 <code>requestIdleCallback</code> 来调度执行每组任务，每组中的每个计算任务被称为 <code>work</code>，每个 <code>work</code> 完成后确认是否有优先级更高的 <code>work</code> 需要插入，如果有就让位，没有就继续。优先级通常是标记为动画或者 <code>high</code> 的会先处理。每完成一组后，将调度权交回主线程，直到下一次 <code>requestIdleCallback</code> 调用，再继续构建 <code>workInProgress</code> 树</li><li>在 <code>commit</code> 阶段需要处理 <code>effect</code> 列表，这里的 <code>effect</code> 列表包含了根据 <code>diff 更新 DOM 树</code>、<code>回调生命周期</code>、<code>响应 ref</code> 等。</li><li>但一定要注意，这个阶段是同步执行的，不可中断暂停，所以不要在 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWiilUnmount</code>中去执行重度消耗算力的任务</li><li>如果只是一般的应用场景，比如管理后台、H5 展示页等，两者性能差距并不大，但在动画、画布及手势等场景下，<code>Stack Reconciler</code> 的设计会占用占主线程，造成卡顿，而 <code>fiber reconciler</code> 的设计则能带来高性能的表现</li></ul><h3 id="_11-diff算法是怎么运作" tabindex="-1"><a class="header-anchor" href="#_11-diff算法是怎么运作" aria-hidden="true">#</a> 11 diff算法是怎么运作</h3><blockquote><p>每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点</p></blockquote><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li><li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li><li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li><li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul><p>优化⬇️</p><blockquote><p>为了降低算法复杂度，<code>React</code>的<code>diff</code>会预设三个限制：</p></blockquote><ol><li>只对同级元素进行<code>Diff</code>。如果一个<code>DOM节点</code>在前后两次更新中跨越了层级，那么<code>React</code>不会尝试复用他。</li><li>两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。</li><li>开发者可以通过 <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</li></ol><p>Diff的思路</p><p>该如何设计算法呢？如果让我设计一个<code>Diff算法</code>，我首先想到的方案是：</p><ol><li>判断当前节点的更新属于哪种情况</li><li>如果是<code>新增</code>，执行新增逻辑</li><li>如果是<code>删除</code>，执行删除逻辑</li><li>如果是<code>更新</code>，执行更新逻辑</li></ol><ul><li>按这个方案，其实有个隐含的前提------不同操作的优先级是相同的</li><li>但是<code>React团队</code>发现，在日常开发中，相较于<code>新增</code>和<code>删除</code>，<code>更新</code>组件发生的频率更高。所以<code>Diff</code>会优先判断当前节点是否属于<code>更新</code>。</li></ul><p>基于以上原因，<code>Diff算法</code>的整体逻辑会经历两轮遍历：</p><ul><li>第一轮遍历：处理<code>更新</code>的节点。</li><li>第二轮遍历：处理剩下的不属于<code>更新</code>的节点。</li></ul><p><img src="/assets/20210307225249.3881213a.png" alt=""></p><p>diff算法的作用</p><p>计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。</p><p>传统diff算法</p><blockquote><p>通过循环递归对节点进行依次对比，算法复杂度达到 <code>O(n^3)</code> ，n是树的节点数，这个有多可怕呢？------如果要展示1000个节点，得执行上亿次比较。。即便是CPU快能执行30亿条命令，也很难在一秒内计算出差异。</p></blockquote><p>React的diff算法</p><ol><li>什么是调和？</li></ol><blockquote><p>将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。</p></blockquote><ol><li>什么是React diff算法？</li></ol><blockquote><p><code>diff</code>算法是调和的具体实现。</p></blockquote><p>diff策略</p><blockquote><p>React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度</p></blockquote><p>策略一（tree diff）：</p><ul><li>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。</li></ul><p>策略二（component diff）：</p><ul><li>拥有相同类的两个组件 生成相似的树形结构，</li><li>拥有不同类的两个组件 生成不同的树形结构。</li></ul><p>策略三（element diff）：</p><p>对于同一层级的一组子节点，通过唯一id区分。</p><p>tree diff</p><ul><li>React通过updateDepth对Virtual DOM树进行层级控制。</li><li>对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。</li><li>只需遍历一次，就能完成整棵DOM树的比较。</li></ul><p><img src="/assets/20217224725566.58c8dce7.png" alt=""></p><p>那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？</p><blockquote><p>答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。</p></blockquote><p><img src="/assets/20217224829092.a5c85deb.png" alt=""></p><blockquote><p>如上图所示，以A为根节点的整棵树会被重新创建，而不是移动，因此 官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点</p></blockquote><p>component diff</p><blockquote><p>React对不同的组件间的比较，有三种策略</p></blockquote><ol><li>同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。</li><li>同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 <code>shouldComponentUpdate()</code> 来判断是否需要 判断计算。</li><li>不同类型的组件，将一个（将被改变的）组件判断为<code>dirty component</code>（脏组件），从而替换 整个组件的所有节点。</li></ol><blockquote><p>注意：如果组件D和组件G的结构相似，但是 React判断是 不同类型的组件，则不会比较其结构，而是删除 组件D及其子节点，创建组件G及其子节点。</p></blockquote><p>element diff</p><blockquote><p>当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。</p></blockquote><ul><li>插入：组件 C 不在集合（A,B）中，需要插入</li><li>删除： <ul><li>组件 D 在集合（A,B,D）中，但 D的节点已经更改，不能复用和更新，所以需要删除 旧的 D ，再创建新的。</li><li>组件 D 之前在 集合（A,B,D）中，但集合变成新的集合（A,B）了，D 就需要被删除。</li></ul></li><li>移动：组件D已经在集合（A,B,C,D）里了，且集合更新时，D没有发生更新，只是位置改变，如新集合（A,D,B,C），D在第二个，无须像传统diff，让旧集合的第二个B和新集合的第二个D 比较，并且删除第二个位置的B，再在第二个位置插入D，而是 （对同一层级的同组子节点） 添加唯一key进行区分，移动即��。</li></ul><p>总结</p><ol><li><code>tree diff</code>：只对比同一层的 dom 节点，忽略 dom 节点的跨层级移动</li></ol><p>如下图，react 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。</p><p>这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p><p><img src="/assets/20212195610674.3dee2b73.png" alt=""></p><p>这就意味着，如果 dom 节点发生了跨层级移动，react 会删除旧的节点，生成新的节点，而不会复用。</p><ol><li><code>component diff</code>：如果不是同一类型的组件，会删除旧的组件，创建新的组件</li></ol><p><img src="/assets/20212195654736.8f14474f.png" alt=""></p><ol><li><code>element diff</code>：对于同一层级的一组子节点，需要通过唯一 id 进行来区分</li></ol><ul><li>如果没有 id 来进行区分，一旦有插入动作，会导致插入位置之后的列表全部重新渲染</li><li>这也是为什么渲染列表时为什么要使用唯一的 key。</li></ul><p>diff的不足与待优化的地方</p><blockquote><p>尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，会影响React的渲染性能</p></blockquote><p>与其他框架相比，React 的 diff 算法有何不同？</p><p><img src="/assets/20210425203918.35195d93.png" alt=""></p><blockquote><p>diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新</p></blockquote><p><img src="/assets/20210425204127.4cff35bb.png" alt=""></p><p>具体的流程是这样的：</p><ul><li>真实 DOM 与虚拟 DOM 之间存在一个映射关系。这个映射关系依靠初始化时的 JSX 建立完成；</li><li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li><li>最后再根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li></ul><p><img src="/assets/20210425204151.9de8cf09.png" alt=""></p><p>在回答有何不同之前，首先需要说明下什么是 diff 算法。</p><ul><li><code>diff 算法是指生成更新补丁的方式</code>，主要应用于<code>虚拟 DOM 树变化后，更新真实 DOM</code>。所以 diff 算法一定存在这样一个过程：<code>触发更新 → 生成补丁 → 应用补丁</code></li><li>React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。<code>将单一节点比对转化为了 3 种类型节点的比对</code>，分别是<code>树、组件及元素</code>，以此提升效率。 <ul><li><code>树比对</code>：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</li><li><code>组件比对</code>：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</li><li><code>元素比对</code>：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。同一层级的子节点，可以通过标记 key 的方式进行列表对比。</li></ul></li><li>以上是经典的 React diff 算法内容。<code>自 React 16 起，引入了 Fiber 架构</code>。为了使整个更新过程<code>可随时暂停恢复</code>，节点与树分别采用了 <code>FiberNode 与 FiberTree 进行重构</code>。<code>fiberNode 使用了双链表的结构</code>，可以直接找到兄弟节点与子节点</li><li>然后拿 Vue 和 Preact 与 React 的 diff 算法进行对比 <ul><li><code>Preact</code> 的 <code>Diff</code> 算法相较于 <code>React</code>，整体设计思路相似，但最底层的元素采用了真实 <code>DOM</code> 对比操作，也没有采用 <code>Fiber</code> 设计。Vue 的 <code>Diff</code> 算法整体也与 <code>React</code> 相似，同样未实现 <code>Fiber</code> 设计</li></ul></li><li>然后进行横向比较，<code>React 拥有完整的 Diff 算法策略，且拥有随时中断更新的时间切片能力</code>，在大批量节点更新的极端情况下，拥有更友好的交互体验。</li><li>Preact 可以在一些对性能要求不高，仅需要渲染框架的简单场景下应用。</li><li>Vue 的整体 <code>diff 策略与 React 对齐</code>，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</li></ul><p>**学习原理的目的就是应用。那如何根据 React diff 算法原理优化代码呢？**这个问题其实按优化方式逆向回答即可。</p><ul><li>根据 <code>diff</code> 算法的设计原则，应尽量避免跨层级节点移动。</li><li>通过设置唯一 <code>key</code> 进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。</li><li>设置 <code>shouldComponentUpdate</code> 或者 <code>React.pureComponet</code> 减少 <code>diff</code> 次数。</li></ul><h3 id="_12-合成事件原理" tabindex="-1"><a class="header-anchor" href="#_12-合成事件原理" aria-hidden="true">#</a> 12 合成事件原理</h3><blockquote><p>为了解决跨浏览器兼容性问题，<code>React</code> 会将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的</p></blockquote><ul><li>所有的事件挂在document上，DOM 事件触发后冒泡到 document；React 找到对应的组件，造出一个合成事件出来；并按组件树模拟一遍事件冒泡。</li><li>event不是原生的，是SyntheticEvent合成事件对象</li><li>和Vue事件不同,和DOM事件也不同</li></ul><p>React 17 之前的事件冒泡流程图</p><p><img src="/assets/20210425135711.3fe30341.png" alt=""></p><blockquote><p>所以这就造成了，在一个页面中，只能有一个版本的 React。如果有多个版本，事件就乱套了。值得一提的是，这个问题在 React 17 中得到了解决，事件委托不再挂在 document 上，而是挂在 DOM 容器上，也就是 <code>ReactDom.Render</code> 所调用的节点上。</p></blockquote><p>React 17 后的事件冒泡流程图</p><p><img src="/assets/20210425135751.c4fe5a69.png" alt=""></p><blockquote><p>那到底哪些事件会被捕获生成合成事件呢？可以从 React 的源码测试文件中一探究竟。下面的测试快照中罗列了大量的事件名，也只有在这份快照中的事件，才会被捕获生成合成事件。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// react/packages/react-dom/src/__tests__/__snapshots__/ReactTestUtils-test.js.snap
Array [
	  &quot;abort&quot;,
	  &quot;animationEnd&quot;,
	  &quot;animationIteration&quot;,
	  &quot;animationStart&quot;,
	  &quot;auxClick&quot;,
	  &quot;beforeInput&quot;,
	  &quot;blur&quot;,
	  &quot;canPlay&quot;,
	  &quot;canPlayThrough&quot;,
	  &quot;cancel&quot;,
	  &quot;change&quot;,
	  &quot;click&quot;,
	  &quot;close&quot;,
	  &quot;compositionEnd&quot;,
	  &quot;compositionStart&quot;,
	  &quot;compositionUpdate&quot;,
	  &quot;contextMenu&quot;,
	  &quot;copy&quot;,
	  &quot;cut&quot;,
	  &quot;doubleClick&quot;,
	  &quot;drag&quot;,
	  &quot;dragEnd&quot;,
	  &quot;dragEnter&quot;,
	  &quot;dragExit&quot;,
	  &quot;dragLeave&quot;,
	  &quot;dragOver&quot;,
	  &quot;dragStart&quot;,
	  &quot;drop&quot;,
	  &quot;durationChange&quot;,
	  &quot;emptied&quot;,
	  &quot;encrypted&quot;,
	  &quot;ended&quot;,
	  &quot;error&quot;,
	  &quot;focus&quot;,
	  &quot;gotPointerCapture&quot;,
	  &quot;input&quot;,
	  &quot;invalid&quot;,
	  &quot;keyDown&quot;,
	  &quot;keyPress&quot;,
	  &quot;keyUp&quot;,
	  &quot;load&quot;,
	  &quot;loadStart&quot;,
	  &quot;loadedData&quot;,
	  &quot;loadedMetadata&quot;,
	  &quot;lostPointerCapture&quot;,
	  &quot;mouseDown&quot;,
	  &quot;mouseEnter&quot;,
	  &quot;mouseLeave&quot;,
	  &quot;mouseMove&quot;,
	  &quot;mouseOut&quot;,
	  &quot;mouseOver&quot;,
	  &quot;mouseUp&quot;,
	  &quot;paste&quot;,
	  &quot;pause&quot;,
	  &quot;play&quot;,
	  &quot;playing&quot;,
	  &quot;pointerCancel&quot;,
	  &quot;pointerDown&quot;,
	  &quot;pointerEnter&quot;,
	  &quot;pointerLeave&quot;,
	  &quot;pointerMove&quot;,
	  &quot;pointerOut&quot;,
	  &quot;pointerOver&quot;,
	  &quot;pointerUp&quot;,
	  &quot;progress&quot;,
	  &quot;rateChange&quot;,
	  &quot;reset&quot;,
	  &quot;scroll&quot;,
	  &quot;seeked&quot;,
	  &quot;seeking&quot;,
	  &quot;select&quot;,
	  &quot;stalled&quot;,
	  &quot;submit&quot;,
	  &quot;suspend&quot;,
	  &quot;timeUpdate&quot;,
	  &quot;toggle&quot;,
	  &quot;touchCancel&quot;,
	  &quot;touchEnd&quot;,
	  &quot;touchMove&quot;,
	  &quot;touchStart&quot;,
	  &quot;transitionEnd&quot;,
	  &quot;volumeChange&quot;,
	  &quot;waiting&quot;,
	  &quot;wheel&quot;,
	]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如果DOM上绑定了过多的事件处理函数,整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用,同时屏蔽底层不同浏览器之间的事件系统的差异,实现了一个中间层 - SyntheticEvent</p></blockquote><ol><li>当用户在为onClick添加函数时,React并没有将Click绑定到DOM上面</li><li>而是在document处监听所有支持的事件,当事件发生并冒泡至document处时,React将事件内容封装交给中间层 SyntheticEvent (负责所有事件合成)</li><li>所以当事件触发的时候, 对使用统一的分发函数 dispatchEvent 将指定函数执行</li></ol><p><img src="/assets/20210409153648.e2f02402.png" alt=""></p><p>为何要合成事件</p><ul><li>兼容性和跨平台</li><li>挂在统一的document上，减少内存消耗，避免频繁解绑</li><li>方便事件的统一管理（事务机制）</li><li>dispatchEvent事件机制</li></ul><h3 id="_13-jsx语法糖本质" tabindex="-1"><a class="header-anchor" href="#_13-jsx语法糖本质" aria-hidden="true">#</a> 13 JSX语法糖本质</h3><blockquote><p>JSX是语法糖，通过babel转成<code>React.createElement</code>函数，在babel官网上可以在线把JSX转成React的JS语法</p></blockquote><ul><li>首先解析出来的话，就是一个<code>createElement</code>函数</li><li>然后这个函数执行完后，会返回一个<code>vnode</code></li><li>通过vdom的patch或者是其他的一个方法，最后渲染一个页面</li></ul><p><img src="/assets/20210407215708.156c9472.png" alt="">  <img src="/assets/20210407215721.81df3538.png" alt=""></p><blockquote><p>script标签中不添加<code>text/babel</code>解析jsx语法的情况下</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;script&gt;
  const ele = React.createElement(&quot;h2&quot;, null, &quot;Hello React!&quot;);
  ReactDOM.render(ele, document.getElementById(&quot;app&quot;));
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JSX的本质是React.createElement()函数</p><p><img src="/assets/20210407215754.464eb8ca.png" alt=""></p><blockquote><p><code>createElement</code>函数返回的对象是<code>ReactEelement</code>对象。</p></blockquote><p><code>createElement</code>的写法如下</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class App extends React.Component {
  constructor() {
    super()
    this.state = {}
  }

  render() {
    return React.createElement(&quot;div&quot;, null,
        /*第一个子元素，header*/
        React.createElement(&quot;div&quot;, { className: &quot;header&quot; },
                            React.createElement(&quot;h1&quot;, { title: &quot;\u6807\u9898&quot; }, &quot;\u6211\u662F\u6807\u9898&quot;)
                          ),
        /*第二个子元素，content*/
        React.createElement(&quot;div&quot;, { className: &quot;content&quot; },
                            React.createElement(&quot;h2&quot;, null, &quot;\u6211\u662F\u9875\u9762\u7684\u5185\u5BB9&quot;),
                            React.createElement(&quot;button&quot;, null, &quot;\u6309\u94AE&quot;),
                            React.createElement(&quot;button&quot;, null, &quot;+1&quot;),
                            React.createElement(&quot;a&quot;, { href: &quot;http://www.baidu.com&quot; },
                                                &quot;\u767E\u5EA6\u4E00\u4E0B&quot;)
                          ),
        /*第三个子元素，footer*/
        React.createElement(&quot;div&quot;, { className: &quot;footer&quot; },
                            React.createElement(&quot;p&quot;, null, &quot;\u6211\u662F\u5C3E\u90E8\u7684\u5185\u5BB9&quot;)
                          )
      );
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际开发中不会使用<code>createElement</code>来创建<code>ReactElement</code>的，一般都是使用JSX的形式开发。</p><p><code>ReactElement</code>在程序中打印一下</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>render() {
  let ele = (
    &lt;div&gt;
      &lt;div className=&quot;header&quot;&gt;
        &lt;h1 title=&quot;标题&quot;&gt;我是标题&lt;/h1&gt;
      &lt;/div&gt;
      &lt;div className=&quot;content&quot;&gt;
        &lt;h2&gt;我是页面的内容&lt;/h2&gt;
        &lt;button&gt;按钮&lt;/button&gt;
        &lt;button&gt;+1&lt;/button&gt;
        &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;
      &lt;/div&gt;
      &lt;div className=&quot;footer&quot;&gt;
        &lt;p&gt;我是尾部的内容&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
  console.log(ele);
  return ele;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210407220013.1b9c2fe1.png" alt=""></p><blockquote><p>react通过babel把JSX转成<code>createElement</code>函数，生成<code>ReactElement</code>对象，然后通过<code>ReactDOM.render函</code>数把<code>ReactElement</code>渲染成真实的<code>DOM</code>元素</p></blockquote><p>为什么 React 使用 JSX</p><p><img src="/assets/20210425120721.666ecd18.png" alt=""></p><ul><li>在回答问题之前，我首先解释下什么是 JSX 吧。JSX 是一个 <code>JavaScript</code> 的语法扩展，结构类似 XML。</li><li>JSX 主要用于声明 <code>React</code> 元素，但 React 中并不强制使用 <code>JSX</code>。即使使用了 <code>JSX</code>，也会在构建过程中，通过 Babel 插件编译为 <code>React.createElement</code>。所以 JSX 更像是 <code>React.createElement</code> 的一种语法糖</li><li>接下来与 JSX 以外的三种技术方案进行对比 <ul><li>首先是模板，React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案</li><li>其次是模板字符串，模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重</li><li>所以 React 最后选用了 JSX，因为 JSX 与其设计思想贴合，不需要引入过多新的概念，对编辑器的代码提示也极为友好。</li></ul></li></ul><p>Babel 插件如何实现 JSX 到 JS 的编译？ 在 React 面试中，这个问题很容易被追问，也经常被要求手写。</p><p>它的实现原理是这样的。Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 <code>React.createElement</code> 的函数。如下代码所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>module.exports = function (babel) {
  var t = babel.types;
  return {
    name: &quot;custom-jsx-plugin&quot;,
    visitor: {
      JSXElement(path) {
        var openingElement = path.node.openingElement;
        var tagName = openingElement.name.name;
        var args = [];
        args.push(t.stringLiteral(tagName));
        var attribs = t.nullLiteral();
        args.push(attribs);
        var reactIdentifier = t.identifier(&quot;React&quot;); //object
        var createElementIdentifier = t.identifier(&quot;createElement&quot;);
        var callee = t.memberExpression(reactIdentifier, createElementIdentifier)
        var callExpression = t.callExpression(callee, args);
        callExpression.arguments = callExpression.arguments.concat(path.node.children);
        path.replaceWith(callExpression, path.node);
      },
    },
  };
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React.createElement源码分析</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 101. React的创建元素方法
 */
export function createElement(type, config, children) {
  // propName 变量用于储存后面需要用到的元素属性
  let propName;
  // props 变量用于储存元素属性的键值对集合
  const props = {};
  // key、ref、self、source 均为 React 元素的属性，此处不必深究
  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  // config 对象中存储的是元素的属性
  if (config != null) {
    // 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    // 此处将 key 值字符串化
    if (hasValidKey(config)) {
      key = &#39;&#39; + config.key;
    }
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面
    for (propName in config) {
      if (
        // 筛选出可以提进 props 对象里的属性
        hasOwnProperty.call(config, propName) &amp;&amp;
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        props[propName] = config[propName];
      }
    }
  }
  // childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度
  const childrenLength = arguments.length - 2;
  // 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了
  if (childrenLength === 1) {
    // 直接把这个参数的值赋给props.children
    props.children = children;
    // 处理嵌套多个子元素的情况
  } else if (childrenLength &gt; 1) {
    // 声明一个子元素数组
    const childArray = Array(childrenLength);
    // 把子元素推进数组里
    for (let i = 0; i &lt; childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    // 最后把这个数组赋值给props.children
    props.children = childArray;
  }

  // 处理 defaultProps
  if (type &amp;&amp; type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  // 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>入参解读：创造一个元素需要知道哪些信息</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>export function createElement(type, config, children)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>createElement 有 3 个入参，这 3 个入参囊括了 React 创建一个元素所需要知道的全部信息。</p><ul><li><code>type</code>：用于标识节点的类型。它可以是类似&quot;h1&quot;&quot;div&quot;这样的标准 HTML 标签字符串，也可以是 React 组件类型或 <code>React fragment</code> 类型。</li><li><code>config</code>：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。</li><li><code>children</code>：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的&quot;子节点&quot;&quot;子元素&quot;</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>React.createElement(&quot;ul&quot;, {
  // 传入属性键值对
  className: &quot;list&quot;
   // 从第三个入参开始往后，传入的参数都是 children
}, React.createElement(&quot;li&quot;, {
  key: &quot;1&quot;
}, &quot;1&quot;), React.createElement(&quot;li&quot;, {
  key: &quot;2&quot;
}, &quot;2&quot;));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个调用对应的 DOM 结构如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;ul className=&quot;list&quot;&gt;
  &lt;li key=&quot;1&quot;&gt;1&lt;/li&gt;
  &lt;li key=&quot;2&quot;&gt;2&lt;/li&gt;
&lt;/ul&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>createElement 函数体拆解</p><p><img src="/assets/20210426192237.77204471.png" alt=""></p><blockquote><p>createElement 中并没有十分复杂的涉及算法或真实 DOM 的逻辑，它的每一个步骤几乎都是在格式化数据。</p></blockquote><p><img src="/assets/20210426192648.da7b23a1.png" alt=""></p><blockquote><p>现在看来，<code>createElement</code> 原来只是个&quot;参数中介&quot;。此时我们的注意力自然而然地就聚焦在了 <code>ReactElement</code> 上</p></blockquote><p>出参解读：初识虚拟 DOM</p><blockquote><p><code>createElement</code> 执行到最后会 return 一个针对 ReactElement 的调用。这里关于 ReactElement，我依然先给出源码 + 注释形式的解析</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    // REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement
    $$typeof: REACT_ELEMENT_TYPE,

    // 内置属性赋值
    type: type,
    key: key,
    ref: ref,
    props: props,

    // 记录创造该元素的组件
    _owner: owner,
  };

  //
  if (__DEV__) {
    // 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听
  }

  return element;
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>ReactElement</code> 其实只做了一件事情，那就是&quot;创建&quot;，说得更精确一点，是&quot;组装&quot;：<code>ReactElement</code> 把传入的参数按照一定的规范，&quot;组装&quot;进了 <code>element</code> 对象里，并把它返回给了 <code>eact.createElement</code>，最终 <code>React.createElement</code> 又把它交回到了开发者手中</p></blockquote><p><img src="/assets/20210426193812.7d690f64.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const AppJSX = (&lt;div className=&quot;App&quot;&gt;
  &lt;h1 className=&quot;title&quot;&gt;I am the title&lt;/h1&gt;
  &lt;p className=&quot;content&quot;&gt;I am the content&lt;/p&gt;
&lt;/div&gt;)

console.log(AppJSX)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会发现它确实是一个标准的 <code>ReactElement</code> 对象实例</p><p><img src="/assets/20210426193901.1d933813.png" alt=""></p><p>这个 <code>ReactElement</code> 对象实例，本质上是以 JavaScript 对象形式存在的对 <code>DOM</code> 的描述，也就是老生常谈的&quot;虚拟 DOM&quot;（准确地说，是虚拟 <code>DOM</code> 中的一个节点)</p><h3 id="_14-为什么-react-元素有一个-typeof-属性" tabindex="-1"><a class="header-anchor" href="#_14-为什么-react-元素有一个-typeof-属性" aria-hidden="true">#</a> 14 为什么 React 元素有一个 $$typeof 属性</h3><p><img src="/assets/20212200213923.e19cf9db.png" alt=""></p><blockquote><p>目的是为了防止 XSS 攻击。因为 Synbol 无法被序列化，所以 React 可以通过有没有 $$typeof 属性来断出当前的 element 对象是从数据库来的还是自己生成的。</p></blockquote><ul><li>如果没有 $$typeof 这个属性，react 会拒绝处理该元素。</li><li>在 React 的古老版本中，下面的写法会出现 XSS 攻击：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 服务端允许用户存储 JSON
let expectedTextButGotJSON = {
  type: &#39;div&#39;,
  props: {
    dangerouslySetInnerHTML: {
      __html: &#39;/* 把你想的搁着 */&#39;
    },
  },
  // ...
};
let message = { text: expectedTextButGotJSON };

// React 0.13 中有风险
&lt;p&gt;
  {message.text}
&lt;/p&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_15-virtual-dom-的工作原理是什么" tabindex="-1"><a class="header-anchor" href="#_15-virtual-dom-的工作原理是什么" aria-hidden="true">#</a> 15 Virtual DOM 的工作原理是什么</h3><p><img src="/assets/20210425201821.97ce0b81.png" alt=""></p><ul><li>虚拟 DOM 的工作原理是<code>通过 JS 对象模拟 DOM 的节点</code>。在 Facebook 构建 React 初期时，考虑到要提升代码抽象能力、避免人为的 DOM 操作、降低代码整体风险等因素，所以引入了虚拟 DOM</li><li>虚拟 DOM 在实现上通常是 <code>Plain Object</code>，以 React 为例，在 <code>render</code> 函数中写的 <code>JSX</code> 会在 <code>Babel</code> 插件的作用下，编译为 <code>React.createElement</code> 执行 <code>JSX</code> 中的属性参数</li><li><code>React.createElement</code> 执行后会返回一个 <code>Plain Object</code>，它会描述自己的 <code>tag</code> 类型、<code>props</code> 属性以及 <code>children</code> 情况等。这些 <code>Plain Object</code> 通过树形结构组成一棵虚拟 <code>DOM</code> 树。当状态发生变更时，将变更前后的虚拟 <code>DOM</code> 树进行差异比较，这个过程称为 <code>diff</code>，生成的结果称为 <code>patch</code>。计算之后，会渲染 <code>Patch</code> 完成对真实 <code>DOM</code> 的操作。</li><li>虚拟 DOM 的优点主要有三点：<code>改善大规模</code>DOM<code>操作的性能</code>、<code>规避 XSS 风险</code>、<code>能以较低的成本实现跨平台开发</code>。</li><li>虚拟 DOM 的缺点在社区中主要有两点 <ul><li>内存占用较高，因为需要模拟整个网页的真实 <code>DOM</code></li><li>高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React</li></ul></li></ul><p>除了渲染页面，虚拟 DOM 还有哪些应用场景？</p><blockquote><p>这个问题考验面试者的想象力。通常而言，我们只是将虚拟 DOM 与渲染绑定在一起，但实际上虚拟 DOM 的应用更为广阔。比如，只要你记录了真实 DOM 变更，它甚至可以应用于埋点统计与数据记录等。</p></blockquote><p>SSR原理</p><blockquote><p>借助虚拟dom,服务器中没有dom概念的，react巧妙的借助虚拟dom，然后可以在服务器中nodejs可以运行起来react代码。</p></blockquote><h3 id="_16-react有哪些优化性能的手段" tabindex="-1"><a class="header-anchor" href="#_16-react有哪些优化性能的手段" aria-hidden="true">#</a> 16 React有哪些优化性能的手段</h3><p>类组件中的优化手段</p><ul><li>使用纯组件 <code>PureComponent</code> 作为基类。</li><li>使用 <code>shouldComponentUpdate</code> 生命周期函数来自定义渲染逻辑。</li></ul><p>方法组件中的优化手段</p><ul><li>使用 <code>React.memo</code> 高阶函数包装组件，<code>React.memo</code> 可以实现类似于 <code>shouldComponentUpdate</code> 或者 <code>PureComponent</code> 的效果</li><li>使用 <code>useMemo</code><ul><li>使用<code>React.useMemo</code>精细化的管控，<code>useMemo 控制的则是是否需要重复执行某一段逻辑</code>，而<code>React.memo 控制是否需要重渲染一个组件</code></li></ul></li><li>使用 <code>useCallBack</code>。</li></ul><p>其他方式</p><ul><li>在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。</li><li>必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。</li><li>使用 <code>Suspense</code> 和 lazy 进行懒加载，例如：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import React, { lazy, Suspense } from &quot;react&quot;;

export default class CallingLazyComponents extends React.Component {
  render() {
    var ComponentToLazyLoad = null;

    if (this.props.name == &quot;Mayank&quot;) {
      ComponentToLazyLoad = lazy(() =&gt; import(&quot;./mayankComponent&quot;));
    } else if (this.props.name == &quot;Anshul&quot;) {
      ComponentToLazyLoad = lazy(() =&gt; import(&quot;./anshulComponent&quot;));
    }

    return (
      &lt;div&gt;
        &lt;h1&gt;This is the Base User: {this.state.name}&lt;/h1&gt;
        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
          &lt;ComponentToLazyLoad /&gt;
        &lt;/Suspense&gt;
      &lt;/div&gt;
    )
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_17-redux实现原理解析" tabindex="-1"><a class="header-anchor" href="#_17-redux实现原理解析" aria-hidden="true">#</a> 17 Redux实现原理解析</h3><blockquote><p><code>在 Redux 的整个工作过程中，数据流是严格单向的</code>。这一点一定一定要背下来，面试的时候也一定一定要记得说</p></blockquote><p>为什么要用redux</p><blockquote><p>在<code>React</code>中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过<code>props</code>）,所以，两个非父子组件之间通信就相对麻烦，<code>redux</code>的出现就是为了解决<code>state</code>里面的数据问题</p></blockquote><p>Redux设计理念</p><blockquote><p><code>Redux</code>是将整个应用状态存储到一个地方上称为<code>store</code>,里面保存着一个状态树<code>store tree</code>,组件可以派发(<code>dispatch</code>)行为(<code>action</code>)给<code>store</code>,而不是直接通知其他组件，组件内部通过订阅<code>store</code>中的状态<code>state</code>来刷新自己的视图</p></blockquote><p><img src="/assets/20220307225368.d9cc4b4f.png" alt=""></p><blockquote><p>如果你想对数据进行修改，<code>只有一种途径：派发 action</code>。action 会被 reducer 读取，进而根据 action 内容的不同对数据进行修改、生成新的 state（状态），这个新的 state 会更新到 store 对象里，进而驱动视图层面做出对应的改变。</p></blockquote><p>Redux三大原则</p><ul><li>唯一数据源</li></ul><blockquote><p>整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中</p></blockquote><ul><li>保持只读状态</li></ul><blockquote><p><code>state</code>是只读的，唯一改变<code>state</code>的方法就是触发<code>action</code>，<code>action</code>是一个用于描述以发生时间的普通对象</p></blockquote><ul><li>数据改变只能通过纯函数来执行</li></ul><blockquote><p>使用纯函数来执行修改，为了描述<code>action</code>如何改变<code>state</code>的，你需要编写<code>reducers</code></p></blockquote><p>从编码的角度理解 Redux 工作流</p><ol><li>使用 <code>createStore 来完成 store 对象的创建</code></li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 引入 redux
import { createStore } from &#39;redux&#39;
// 创建 store
const store = createStore(
    reducer,
    initial_state,
    applyMiddleware(middleware1, middleware2, ...)
);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>createStore 方法是一切的开始，它接收三个入参：</p><ul><li>reducer；</li><li>初始状态内容；</li><li>指定中间件</li></ul><ol><li><code>reducer 的作用是将新的 state 返回给 store</code></li></ol><p>一个 reducer 一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个 state：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const reducer = (state, action) =&gt; {
    // 此处是各种样的 state处理逻辑
    return new_state
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们基于某个 reducer 去创建 store 的时候，其实就是给这个 store 指定了一套更新规则：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 更新规则全都写在 reducer 里
const store = createStore(reducer)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>action 的作用是通知 reducer &quot;让改变发生&quot;</li></ol><blockquote><p>要想让 state 发生改变，就必须用正确的 action 来驱动这个改变。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const action = {
  type: &quot;ADD_ITEM&quot;,
  payload: &#39;&lt;li&gt;text&lt;/li&gt;&#39;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>action 对象中允许传入的属性有多个，但只有 type 是必传的。type 是 action 的唯一标识，reducer 正是通过不同的 type 来识别出需要更新的不同的 state，由此才能够实现精准的&quot;定向更新&quot;。</p></blockquote><ol><li>派发 action，靠的是 dispatch</li></ol><p>action 本身只是一个对象，要想让 reducer 感知到 action，还需要&quot;派发 action&quot;这个动作，<code>这个动作是由 store.dispatch 完成的</code>。这里我简单地示范一下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { createStore } from &#39;redux&#39;
// 创建 reducer
const reducer = (state, action) =&gt; {
    // 此处是各种样的 state处理逻辑
    return new_state
}
// 基于 reducer 创建 state
const store = createStore(reducer)
// 创建一个 action，这个 action 用 &quot;ADD_ITEM&quot; 来标识
const action = {
  type: &quot;ADD_ITEM&quot;,
  payload: &#39;&lt;li&gt;text&lt;/li&gt;&#39;
}
// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新
store.dispatch(action)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这段代码，是从编码角度对 Redux 主要工作流的概括，这里我同样为你总结了一张对应的流程图：</p><p><img src="/assets/20210426215948.bc421815.png" alt=""></p><p>Redux源码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let createStore = (reducer) =&gt; {
    let state;
    //获取状态对象
    //存放所有的监听函数
    let listeners = [];
    let getState = () =&gt; state;
    //提供一个方法供外部调用派发action
    let dispath = (action) =&gt; {
        //调用管理员reducer得到新的state
        state = reducer(state, action);
        //执行所有的监听函数
        listeners.forEach((l) =&gt; l())
    }
    //订阅状态变化事件，当状态改变发生之后执行监听函数
    let subscribe = (listener) =&gt; {
        listeners.push(listener);
    }
    dispath();
    return {
        getState,
        dispath,
        subscribe
    }
}
let combineReducers=(renducers)=&gt;{
    //传入一个renducers管理组，返回的是一个renducer
    return function(state={},action={}){
        let newState={};
        for(var attr in renducers){
            newState[attr]=renducers[attr](state[attr],action)

        }
        return newState;
    }
}
export {createStore,combineReducers};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>聊聊 Redux 和 Vuex 的设计思想</p><ul><li>共同点</li></ul><blockquote><p>首先两者都是处理全局状态的工具库，大致实现思想都是：全局<code>state</code>保存状态----&gt;<code>dispatch(action)</code>------&gt;<code>reducer</code>(<code>vuex</code>里的<code>mutation</code>)----&gt; 生成<code>newState</code>; 整个状态为同步操作；</p></blockquote><ul><li>区别</li></ul><blockquote><p>最大的区别在于处理异步的不同，vuex里面多了一步<code>commit</code>操作，在<code>action</code>之后<code>commit(mutation)</code>之前处理异步，而<code>redux</code>里面则是通过中间件处理</p></blockquote><p>redux 中间件</p><blockquote><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过 滤，日志输出，异常报告等功能</p></blockquote><p>常见的中间件:</p><ul><li><code>redux-logger</code>:提供日志输出;</li><li><code>redux-thunk</code>:处理异步操作;</li><li><code>redux-promise</code>: 处理异步操作;</li><li><code>actionCreator</code> 的返回值是 <code>promise</code></li></ul><p>redux中间件的原理是什么</p><p><code>applyMiddleware</code></p><p>为什么会出现中间件？</p><ul><li>它只是一个用来加工dispatch的工厂，而要加工什么样的dispatch出来，则需要我们传入对应的中间件函数</li><li>让每一个中间件函数，接收一个dispatch，然后返回一个改造后的dispatch，来作为下一个中间件函数的next，以此类推。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function applyMiddleware(middlewares) {
  middlewares = middlewares.slice()
  middlewares.reverse()

  let dispatch = store.dispatch
  middlewares.forEach(middleware =&gt;
    dispatch = middleware(store)(dispatch)
  )
  return Object.assign({}, store, { dispatch })
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>上面的<code>middleware(store)(dispatch)</code> 就相当于是 <code>const logger = store =&gt; next =&gt; {}</code>，这就是构造后的dispatch，继续向下传递。这里<code>middlewares.reverse()</code>，进行数组反转的原因，是最后构造的<code>dispatch</code>，实际上是最先执行的。因为在<code>applyMiddleware</code>串联的时候，每个中间件只是返回一个新的<code>dispatch</code>函数给下一个中间件，实际上这个<code>dispatch</code>并不会执行。只有当我们在程序中通过<code>store.dispatch(action)</code>，真正派发的时候，才会执行。而此时的<code>dispatch</code>是最后一个中间件返回的包装函数。然后依次向前递推执行。</p></blockquote><p><a href="http://interview.poetries.top/principle-docs/react/08-%E6%B5%85%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6.html" target="_blank" rel="noopener noreferrer">浅析中间件(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>action、store、reducer分析</p><blockquote><p>redux的核心概念就是store、action、reducer，从调用关系来看如下所示</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>store.dispatch(action) --&gt; reducer(state, action) --&gt; final state

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// reducer方法, 传入的参数有两个
// state: 当前的state
// action: 当前触发的行为, {type: &#39;xx&#39;}
// 返回值: 新的state
var reducer = function(state, action){
    switch (action.type) {
        case &#39;add_todo&#39;:
            return state.concat(action.text);
        default:
            return state;
    }
};

// 创建store, 传入两个参数
// 参数1: reducer 用来修改state
// 参数2(可选): [], 默认的state值,如果不传, 则为undefined
var store = redux.createStore(reducer, []);

// 通过 store.getState() 可以获取当前store的状态(state)
// 默认的值是 createStore 传入的第二个参数
console.log(&#39;state is: &#39; + store.getState());  // state is:

// 通过 store.dispatch(action) 来达到修改 state 的目的
// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)
store.dispatch({type: &#39;add_todo&#39;, text: &#39;读书&#39;});
// 打印出修改后的state
console.log(&#39;state is: &#39; + store.getState());  // state is: 读书

store.dispatch({type: &#39;add_todo&#39;, text: &#39;写作&#39;});
console.log(&#39;state is: &#39; + store.getState());  // state is: 读书,写作

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>store、reducer、action关联</li></ol><p>store</p><ul><li><code>store</code>在这里代表的是数据模型，内部维护了一个<code>state</code>变量</li><li><code>store</code>有两个核心方法，分别是<code>getState</code>、<code>dispatch</code>。前者用来获取<code>store</code>的状态（<code>state</code>），后者用来修改<code>store</code>的状态</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 创建store, 传入两个参数
// 参数1: reducer 用来修改state
// 参数2(可选): [], 默认的state值,如果不传, 则为undefined
var store = redux.createStore(reducer, []);

// 通过 store.getState() 可以获取当前store的状态(state)
// 默认的值是 createStore 传入的第二个参数
console.log(&#39;state is: &#39; + store.getState());  // state is:

// 通过 store.dispatch(action) 来达到修改 state 的目的
// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)
store.dispatch({type: &#39;add_todo&#39;, text: &#39;读书&#39;});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>action</p><ul><li>对行为（如用户行为）的抽象，在<code>redux</code>里是一个普通的<code>js</code>对象</li><li><code>action</code>必须有一个<code>type</code>字段来标识这个行为的类型</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{type:&#39;add_todo&#39;, text:&#39;读书&#39;}
{type:&#39;add_todo&#39;, text:&#39;写作&#39;}
{type:&#39;add_todo&#39;, text:&#39;睡觉&#39;, time:&#39;晚上&#39;}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>reducer</p><ul><li>一个普通的函数，用来修改<code>store</code>的状态。传入两个参数 <code>state</code>、<code>action</code></li><li>其中，<code>state</code>为当前的状态（可通过<code>store.getState()</code>获得），而<code>action</code>为当前触发的行为（通过<code>store.dispatch(action)</code>调用触发）</li><li><code>reducer(state, action)</code> 返回的值，就是<code>store</code>最新的<code>state</code>值</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// reducer方法, 传入的参数有两个
// state: 当前的state
// action: 当前触发的行为, {type: &#39;xx&#39;}
// 返回值: 新的state
var reducer = function(state, action){
    switch (action.type) {
        case &#39;add_todo&#39;:
            return state.concat(action.text);
        default:
            return state;
    }
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>关于<code>actionCreator</code></li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>actionCreator(args) =&gt; action

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var addTodo = function(text){
    return {
        type: &#39;add_todo&#39;,
        text: text
    };
};

addTodo(&#39;睡觉&#39;);  // 返回：{type: &#39;add_todo&#39;, text: &#39;睡觉&#39;}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异步Action及操作</p><ol><li>创建同步Action</li></ol><blockquote><p><code>Action</code>是数据从应用传递到 <code>store</code>/<code>state</code> 的载体，也是开启一次完成数据流的开始</p></blockquote><p>普通的action对象</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const action = {
	type:&#39;ADD_TODO&#39;,
	name:&#39;poetries&#39;
}

dispatch(action)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>封装action creator</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function actionCreator(data){
    return {
    	type:&#39;ADD_TODO&#39;,
    	data:data
    }
}

dispatch(actionCreator(&#39;poetries&#39;))

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bindActionCreators合并</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function a(name,id){
	reurn {
		type:&#39;a&#39;,
		name,
		id
	}
}
function b(name,id){
	reurn {
		type:&#39;b&#39;,
		name,
		id
	}
}

let actions = Redux.bindActionCreators({a,b},store.dispatch)

//调用
actions.a(&#39;poetries&#39;,&#39;id001&#39;)
actions.b(&#39;jing&#39;,&#39;id002&#39;)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>action创建的标准</p><blockquote><p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件</p></blockquote><ul><li>是一个纯文本对象</li><li>只具备 <code>type</code> 、<code>payload</code>、<code>error</code> 和 <code>meta</code>中的一个或者多个属性。<code>type</code> 字段不可缺省，其它字段可缺省</li><li>若 <code>Action</code> 报错，<code>error</code> 字段不可缺省，切必须为 <code>true</code></li></ul><blockquote><p><code>payload</code> 是一个对象，用作Action携带数据的载体</p></blockquote><p>标准action示例</p><ul><li>A basic Flux Standard Action:</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{
  type: &#39;ADD_TODO&#39;,
  payload: {
    text: &#39;Do something.&#39;
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>An FSA that represents an error, analogous to a rejected Promise</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{
  type: &#39;ADD_TODO&#39;,
  payload: new Error(),
  error: true
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>https://github.com/acdlite/flux-standard-action</p></blockquote><ul><li>可以采用如下一个简单的方式检验一个<code>Action</code>是否符合FSA标准</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// every有一个匹配不到返回false
let isFSA = Object.keys(action).every((item)=&gt;{
   return  [&#39;payload&#39;,&#39;type&#39;,&#39;error&#39;,&#39;meta&#39;].indexOf(item) &gt;  -1
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>创建异步action的多种方式</li></ol><blockquote><p>最简单的方式就是使用同步的方式来异步，将原来同步时一个<code>action</code>拆分成多个异步的<code>action</code>的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有<code>redux-saga</code>等插件来解决这些问题了</p></blockquote><p>异步action的实现方式一：setTimeout</p><blockquote><p><code>redux-thunk</code>中间处理解析</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function thunkAction(data) {
    reutrn (dispatch)=&gt;{
        setTimeout(function(){
            dispatch({
                type:&#39;ADD_TODO&#39;,
                data
            })
        },3000)
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异步action的实现方式二：promise实现异步action</p><blockquote><p><code>redux-promise</code>中间处理这种<code>action</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function promiseAction(name){
    return new Promise((resolve,reject) =&gt; {
        setTimeout((param)=&gt;{
            resolve({
                type:&#39;ADD_TODO&#39;,
                name
            })
        },3000)
    }).then((param)=&gt;{
        dispatch(action(&quot;action2&quot;))
        return;
    }).then((param)=&gt;{
        dispatch(action(&quot;action3&quot;))
    })
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>redux异步流程</li></ol><p><img src="/assets/20210427115241.d559561c.png" alt=""></p><ul><li>首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样<code>dispatch</code>的返回值才能是一个函数。</li><li>通过<code>store.dispatch</code>，将状态的的改变传给<code>store</code>的小弟<code>reducer</code>，<code>reducer</code>根据<code>action</code>的改变，传递新的状态<code>state</code>。</li><li>最后将所有的改变告诉给它的大哥，<code>store</code>。<code>store</code>保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了</li></ul><ol><li>Redux异步方案选型</li></ol><p>redux-thunk</p><blockquote><p><code>Redux</code>本身只能处理同步的<code>Action</code>，但可以通过中间件来拦截处理其它类型的<code>action</code>，比如函数(<code>Thunk</code>)，再用回调触发普通<code>Action</code>，从而实现异步处理</p></blockquote><ul><li>发送异步的<code>action</code>其实是被中间件捕获的，函数类型的action就被<code>middleware</code>捕获。至于怎么定义异步的<code>action</code>要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析<code>action</code></li></ul><blockquote><p><code>Redux</code> 本身不处理异步行为，需要依赖中间件。结合 <code>redux-actions</code> 使用，<code>Redux</code> 有两个推荐的异步中间件</p></blockquote><ul><li><code>redux-thunk</code></li><li><code>redux-promise</code></li></ul><blockquote><p><code>redux-thunk</code> 的源码如下</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
    if (typeof action === &#39;function&#39;) {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>源码可知，<code>action creator</code> 需要返回一个函数给 <code>redux-thunk</code> 进行调用，示例如下</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;{
    //请求之前的一些处理

    let value = await Promise.resolve(val + &#39; thunk&#39;);
    dispatch({
        type:CONSTANT.ADD_TO_DO_THUNK,
        payload:{
            value
        }
    });
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>而它使用起来最大的问题，就是重复的模板代码太多</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//action types
const GET_DATA = &#39;GET_DATA&#39;,
    GET_DATA_SUCCESS = &#39;GET_DATA_SUCCESS&#39;,
    GET_DATA_FAILED = &#39;GET_DATA_FAILED&#39;;

//action creator
const getDataAction = (id) =&gt; (dispatch, getState) =&gt; {
        dispatch({
            type: GET_DATA,
            payload: id
        })
        api.getData(id) //注：本文所有示例的api.getData都返回promise对象
            .then(response =&gt; {
                dispatch({
                    type: GET_DATA_SUCCESS,
                    payload: response
                })
            })
            .catch(error =&gt; {
                dispatch({
                    type: GET_DATA_FAILED,
                    payload: error
                })
            })
    }
}

//reducer
const reducer = (oldState, action) =&gt; {
    switch(action.type) {
    case GET_DATA :
        return oldState;
    case GET_DATA_SUCCESS :
        return successState;
    case GET_DATA_FAILED :
        return errorState;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍</p></blockquote><ul><li>另一方面，像<code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>这样的字符串声明也非常无趣且易错 上例中，<code>GET_DATA</code>这个<code>action</code>并不是多数场景需要的</li></ul><p>redux-promise</p><blockquote><p>由于<code>redux-thunk</code>写起来实在是太麻烦了，社区当然会有其它轮子出现。<code>redux-promise</code>则是其中比较知名的</p></blockquote><ul><li>它自定义了一个<code>middleware</code>，当检测到有<code>action</code>的<code>payload</code>属性是<code>Promise</code>对象时，就会 <ul><li>若<code>resolve</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>value</code>，并设<code>status</code>属性为<code>&quot;success&quot;</code></li><li>若<code>reject</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>reason</code>，并设<code>status</code>属性为<code>&quot;error&quot;</code></li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//action types
const GET_DATA = &#39;GET_DATA&#39;;

//action creator
const getData = function(id) {
    return {
        type: GET_DATA,
        payload: api.getData(id) //payload为promise对象
    }
}

//reducer
function reducer(oldState, action) {
    switch(action.type) {
        case GET_DATA:
            if (action.status === &#39;success&#39;) {
                return successState
            } else {
                   return errorState
            }
        }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>redux-promise</code>为了精简而做出的妥协非常明显：无法处理乐观更新</p></blockquote><p>场景解析之：乐观更新</p><blockquote><p>多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据</p></blockquote><ul><li>由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作</li><li>在上面<code>redux-thunk</code>的例子中，我们看到了<code>GET_DATA</code>, <code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>三个<code>action</code>，分别表示初始动作、异步成功和异步失败，其中第一个<code>action</code>使得<code>redux-thunk</code>具备乐观更新的能力</li><li>而在<code>redux-promise</code>中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，<code>redux</code>认可的<code>action</code>对象是 <code>plain JavaScript objects</code>，即简单对象，而在<code>redux-promise</code>中，初始<code>action</code>的<code>payload</code>是个<code>Promise</code></li></ul><p>redux-promise-middleware</p><blockquote><p><code>redux-promise-middleware</code>相比<code>redux-promise</code>，采取了更为温和和渐进式的思路，保留了和<code>redux-thunk</code>类似的三个<code>action</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//action types
const GET_DATA = &#39;GET_DATA&#39;,
    GET_DATA_PENDING = &#39;GET_DATA_PENDING&#39;,
    GET_DATA_FULFILLED = &#39;GET_DATA_FULFILLED&#39;,
    GET_DATA_REJECTED = &#39;GET_DATA_REJECTED&#39;;

//action creator
const getData = function(id) {
    return {
        type: GET_DATA,
        payload: {
            promise: api.getData(id),
            data: id
        }
    }
}

//reducer
const reducer = function(oldState, action) {
    switch(action.type) {
    case GET_DATA_PENDING :
        return oldState; // 可通过action.payload.data获取id
    case GET_DATA_FULFILLED :
        return successState;
    case GET_DATA_REJECTED :
        return errorState;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>redux异步操作代码演示</li></ol><ul><li>根据官网的async例子分析 https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</li></ul><p>action/index.js</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import fetch from &#39;isomorphic-fetch&#39;
export const RECEIVE_POSTS = &#39;RECEIVE_POSTS&#39;

//获取新闻成功的action
function receivePosts(reddit, json) {
  return {
    type: RECEIVE_POSTS,
    reddit: reddit,
    posts: json.data.children.map(child =&gt;child.data)
  }
}

function fetchPosts(subreddit) {

  return function (dispatch) {

    return fetch(`http://www.subreddit.com/r/${subreddit}.json`)
      .then(response =&gt; response.json())
      .then(json =&gt;
        dispatch(receivePosts(subreddit, json))
      )
  }
}

//如果需要则开始获取文章
export function fetchPostsIfNeeded(subreddit) {

  return (dispatch, getState) =&gt; {

      return dispatch(fetchPosts(subreddit))

    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>fetchPostsIfNeeded</code>这里就是一个中间件。<code>redux-thunk</code>会拦截<code>fetchPostsIfNeeded</code>这个<code>action</code>，会先发起数据请求，如果成功，就将数据传给<code>action</code>从而到达<code>reducer</code>那里</p></blockquote><p>reducers/index.js</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { combineReducers } from &#39;redux&#39;
import {
  RECEIVE_POSTS
} from &#39;../actions&#39;

function posts(state = {
  items: []
}, action) {
  switch (action.type) {

    case RECEIVE_POSTS:
      // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里
      //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
      return Object.assign({}, state, {
        items: action.posts //数据都存在了这里
      })
    default:
      return state
  }
}

// 将所有的reducer结合为一个,传给store
const rootReducer = combineReducers({
  postsByReddit
})

export default rootReducer

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这个跟正常的<code>reducer</code>差不多。判断<code>action</code>的类型，从而根据<code>action</code>的不同类型，返回不同的数据。这里将数据存储在了<code>items</code>这里。这里的<code>reducer</code>只有一个。最后结合成<code>rootReducer</code>,传给<code>store</code></p></blockquote><p>store/configureStore.js</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { createStore, applyMiddleware } from &#39;redux&#39;
import thunkMiddleware from &#39;redux-thunk&#39;
import createLogger from &#39;redux-logger&#39;
import rootReducer from &#39;../reducers&#39;

const createStoreWithMiddleware = applyMiddleware(
  thunkMiddleware,
  createLogger()
)(createStore)

export default function configureStore(initialState) {
  const store = createStoreWithMiddleware(rootReducer, initialState)

  if (module.hot) {
    // Enable Webpack hot module replacement for reducers
    module.hot.accept(&#39;../reducers&#39;, () =&gt; {
      const nextRootReducer = require(&#39;../reducers&#39;)
      store.replaceReducer(nextRootReducer)
    })
  }

  return store
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们是如何在 <code>dispatch</code> 机制中引入 <code>Redux Thunk middleware</code> 的呢？ 我们使用了<code>applyMiddleware()</code></li><li>通过使用指定的 <code>middleware</code>，<code>action creator</code> 除了返回 <code>action</code> 对象外还可以返回函数</li><li>这时，这个 <code>action creator</code> 就成为了 <code>thunk</code></li></ul><p>界面上的调用：在containers/App.js</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//初始化渲染后触发
  componentDidMount() {
    const { dispatch} = this.props
    // 这里可以传两个值，一个是 reactjs 一个是 frontend
    dispatch(fetchPostsIfNeeded(&#39;frontend&#39;))
  }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>改变状态的时候也是需要通过<code>dispatch</code>来传递的</p></blockquote><ul><li>数据的获取是通过<code>provider</code>,将<code>store</code>里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import &#39;babel-core/polyfill&#39;
import React from &#39;react&#39;
import { render } from &#39;react-dom&#39;
import { Provider } from &#39;react-redux&#39;
import App from &#39;./containers/App&#39;
import configureStore from &#39;./store/configureStore&#39;
const store = configureStore()
render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&#39;root&#39;)
)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这样就完成了<code>redux</code>的异步操作。其实最主要的区别还是<code>action</code>里面还有中间件的调用，其他的地方基本跟同步的<code>redux</code>差不多的。搞懂了中间件，就基本搞懂了<code>redux</code>的异步操作</p></blockquote><p><img src="/assets/20210427115322.5c55ac55.png" alt=""></p><h3 id="_18-谈谈你对状态管理的理解" tabindex="-1"><a class="header-anchor" href="#_18-谈谈你对状态管理的理解" aria-hidden="true">#</a> 18 谈谈你对状态管理的理解</h3><ul><li>首先介绍 Flux，Flux 是一种使用单向数据流的形式来组合 React 组件的应用架构。</li><li>Flux 包含了 4 个部分，分别是 <code>Dispatcher</code>、 <code>Store</code>、<code>View</code>、<code>Action</code>。<code>Store</code> 存储了视图层所有的数据，当 <code>Store</code> 变化后会引起 View 层的更新。如果在视图层触发一个 <code>Action</code>，就会使当前的页面数据值发生变化。Action 会被 Dispatcher 进行统一的收发处理，传递给 Store 层，Store 层已经注册过相关 Action 的处理逻辑，处理对应的内部状态变化后，触发 View 层更新。</li><li><code>Flux 的优点是单向数据流，解决了 MVC 中数据流向不清的问题</code>，使开发者可以快速了解应用行为。从项目结构上简化了视图层设计，明确了分工，数据与业务逻辑也统一存放管理，使在大型架构的项目中更容易管理、维护代码。</li><li><code>其次是 Redux</code>，Redux 本身是一个 JavaScript 状态容器，提供可预测化状态的管理。社区通常认为 Redux 是 Flux 的一个简化设计版本，它提供的状态管理，简化了一些高级特性的实现成本，比如撤销、重做、实时编辑、时间旅行、服务端同构等。</li><li>Redux 的核心设计包含了三大原则：<code>单一数据源、纯函数 Reducer、State 是只读的</code>。</li><li>Redux 中整个数据流的方案与 Flux 大同小异</li><li>Redux 中的另一大核心点是处理&quot;副作用&quot;，AJAX 请求等异步工作，或不是纯函数产生的第三方的交互都被认为是 &quot;副作用&quot;。这就造成在纯函数设计的 Redux 中，处理副作用变成了一件至关重要的事情。社区通常有两种解决方案： <ul><li>第一类是在 <code>Dispatch</code> 的时候会有一个 <code>middleware 中间件层</code>，拦截分发的 <code>Action 并添加额外的复杂行为</code>，还可以添加副作用。第一类方案的流行框架有 <code>Redux-thunk、Redux-Promise、Redux-Observable、Redux-Saga</code> 等。</li><li>第二类是允许 <code>Reducer</code> 层中直接处理副作用，采取该方案的有 <code>React Loop</code>，<code>React Loop</code> 在实现中采用了 Elm 中分形的思想，使代码具备更强的组合能力。</li><li>除此以外，社区还提供了更为工程化的方案，比如 <code>rematch 或 dva</code>，提供了更详细的模块架构能力，提供了拓展插件以支持更多功能。</li></ul></li><li>Redux 的优点很多： <ul><li>结果可预测；</li><li>代码结构严格易维护；</li><li>模块分离清晰且小函数结构容易编写单元测试；</li><li><code>Action</code> 触发的方式，可以在调试器中使用时间回溯，定位问题更简单快捷；</li><li>单一数据源使服务端同构变得更为容易；社区方案多，生态也更为繁荣。</li></ul></li><li><code>最后是 Mobx</code>，Mobx 通过监听数据的属性变化，可以直接在数据上更改触发UI 的渲染。在使用上更接近 Vue，比起 <code>Flux 与 Redux</code> 的手动挡的体验，更像开自动挡的汽车。<code>Mobx 的响应式实现原理与 Vue 相同</code>，以 <code>Mobx 5</code> 为分界点，5 以前采用 <code>Object.defineProperty</code> 的方案，5 及以后使用 <code>Proxy</code> 的方案。<code>它的优点是样板代码少、简单粗暴、用户学习快、响应式自动更新数据</code>让开发者的心智负担更低。</li><li>Mobx 在开发项目时简单快速，但应用 Mobx 的场景 ，其实完全可以用 Vue 取代。如果纯用 Vue，体积还会更小巧</li></ul><p><img src="/assets/20210425201200.f04c6c43.png" alt=""></p><h3 id="_19-connect组件原理分析" tabindex="-1"><a class="header-anchor" href="#_19-connect组件原理分析" aria-hidden="true">#</a> 19 connect组件原理分析</h3><p>1. connect用法</p><blockquote><p>作用：连接<code>React</code>组件与 <code>Redux store</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])
// 这个函数允许我们将 store 中的数据作为 props 绑定到组件上
const mapStateToProps = (state) =&gt; {
  return {
    count: state.count
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个函数的第一个参数就是 <code>Redux</code> 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性</li><li>函数的第二个参数 <code>ownProps</code>，是组件自己的 <code>props</code></li></ul><blockquote><p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps merge</code> 后）更新给组件</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>mapDispatchToProps(dispatch, ownProps): dispatchProps

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 <code>action</code> 作为 <code>props</code>绑定到组件上，也会成为 <code>MyComp</code> 的 `props</p></blockquote><p>2. 原理解析</p><blockquote><p>首先<code>connect</code>之所以会成功，是因为<code>Provider</code>组件</p></blockquote><ul><li>在原应用组件上包裹一层，使原来整个应用成为<code>Provider</code>的子组件</li><li>接收<code>Redux</code>的<code>store</code>作为<code>props</code>，通过<code>context</code>对象传递给子孙组件上的<code>connect</code></li></ul><p>connect做了些什么</p><blockquote><p>它真正连接 <code>Redux</code> 和 <code>React</code>，它包在我们的容器组件的外一层，它接收上面 <code>Provider</code>提供的 <code>store</code> 里面的 <code>state</code>和 <code>dispatch</code>，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件</p></blockquote><p>3. 源码</p><blockquote><p><code>connect</code>是一个高阶函数，首先传入<code>mapStateToProps</code>、<code>mapDispatchToProps</code>，然后返回一个生产<code>Component</code>的函数(<code>wrapWithConnect</code>)，然后再将真正的<code>Component</code>作为参数传入<code>wrapWithConnect</code>，这样就生产出一个经过包裹的<code>Connect</code>组件，该组件具有如下特点</p></blockquote><ul><li>通过<code>props.store</code>获取祖先<code>Component</code>的<code>store props</code>包括<code>stateProps</code>、<code>dispatchProps</code>、<code>parentProps</code>,合并在一起得到<code>nextState</code>，作为<code>props</code>传给真正的<code>Component</code></li><li><code>componentDidMount</code>时，添加事件<code>this.store.subscribe(this.handleChange)</code>，实现页面交互</li><li><code>shouldComponentUpdate</code>时判断是否有避免进行渲染，提升页面性能，并得到<code>nextState</code></li><li><code>componentWillUnmount</code>时移除注册的事件<code>this.handleChange</code></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 主要逻辑

export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {
  return function wrapWithConnect(WrappedComponent) {
    class Connect extends Component {
      constructor(props, context) {
        // 从祖先Component处获得store
        this.store = props.store || context.store
        this.stateProps = computeStateProps(this.store, props)
        this.dispatchProps = computeDispatchProps(this.store, props)
        this.state = { storeState: null }
        // 对stateProps、dispatchProps、parentProps进行合并
        this.updateState()
      }
      shouldComponentUpdate(nextProps, nextState) {
        // 进行判断，当数据发生改变时，Component重新渲染
        if (propsChanged || mapStateProducedChange || dispatchPropsChanged) {
          this.updateState(nextProps)
            return true
          }
        }
        componentDidMount() {
          // 改变Component的state
          this.store.subscribe(() = {
            this.setState({
              storeState: this.store.getState()
            })
          })
        }
        render() {
          // 生成包裹组件Connect
          return (
            &lt;WrappedComponent {...this.nextState} /&gt;
          )
        }
      }
      Connect.contextTypes = {
        store: storeShape
      }
      return Connect;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_20-react-hooks" tabindex="-1"><a class="header-anchor" href="#_20-react-hooks" aria-hidden="true">#</a> 20 React Hooks</h3><ul><li>代码逻辑聚合，逻辑复用</li><li>HOC嵌套地狱</li><li>代替class</li></ul><blockquote><p>React 中通常使用 类定义 或者 函数定义 创建组件:</p></blockquote><p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p><p>函数组件与类组件的对比：无关&quot;优劣&quot;，只谈&quot;不同&quot;</p><ul><li>类组件需要继承 class，函数组件不需要；</li><li>类组件可以访问生命周期方法，函数组件不能；</li><li>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</li><li>类组件中可以定义并维护 state（状态），而函数组件不可以；</li></ul><blockquote><p>但是类组件它太重了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的</p></blockquote><p>react hooks的好处:</p><ol><li>跨组件复用: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</li><li>类定义更为复杂</li></ol><ul><li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li><li>时刻需要关注this的指向问题；</li><li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li></ul><ol><li>状态与UI隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</li></ol><p>注意:</p><ul><li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li><li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li><li>不能在useEffect中使用useState，React 会报错提示；</li><li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li></ul><p>重要钩子</p><ol><li>状态钩子 (useState): 用于定义组件的 State，其到类定义中this.state的功能；</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// useState 只接受一个参数: 初始状态
// 返回的是组件名和更改该组件对应的函数
const [flag, setFlag] = useState(true);
// 修改状态
setFlag(false)

// 上面的代码映射到类定义中:
this.state = {
	flag: true	
}
const flag = this.state.flag
const setFlag = (bool) =&gt; {
    this.setState({
        flag: bool,
    })
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>生命周期钩子 (useEffect):</li></ol><blockquote><p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (useEffect)，这里可以看做componentDidMount、componentDidUpdate和componentWillUnmount的结合。</p></blockquote><p>useEffect(callback, [source])接受两个参数</p><ul><li>callback: 钩子回调函数；</li><li>source: 设置触发条件，仅当 source 发生改变时才会触发；</li><li>useEffect钩子在没有传入[source]参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>useEffect(() =&gt; {
	// 组件挂载后执行事件绑定
	console.log(&#39;on&#39;)
	addEventListener()

	// 组件 update 时会执行事件解绑
	return () =&gt; {
		console.log(&#39;off&#39;)
		removeEventListener()
	}
}, [source]);

// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):
// --- DidMount ---
// &#39;on&#39;
// --- DidUpdate ---
// &#39;off&#39;
// &#39;on&#39;
// --- DidUpdate ---
// &#39;off&#39;
// &#39;on&#39;
// --- WillUnmount ---
// &#39;off&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过第二个参数，我们便可模拟出几个常用的生命周期:</p><ul><li>componentDidMount: 传入[]时，就只会在初始化时调用一次</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const useMount = (fn) =&gt; useEffect(fn, [])

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const useUnmount = (fn) =&gt; useEffect(() =&gt; fn, [])

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const useMounted = () =&gt; {
    const [mounted, setMounted] = useState(false);
    useEffect(() =&gt; {
        !mounted &amp;&amp; setMounted(true);
        return () =&gt; setMounted(false);
    }, []);
    return mounted;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const mounted = useMounted()
useEffect(() =&gt; {
    mounted &amp;&amp; fn()
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>其它内置钩子:</li></ol><ul><li><code>useContext</code>: 获取 context 对象</li><li><code>useReducer</code>: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux: <ul><li>并不是持久化存储，会随着组件被销毁而销毁；</li><li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li><li>配合useContext`的全局性，可以完成一个轻量级的 Redux；(easy-peasy)</li></ul></li><li><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</li><li><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</li><li><code>useRef</code>: 获取组件的真实节点；</li><li><code>useLayoutEffect</code><ul><li>DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同</li><li>useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；</li><li>可以获取更新后的 state；</li></ul></li></ul><ol><li>自定义钩子(useXxxxx): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的useMounted。又例如，我们需要每个页面自定义标题:</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function useTitle(title) {
  useEffect(
    () =&gt; {
      document.title = title;
    });
}

// 使用:
function Home() {
	const title = &#39;我是首页&#39;
	useTitle(title)

	return (
		&lt;div&gt;{title}&lt;/div&gt;
	)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React Hooks 的限制</p><p><img src="/assets/20210425213051.3bd5788a.png" alt=""></p><ul><li>不要在<code>循环、条件</code>或<code>嵌套函数中调用 Hook</code>；</li><li>在 React 的函数组件中调用 <code>Hook</code></li></ul><blockquote><p>那为什么会有这样的限制呢？就得从 Hooks 的设计说起。Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。</p></blockquote><ul><li>组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、<code>render props</code> 及状态管理框架。</li><li>复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。</li><li>常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，他们希望在编译优化层面做出一些改进。</li></ul><blockquote><p>这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。</p></blockquote><p>那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？<code>因为 Hooks 的设计是基于数组实现</code>。在<code>调用时按顺序加入数组中</code>，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，<code>实质上 React 的源码里不是数组，是链表</code>。</p><p>这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。</p><p>useEffect 与 useLayoutEffect 区别在哪里</p><p><img src="/assets/20210425213302.5a420c5d.png" alt=""></p><ul><li>它们的共同点很简单，底层的函数签名是完全一致的，都是调用的 <code>mountEffectImpl</code>，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用。</li><li>那不同点就很大了，<code>useEffect</code> 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 <code>LayoutEffect</code> 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 <code>LayoutEffect</code> 做计算量较大的耗时任务从而造成阻塞。</li><li>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 <code>useEffect</code>，一般问题不大；如果页面有异常，再直接替换为 <code>useLayoutEffect</code> 即可。</li></ul><h3 id="_21-受控组件和非受控组件" tabindex="-1"><a class="header-anchor" href="#_21-受控组件和非受控组件" aria-hidden="true">#</a> 21 受控组件和非受控组件</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;FInput value = {x} onChange = {fn} /&gt;
// 上面的是受控组件 下面的是非受控组件
&lt;FInput defaultValue = {x} /&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当你一个组件同时传递一个value以及onChange事件时，它就是一个受控组件，收入输出都是我来控制的。</li><li>第二个只是传递了默认的初时值，并没有传onchange事件，</li><li>非受控组件是一种反模式，它的值不受组件自身的state或props控制</li></ul><h3 id="_22-如何避免ajax数据请求重新获取" tabindex="-1"><a class="header-anchor" href="#_22-如何避免ajax数据请求重新获取" aria-hidden="true">#</a> 22 如何避免ajax数据请求重新获取</h3><blockquote><p>一般而言，ajax请求的数据都放在redux中存取。</p></blockquote><h3 id="_23-组件之间通信" tabindex="-1"><a class="header-anchor" href="#_23-组件之间通信" aria-hidden="true">#</a> 23 组件之间通信</h3><ul><li>父子组件通信</li><li>自定义事件</li><li>redux和context</li></ul><p>context如何运用</p><ul><li>父组件向其下所有子孙组件传递信息</li><li>如一些简单的信息：主题、语言</li><li>复杂的公共信息用redux</li></ul><blockquote><p>在跨层级通信中，主要分为一层或多层的情况</p></blockquote><ul><li>如果只有一层，那么按照 React 的树形结构进行分类的话，主要有以下三种情况：<code>父组件向子组件通信</code>，<code>子组件向父组件通信</code>以及<code>平级的兄弟组件间互相通信</code>。</li><li>在父与子的情况下，因为 React 的设计实际上就是传递 <code>Props</code> 即可。那么场景体现在容器组件与展示组件之间，通过 <code>Props</code> 传递 <code>state</code>，让展示组件受控。</li><li>在子与父的情况下，有两种方式，分别是回调函数与实例函数。回调函数，比如输入框向父级组件返回输入内容，按钮向父级组件传递点击事件等。实例函数的情况有些特别，主要是在父组件中<code>通过 React 的 ref API 获取子组件的实例</code>，然后是<code>通过实例调用子组件的实例函数</code>。这种方式在过去常见于 Modal 框的显示与隐藏</li><li>多层级间的数据通信，有两种情况。第一种是一个容器中包含了多层子组件，需要最底部的子组件与顶部组件进行通信。在这种情况下，如果不断透传 Props 或回调函数，不仅代码层级太深，后续也很不好维护。第二种是两个组件不相关，在整个 React 的组件树的两侧，完全不相交。那么基于多层级间的通信一般有三个方案。 <ul><li>第一个是使用 React 的 <code>Context API</code>，最常见的用途是做语言包国际化</li><li>第二个是使用全局变量与事件。</li><li>第三个是使用状态管理框架，比如 Flux、Redux 及 Mobx。优点是由于引入了状态管理，使得项目的开发模式与代码结构得以约束，缺点是学习成本相对较高</li></ul></li></ul><p><img src="/assets/20210425145857.b7855e0d.png" alt=""></p><h3 id="_24-类组件与函数组件有什么区别呢" tabindex="-1"><a class="header-anchor" href="#_24-类组件与函数组件有什么区别呢" aria-hidden="true">#</a> 24 类组件与函数组件有什么区别呢？</h3><ul><li>作为组件而言，类组件与函数组件在使用与呈现上没有任何不同，性能上在现代浏览器中也不会有明显差异</li><li>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</li><li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。</li><li>但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。</li><li>其次继承并不是组件最佳的设计模式，官方更推崇&quot;组合优于继承&quot;的设计概念，所以类组件在这方面的优势也在淡出。</li><li>性能优化上，类组件主要依靠 <code>shouldComponentUpdate</code> 阻断渲染来提升性能，而函数组件依靠 <code>React.memo</code> 缓存渲染结果来提升性能。</li><li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li><li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</li></ul><p><img src="/assets/20210425134417.36939978.png" alt=""></p><h3 id="_25-如何设计react组件" tabindex="-1"><a class="header-anchor" href="#_25-如何设计react组件" aria-hidden="true">#</a> 25 如何设计React组件</h3><p>React 组件应从<code>设计与工程实践</code>两个方向进行探讨</p><blockquote><p>从设计上而言，社区主流分类的方案是展示组件与灵巧组件</p></blockquote><ul><li><code>展示组件内部没有状态管理，仅仅用于最简单的展示表达</code>。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。</li><li>从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力</li></ul><p><img src="/assets/20210425134939.61cbba29.png" alt=""></p><h3 id="_26-组件的协同及-不-可控组件" tabindex="-1"><a class="header-anchor" href="#_26-组件的协同及-不-可控组件" aria-hidden="true">#</a> 26 组件的协同及（不）可控组件</h3><p>为什么要进行组件的协同</p><ul><li>我们在实际的开发项目的时候，不会只用几个组件，有时候遇到大型的项目，可能会有成千上百的组件，难免会遇到有功能重复的组件。要进行修改，就会修改大部分的文件。所以我们需要进行组件的协同开发。</li></ul><p><img src="/assets/20210427114453.b53a0bf7.png" alt=""></p><p>什么是组件的协同使用？</p><ul><li>组件的协同本质上是对组件的一种组织、管理的方式。</li><li>目的： <ul><li>逻辑清晰：这是组件与组件之间的逻辑</li><li>代码模块化</li><li>封装细节：像面向对象一样将常用的方法以及数据封装起来</li><li>提高代码的复用性：因为是组件，相当于一个封装好的东西，用的时候直接调用</li></ul></li></ul><p>如何实现组件的协同使用</p><ul><li>第一种：增加一个父组件，将其他的组件进行嵌套，更多的是实现代码的封装</li><li>第二种：通过一些操作从后台获取数据，<code>React</code>中的<code>Mixin</code>，更多的是实现代码的复用</li></ul><p>组件嵌套的含义</p><ul><li>组件嵌套的本质是父子关系</li></ul><p><img src="/assets/20210427114544.2fbb5029.png" alt=""></p><p>组件嵌套的优缺点</p><ul><li>优点： <ul><li>逻辑清晰：父子关系类似于人类中的父子关系</li><li>模块化开发：每个模块对应一个功能，不同的模块可以同步开发</li><li>封装细节：开发者必须要关注组件的功能，不需要了解细节</li></ul></li><li>缺点： <ul><li>编写难度高：父子组件的关系需要经过深思熟虑，贸然编写可能导致关系混乱，代码难以维护</li><li>无法掌握所有细节：使用者只知道组件的用法，不知道实现细节，遇到问题难以修复</li></ul></li></ul><p>Mixin</p><p>Mixin的含义</p><ul><li><code>Mixin=一组方法</code>。</li><li>他的目的是横向抽离出组件的相似代码，把组件的共同作用以及效果的代码提出来</li></ul><p><img src="/assets/20210427114655.48b4a1d6.png" alt=""></p><p>Mixin的优缺点</p><ul><li>优点 <ul><li>代码复用：抽离出通用的代码，减少开发成本，提高开发效率</li><li>即插即用：可以使用许多现有的<code>Mixin</code>来开发自己的代码</li><li>适应性强：改动一次代码，影响多个组件</li></ul></li><li>缺点 <ul><li>编写难度高：<code>Mixin</code>可能被用在各种环境中，想要兼容多种环境就需要更多的 - 码与逻辑，通用的代价是提高复杂度</li><li>降低代码的可读性：组件的优势在于将逻辑与是界面直接结合在一起，<code>Mixin</code>本质上会分散逻辑，理解起来难度大</li></ul></li></ul><p>不可控组件</p><p><img src="/assets/20210427114820.6314ed35.png" alt=""></p><ul><li>上图：<code>defaultValue</code>的值是固定的，这就是一个不可控组件</li><li>如果要获取<code>input</code>的<code>value</code>值，只有使用<code>ref</code>获取节点来获取值</li></ul><p>可控组件</p><p><img src="/assets/20210427114833.38be03a2.png" alt=""></p><ul><li><code>defaultValue</code>的值是根据状态确定了，只需要拿到<code>this.state.value</code>的值就可以了</li><li>这里需要注意一下：使用<code>value</code>的值是不可修改的，<code>defaultValue</code>的值是可以修改的</li></ul><p>可控组件的优点</p><ul><li>符合<code>React</code>的数据流</li><li>数据存储在<code>state</code>中，便于获取</li><li>便于处理数据</li></ul><h3 id="_27-react-router-的实现原理及工作方式分别是什么" tabindex="-1"><a class="header-anchor" href="#_27-react-router-的实现原理及工作方式分别是什么" aria-hidden="true">#</a> 27 React-Router 的实现原理及工作方式分别是什么</h3><ul><li><code>React Router</code> 路由的基础实现原理分为两种，如果是<code>切换 Hash</code> 的方式，那么依靠浏览器 <code>Hash</code> 变化即可；如果是切换网址中的 <code>Path</code>，就要用到 <code>HTML5 History API</code> 中的 <code>pushState</code>、<code>replaceState</code> 等。在使用这个方式时，还需要在服务端完成 <code>historyApiFallback</code> 配置</li><li>在 <code>React Router</code> 内部主要依靠 <code>history</code> 库完成，这是由 <code>React Router</code> 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 <code>history</code>，一套是直接使用浏览器的 <code>History API</code>，用于支持 <code>react-router-dom</code>；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 <code>react-router-native</code>。</li><li><code>React Router</code> 的工作方式可以分为设计模式与关键模块两个部分。从设计模式的角度出发，在架构上通过 <code>Monorepo</code>进行库的管理。<code>Monorepo</code> 具有团队间透明、迭代便利的优点。其次在整体的数据通信上使用了 Context API 完成上下文传递。</li><li>在关键模块上，主要分为三类组件：<code>第一类是 Context 容器</code>，比如 Router 与 MemoryRouter；<code>第二类是消费者组件，用以匹配路由</code>，主要有 Route、Redirect、Switch 等；<code>第三类是与平台关联的功能组件</code>，比如 <code>Link、NavLink、DeepLinking</code> 等。</li></ul><p><img src="/assets/20210425214114.5f3c2751.png" alt=""></p><p><img src="/assets/20210409164620.de42876d.png" alt=""></p><p><a href="http://interview.poetries.top/principle-docs/react/01-React-router%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener noreferrer">React router原理分析(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_28-react-17-带来了哪些改变" tabindex="-1"><a class="header-anchor" href="#_28-react-17-带来了哪些改变" aria-hidden="true">#</a> 28 React 17 带来了哪些改变</h3><blockquote><p>最重要的是以下三点：</p></blockquote><ul><li>新的 <code>JSX</code> 转换逻辑</li><li>事件系统重构</li><li><code>Lane 模型</code>的引入</li></ul><p>1. 重构 JSX 转换逻辑</p><p>在过去，如果我们在 React 项目中写入下面这样的代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function MyComponent() {
  return &lt;p&gt;这是我的组件&lt;/p&gt;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 是会报错的，原因是 React 中对 JSX 代码的转换依赖的是 <code>React.createElement</code> 这个函数。因此但凡我们在代码中包含了 JSX，那么就必须在文件中引入 React，像下面这样：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import React from &#39;react&#39;;
function MyComponent() {
  return &lt;p&gt;这是我的组件&lt;/p&gt;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 <code>React 17 则允许我们在不引入 React 的情况下直接使用 JSX</code>。这是因为在 React 17 中，编译器会自动帮我们引入 JSX 的解析器，也就是说像下面这样一段逻辑：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function MyComponent() {
  return &lt;p&gt;这是我的组件&lt;/p&gt;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会被编译器转换成这个样子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import {jsx as _jsx} from &#39;react/jsx-runtime&#39;;
function MyComponent() {
  return _jsx(&#39;p&#39;, { children: &#39;这是我的组件&#39; });
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>react/jsx-runtime</code> 中的 JSX 解析器将取代 <code>React.createElement</code> 完成 <code>JSX</code> 的编译工作，这个过程对开发者而言是自动化、无感知的。因此，新的 JSX 转换逻辑带来的最显著的改变就是降低了开发者的学习成本。</p><p><code>react/jsx-runtime</code> 中的 JSX 解析器看上去似乎在调用姿势上和 <code>React.createElement</code> 区别不大，那么它是否只是 <code>React.createElement</code> 换了个马甲呢？当然不是，它在内部实现了 <code>React.createElement</code> 无法做到的性能优化和简化。在一定情况下，它可能会略微改善编译输出内容的大小</p><p>2. 事件系统重构</p><p>事件系统在 React 17 中的重构要从以下两个方面来看：</p><ul><li>卸掉历史包袱</li><li>拥抱新的潮流</li></ul><p>2.1 卸掉历史包袱：放弃利用 document 来做事件的中心化管控</p><blockquote><p>React 16.13.x 版本中的事件系统会通过将所有事件冒泡到 document 来实现对事件的中心化管控</p></blockquote><p>这样的做法虽然看上去已经足够巧妙，但仍然有它不聪明的地方------document 是整个文档树的根节点，操作 document 带来的影响范围实在是太大了，这将会使事情变得更加不可控</p><blockquote><p>在 React 17 中，React 团队终于正面解决了这个问题：事件的中心化管控不会再全部依赖 <code>document</code>，管控相关的逻辑被转移到了每个 React 组件自己的容器 DOM 节点中。比如说我们在 ID 为 root 的 DOM 节点下挂载了一个 React 组件，像下面代码这样：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;App /&gt;, rootElement);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么事件管控相关的逻辑就会被安装到 <code>root 节点</code>上去。这样一来， React 组件就能够自己玩自己的，再也无法对全局的事件流构成威胁了</p><p>2.2 拥抱新的潮流：放弃事件池</p><p>在 React 17 之前，合成事件对象会被放进一个叫作&quot;事件池&quot;的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了，React 官方给出的这个例子就很能说明问题，请看下面这个代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function handleChange(e) {
  // This won&#39;t work because the event object gets reused.
  setTimeout(() =&gt; {
    console.log(e.target.value); // Too late!
  }, 100);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>异步执行的 <code>setTimeout</code> 回调会在 <code>handleChange</code> 这个事件处理函数执行完毕后执行，因此它拿不到想要的那个事件对象 <code>e</code>。</p></blockquote><p>要想拿到目标事件对象，必须显式地告诉 React------我永远需要它，也就是调用 <code>e.persist()</code> 函数，像下面这样：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function handleChange(e) {
  // Prevents React from resetting its properties:
  e.persist();
  setTimeout(() =&gt; {
    console.log(e.target.value); // Works
  }, 100);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 React 17 中，我们不需要 <code>e.persist()</code>，也可以随时随地访问我们想要的事件对象。</p><p>3. Lane 模型的引入</p><p>初学 React 源码的同学由此可能会很自然地认为：<code>优先级就应该是用 Lane 来处理的</code>。但事实上，<code>React 16 中处理优先级采用的是 expirationTime 模型</code>。</p><blockquote><p><code>expirationTime</code> 模型使用 <code>expirationTime</code>（一个时间长度） 来描述任务的优先级；而 <code>Lane 模型</code>则使用<code>二进制数来表示任务的优先级</code>：</p></blockquote><p><code>lane 模型</code>通过将不同优先级赋值给一个位，通过 <code>31 位的位运算</code>来操作优先级。</p><p><code>Lane 模型</code>提供了一个新的优先级排序的思路，相对于 <code>expirationTime</code> 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/advanced/Vue.html" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></span><span class="next"><a href="/advanced/%E6%80%A7%E8%83%BD.html" class="" aria-label="性能"><!--[--><!--]--> 性能 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.12353158.js" defer></script>
  </body>
</html>
