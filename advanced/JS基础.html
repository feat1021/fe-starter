<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>JS基础 | Frontend Starter</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.12353158.js"><link rel="modulepreload" href="/assets/JS基础.html.b88ab559.js"><link rel="modulepreload" href="/assets/JS基础.html.0a913d15.js"><link rel="prefetch" href="/assets/index.html.ee998a26.js"><link rel="prefetch" href="/assets/CSS.html.c64e9431.js"><link rel="prefetch" href="/assets/HTML.html.a70e4433.js"><link rel="prefetch" href="/assets/HTTP.html.6dbdd949.js"><link rel="prefetch" href="/assets/React.html.6802a56c.js"><link rel="prefetch" href="/assets/Vue.html.a81339b7.js"><link rel="prefetch" href="/assets/工程化.html.0c152696.js"><link rel="prefetch" href="/assets/性能.html.090fde92.js"><link rel="prefetch" href="/assets/框架通识.html.1a3f58ab.js"><link rel="prefetch" href="/assets/浏览器.html.2ec19a51.js"><link rel="prefetch" href="/assets/设计模式.html.5761cd54.js"><link rel="prefetch" href="/assets/Bootstrap.html.86ad9734.js"><link rel="prefetch" href="/assets/CSS.html.e3ee6176.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.6603dd61.js"><link rel="prefetch" href="/assets/JavaScript.html.14aca0a4.js"><link rel="prefetch" href="/assets/Webpack.html.f773c5e1.js"><link rel="prefetch" href="/assets/jQuery.html.c3b9972e.js"><link rel="prefetch" href="/assets/其他.html.c716f6ee.js"><link rel="prefetch" href="/assets/微信小程序.html.0335a142.js"><link rel="prefetch" href="/assets/综合.html.5dfe757e.js"><link rel="prefetch" href="/assets/编程题.html.cbfc1c8c.js"><link rel="prefetch" href="/assets/性能优化.html.30c3f1c5.js"><link rel="prefetch" href="/assets/高频考点.html.2ee4efd2.js"><link rel="prefetch" href="/assets/handwritten.html.879fcb5e.js"><link rel="prefetch" href="/assets/JavaScript.html.bcb5a0d9.js"><link rel="prefetch" href="/assets/Node.html.be9ed4e1.js"><link rel="prefetch" href="/assets/React.html.36beeb6b.js"><link rel="prefetch" href="/assets/Vue.html.b739e835.js"><link rel="prefetch" href="/assets/Webpack.html.b34fb870.js"><link rel="prefetch" href="/assets/综合.html.30e0bc70.js"><link rel="prefetch" href="/assets/CSS模块.html.99bd45d7.js"><link rel="prefetch" href="/assets/ES6模块.html.0f2bfddb.js"><link rel="prefetch" href="/assets/HTML模块.html.4fb65265.js"><link rel="prefetch" href="/assets/HTTP模块.html.b4ce19f7.js"><link rel="prefetch" href="/assets/JS模块.html.015ff251.js"><link rel="prefetch" href="/assets/Node模块.html.b1985276.js"><link rel="prefetch" href="/assets/React模块.html.f53e1f03.js"><link rel="prefetch" href="/assets/Vue模块.html.785747a6.js"><link rel="prefetch" href="/assets/前端安全模块.html.f0f98ff3.js"><link rel="prefetch" href="/assets/前端工程相关.html.183e2c9f.js"><link rel="prefetch" href="/assets/小程序模块.html.f7ab4d91.js"><link rel="prefetch" href="/assets/常用设计模式.html.03f9722f.js"><link rel="prefetch" href="/assets/性能优化相关.html.12e8a2e3.js"><link rel="prefetch" href="/assets/排序算法.html.40481e91.js"><link rel="prefetch" href="/assets/框架通识.html.c3c3096b.js"><link rel="prefetch" href="/assets/浏览器模块.html.24652566.js"><link rel="prefetch" href="/assets/移动多端开发.html.8636371c.js"><link rel="prefetch" href="/assets/计算机通识.html.728b7ceb.js"><link rel="prefetch" href="/assets/404.html.93c18560.js"><link rel="prefetch" href="/assets/index.html.60500264.js"><link rel="prefetch" href="/assets/CSS.html.02fa634c.js"><link rel="prefetch" href="/assets/HTML.html.3a31cd64.js"><link rel="prefetch" href="/assets/HTTP.html.a1df6d3a.js"><link rel="prefetch" href="/assets/React.html.4ec983c7.js"><link rel="prefetch" href="/assets/Vue.html.5c58cab9.js"><link rel="prefetch" href="/assets/工程化.html.863e35db.js"><link rel="prefetch" href="/assets/性能.html.470e0a6f.js"><link rel="prefetch" href="/assets/框架通识.html.32d2fbab.js"><link rel="prefetch" href="/assets/浏览器.html.8279ebd9.js"><link rel="prefetch" href="/assets/设计模式.html.6afe6cf3.js"><link rel="prefetch" href="/assets/Bootstrap.html.2cc414a0.js"><link rel="prefetch" href="/assets/CSS.html.5d66e791.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.bbea8927.js"><link rel="prefetch" href="/assets/JavaScript.html.07acfd24.js"><link rel="prefetch" href="/assets/Webpack.html.a1c5dce1.js"><link rel="prefetch" href="/assets/jQuery.html.4e2f3899.js"><link rel="prefetch" href="/assets/其他.html.929587e1.js"><link rel="prefetch" href="/assets/微信小程序.html.69cc86fd.js"><link rel="prefetch" href="/assets/综合.html.1c892aa5.js"><link rel="prefetch" href="/assets/编程题.html.5478af99.js"><link rel="prefetch" href="/assets/性能优化.html.337c4654.js"><link rel="prefetch" href="/assets/高频考点.html.8772c401.js"><link rel="prefetch" href="/assets/handwritten.html.0f0ee7e3.js"><link rel="prefetch" href="/assets/JavaScript.html.5dd72bd0.js"><link rel="prefetch" href="/assets/Node.html.7eac5124.js"><link rel="prefetch" href="/assets/React.html.d8ccb952.js"><link rel="prefetch" href="/assets/Vue.html.47efbab1.js"><link rel="prefetch" href="/assets/Webpack.html.793df544.js"><link rel="prefetch" href="/assets/综合.html.ff78888d.js"><link rel="prefetch" href="/assets/CSS模块.html.bcc3cfc7.js"><link rel="prefetch" href="/assets/ES6模块.html.2ea3507a.js"><link rel="prefetch" href="/assets/HTML模块.html.6b729342.js"><link rel="prefetch" href="/assets/HTTP模块.html.2c6adffa.js"><link rel="prefetch" href="/assets/JS模块.html.28259fe6.js"><link rel="prefetch" href="/assets/Node模块.html.c36cd1fb.js"><link rel="prefetch" href="/assets/React模块.html.b09a5954.js"><link rel="prefetch" href="/assets/Vue模块.html.a27ab950.js"><link rel="prefetch" href="/assets/前端安全模块.html.e3aebe2f.js"><link rel="prefetch" href="/assets/前端工程相关.html.281b6ffe.js"><link rel="prefetch" href="/assets/小程序模块.html.493268db.js"><link rel="prefetch" href="/assets/常用设计模式.html.a600f326.js"><link rel="prefetch" href="/assets/性能优化相关.html.aff23982.js"><link rel="prefetch" href="/assets/排序算法.html.361967d5.js"><link rel="prefetch" href="/assets/框架通识.html.7719e539.js"><link rel="prefetch" href="/assets/浏览器模块.html.ac4e495d.js"><link rel="prefetch" href="/assets/移动多端开发.html.d8fc5993.js"><link rel="prefetch" href="/assets/计算机通识.html.0e8ab127.js"><link rel="prefetch" href="/assets/404.html.232c3875.js"><link rel="prefetch" href="/assets/404.176778df.js"><link rel="prefetch" href="/assets/Layout.ac3a6e88.js">
    <link rel="stylesheet" href="/assets/style.20e644be.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Frontend Starter</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">基础 Basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/basic/HTTP%20&amp;%20HTML.html" class="sidebar-item" aria-label="HTML、HTTP、Web"><!--[--><!--]--> HTML、HTTP、Web <!--[--><!--]--></a><!----></li><li><a href="/basic/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/basic/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/basic/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/basic/Bootstrap.html" class="sidebar-item" aria-label="Bootstrap"><!--[--><!--]--> Bootstrap <!--[--><!--]--></a><!----></li><li><a href="/basic/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BC%96%E7%A8%8B%E9%A2%98.html" class="sidebar-item" aria-label="编程题"><!--[--><!--]--> 编程题 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%85%B6%E4%BB%96.html" class="sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">进阶 Advanced <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_1-类型及检测方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1 类型及检测方式"><!--[--><!--]--> 1 类型及检测方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_2-this" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 This"><!--[--><!--]--> 2 This <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_3-apply-call-bind-原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="3 apply/call/bind 原理"><!--[--><!--]--> 3 apply/call/bind 原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_4-变量提升" class="router-link-active router-link-exact-active sidebar-item" aria-label="4 变量提升"><!--[--><!--]--> 4 变量提升 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_5-执行上下文" class="router-link-active router-link-exact-active sidebar-item" aria-label="5 执行上下文"><!--[--><!--]--> 5 执行上下文 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_6-作用域" class="router-link-active router-link-exact-active sidebar-item" aria-label="6 作用域"><!--[--><!--]--> 6 作用域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_7-闭包" class="router-link-active router-link-exact-active sidebar-item" aria-label="7 闭包"><!--[--><!--]--> 7 闭包 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_8-new的原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="8 New的原理"><!--[--><!--]--> 8 New的原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_9-原型-原型链" class="router-link-active router-link-exact-active sidebar-item" aria-label="9 原型/原型链"><!--[--><!--]--> 9 原型/原型链 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_10-继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="10 继承"><!--[--><!--]--> 10 继承 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_11-面向对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="11 面向对象"><!--[--><!--]--> 11 面向对象 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_12-事件机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="12 事件机制"><!--[--><!--]--> 12 事件机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_13-模块化" class="router-link-active router-link-exact-active sidebar-item" aria-label="13 模块化"><!--[--><!--]--> 13 模块化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_14-iterator迭代器" class="router-link-active router-link-exact-active sidebar-item" aria-label="14 Iterator迭代器"><!--[--><!--]--> 14 Iterator迭代器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_15-promise" class="router-link-active router-link-exact-active sidebar-item" aria-label="15 Promise"><!--[--><!--]--> 15 Promise <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_16-generator" class="router-link-active router-link-exact-active sidebar-item" aria-label="16 Generator"><!--[--><!--]--> 16 Generator <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_17-async-await" class="router-link-active router-link-exact-active sidebar-item" aria-label="17 async/await"><!--[--><!--]--> 17 async/await <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_18-事件循环" class="router-link-active router-link-exact-active sidebar-item" aria-label="18 事件循环"><!--[--><!--]--> 18 事件循环 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_19-垃圾回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="19 垃圾回收"><!--[--><!--]--> 19 垃圾回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_20-内存泄露" class="router-link-active router-link-exact-active sidebar-item" aria-label="20 内存泄露"><!--[--><!--]--> 20 内存泄露 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_21-深浅拷贝" class="router-link-active router-link-exact-active sidebar-item" aria-label="21 深浅拷贝"><!--[--><!--]--> 21 深浅拷贝 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_22-节流与防抖" class="router-link-active router-link-exact-active sidebar-item" aria-label="22 节流与防抖"><!--[--><!--]--> 22 节流与防抖 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_23-proxy代理" class="router-link-active router-link-exact-active sidebar-item" aria-label="23 Proxy代理"><!--[--><!--]--> 23 Proxy代理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_24-ajax" class="router-link-active router-link-exact-active sidebar-item" aria-label="24 Ajax"><!--[--><!--]--> 24 Ajax <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/advanced/JS%E5%9F%BA%E7%A1%80.html#_25-深入数组" class="router-link-active router-link-exact-active sidebar-item" aria-label="25 深入数组"><!--[--><!--]--> 25 深入数组 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/advanced/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/advanced/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%B5%8F%E8%A7%88%E5%99%A8.html" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/advanced/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/advanced/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%80%A7%E8%83%BD.html" class="sidebar-item" aria-label="性能"><!--[--><!--]--> 性能 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="sidebar-item" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">精选 Selected <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/selected/HTML%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTML模块"><!--[--><!--]--> HTML模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/CSS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="CSS模块"><!--[--><!--]--> CSS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/JS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="JS模块"><!--[--><!--]--> JS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/ES6%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="ES6模块"><!--[--><!--]--> ES6模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="浏览器模块"><!--[--><!--]--> 浏览器模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/React%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="React模块"><!--[--><!--]--> React模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Vue%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Vue模块"><!--[--><!--]--> Vue模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Node%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Node模块"><!--[--><!--]--> Node模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="前端工程相关"><!--[--><!--]--> 前端工程相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="移动多端开发"><!--[--><!--]--> 移动多端开发 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="小程序模块"><!--[--><!--]--> 小程序模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="前端安全模块"><!--[--><!--]--> 前端安全模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="性能优化相关"><!--[--><!--]--> 性能优化相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/HTTP%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTTP模块"><!--[--><!--]--> HTTP模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="常用设计模式"><!--[--><!--]--> 常用设计模式 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="计算机通识"><!--[--><!--]--> 计算机通识 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">高频 Frequency <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/frequency/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" class="sidebar-item" aria-label="高频考点"><!--[--><!--]--> 高频考点 <!--[--><!--]--></a><!----></li><li><a href="/frequency/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">原理 Principle <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/principle/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/principle/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/principle/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/principle/Node.html" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><li><a href="/principle/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/principle/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="js基础" tabindex="-1"><a class="header-anchor" href="#js基础" aria-hidden="true">#</a> JS基础</h1><hr><h3 id="_1-类型及检测方式" tabindex="-1"><a class="header-anchor" href="#_1-类型及检测方式" aria-hidden="true">#</a> 1 类型及检测方式</h3><p>1. JS内置类型</p><p>JavaScript 的数据类型有下图所示</p><p><img src="/assets/20210414100319.b01da7d3.png" alt=""></p><blockquote><p>其中，前 7 种类型为基础类型，最后 <code>1 种（Object）为引用类型</code>，也是你需要重点关注的，因为它在日常工作中是使用得最频繁，也是需要关注最多技术细节的数据类型</p></blockquote><ul><li><code>JavaScript</code>一共有8种数据类型，其中有7种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>（<code>es6</code>新增，表示独一无二的值）和<code>BigInt</code>（<code>es10</code>新增）；</li><li>1种引用数据类型------<code>Object</code>（Object本质上是由一组无序的名值对组成的）。里面包含 <code>function、Array、Date</code>等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。 <ul><li>引用数据类型: 对象<code>Object</code>（包含普通对象-<code>Object</code>，数组对象-<code>Array</code>，正则对象-<code>RegExp</code>，日期对象-<code>Date</code>，数学函数-<code>Math</code>，函数对象-<code>Function</code>）</li></ul></li></ul><blockquote><p>在这里，我想先请你重点了解下面两点，因为各种 JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分成两类来进行存储：</p></blockquote><ul><li>原始数据类型：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</li><li>引用数据类型：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个&quot;共享&quot;的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>JavaScript 中的数据是如何存储在内存中的？</p><blockquote><p>在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p></blockquote><p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<code>代码空间</code>、<code>栈空间</code>、<code>堆空间</code>。其中的代码空间主要是存储可执行代码的，原始类型(<code>Number、String、Null、Undefined、Boolean、Symbol、BigInt</code>)的数据值都是直接保存在&quot;栈&quot;中的，引用类型(Object)的值是存放在&quot;堆&quot;中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在&quot;堆空间&quot;中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p><p>在编译过程中，如果 JavaScript 引擎判断到一个闭包，也会在堆空间创建换一个<code>&quot;closure(fn)&quot;</code>的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存闭包中的变量。所以闭包中的变量是存储在&quot;堆空间&quot;中的。</p><p>JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要&quot;栈&quot;和&quot;堆&quot;两种空间。</p><blockquote><p>题目一：初出茅庐</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
  name: &#39;lee&#39;,
  age: 18
}
let b = a;
console.log(a.name);  //第一个console
b.name = &#39;son&#39;;
console.log(a.name);  //第二个console
console.log(b.name);  //第三个console

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这道题比较简单，我们可以看到第一个 console 打出来 name 是 &#39;lee&#39;，这应该没什么疑问；但是在执行了 b.name=&#39;son&#39; 之后，结果你会发现 a 和 b 的属性 name 都是 &#39;son&#39;，第二个和第三个打印结果是一样的，这里就体现了引用类型的&quot;共享&quot;的特性，即这两个值都存在同一块内存中共享，一个发生了改变，另外一个也随之跟着变化。</p></blockquote><p>你可以直接在 Chrome 控制台敲一遍，深入理解一下这部分概念。下面我们再看一段代码，它是比题目一稍复杂一些的对象属性变化问题。</p><blockquote><p>题目二：渐入佳境</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
  name: &#39;Julia&#39;,
  age: 20
}
function change(o) {
  o.age = 24;
  o = {
    name: &#39;Kath&#39;,
    age: 30
  }
  return o;
}
let b = change(a);     // 注意这里没有new，后面new相关会有专门文章讲解
console.log(b.age);    // 第一个console
console.log(a.age);    // 第二个console

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这道题涉及了 <code>function</code>，你通过上述代码可以看到第一个 <code>console</code> 的结果是 <code>30</code>，<code>b</code> 最后打印结果是 <code>{name: &quot;Kath&quot;, age: 30}</code>；第二个 <code>console</code> 的返回结果是 <code>24</code>，而 <code>a</code> 最后的打印结果是 <code>{name: &quot;Julia&quot;, age: 24}</code>。</p><p>是不是和你预想的有些区别？你要注意的是，这里的 <code>function</code> 和 <code>return</code> 带来了不一样的东西。</p><blockquote><p>原因在于：函数传参进来的 <code>o</code>，传递的是对象在堆中的内存地址值，通过调用 <code>o.age = 24</code>（第 7 行代码）确实改变了 <code>a</code> 对象的 <code>age</code> 属性；但是第 12 行代码的 <code>return</code> 却又把 <code>o</code> 变成了另一个内存地址，将 <code>{name: &quot;Kath&quot;, age: 30}</code> 存入其中，最后返回 <code>b</code> 的值就变成了 <code>{name: &quot;Kath&quot;, age: 30}</code>。而如果把第 12 行去掉，那么 <code>b</code> 就会返回 <code>undefined</code></p></blockquote><p>2. 数据类型检测</p><p>（1）typeof</p><blockquote><p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof &#39;str&#39;);           // string
console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code></p></blockquote><p>（2）instanceof</p><blockquote><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false
console.log(&#39;str&#39; instanceof String);                // false
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
// console.log(undefined instanceof Undefined);
// console.log(null instanceof Null);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li><li>而 <code>typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了 <code>function</code> 类型以外，其他的也无法判断</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 我们也可以试着实现一下 instanceof
function _instanceof(left, right) {
    // 由于instance要检测的是某对象，需要有一个前置判断条件
    //基本数据类型直接返回false
    if(typeof left !== &#39;object&#39; || left === null) return false;

    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}

console.log(&#39;test&#39;, _instanceof(null, Array)) // false
console.log(&#39;test&#39;, _instanceof([], Array)) // true
console.log(&#39;test&#39;, _instanceof(&#39;&#39;, Array)) // false
console.log(&#39;test&#39;, _instanceof({}, Object)) // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）constructor</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log((&#39;str&#39;).constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里有一个坑，如果我创建一个对象，更改它的原型，<code>constructor</code>就会变得不可靠了</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Fn(){};

Fn.prototype=new Array();

var f=new Fn();

console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）Object.prototype.toString.call()</p><blockquote><p><code>toString()</code> 是 <code>Object</code> 的原型方法，调用该方法，可以统一返回格式为 <code>&quot;[object Xxx]&quot;</code> 的字符串，其中 <code>Xxx</code> 就是对象的类型。对于 <code>Object</code> 对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code>；而对于其他对象，则需要通过 <code>call</code> 来调用，才能返回正确的类型信息。我们来看一下代码。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Object.prototype.toString({})       // &quot;[object Object]&quot;
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // &quot;[object Number]&quot;
Object.prototype.toString.call(&#39;1&#39;)  // &quot;[object String]&quot;
Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;
Object.prototype.toString.call(function(){})  // &quot;[object Function]&quot;
Object.prototype.toString.call(null)   //&quot;[object Null]&quot;
Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;
Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;
Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;
Object.prototype.toString.call([])       //&quot;[object Array]&quot;
Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;
Object.prototype.toString.call(window)   //&quot;[object Window]&quot;

// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function getType(obj){
  let type  = typeof obj;
  if (type !== &quot;object&quot;) {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#39;$1&#39;);  // 注意正则中间有个空格
}
/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */
getType([])     // &quot;Array&quot; typeof []是object，因此toString返回
getType(&#39;123&#39;)  // &quot;string&quot; typeof 直接返回
getType(window) // &quot;Window&quot; toString返回
getType(null)   // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断
getType(undefined)   // &quot;undefined&quot; typeof 直接返回
getType()            // &quot;undefined&quot; typeof 直接返回
getType(function(){}) // &quot;function&quot; typeof能判断，因此首字母小写
getType(/123/g)      //&quot;RegExp&quot; toString返回

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小结</p><ul><li><code>typeof</code><ul><li>直接在计算机底层基于数据类型的值（二进制）进行检测</li><li><code>typeof null</code>为<code>object</code> 原因是对象存在在计算机中，都是以<code>000</code>开始的二进制存储，所以检测出来的结果是对象</li><li><code>typeof</code> 普通对象/数组对象/正则对象/日期对象 都是<code>object</code></li><li><code>typeof NaN === &#39;number&#39;</code></li></ul></li><li><code>instanceof</code><ul><li>检测当前实例是否属于这个类的</li><li>底层机制：只要当前类出现在实例的原型上，结果都是true</li><li>不能检测基本数据类型</li></ul></li><li><code>constructor</code><ul><li>支持基本类型</li><li>constructor可以随便改，也不准</li></ul></li><li><code>Object.prototype.toString.call([val])</code><ul><li>返回当前实例所属类信息</li></ul></li></ul><blockquote><p>判断 <code>Target</code> 的类型，单单用 <code>typeof</code> 并无法完全满足，这其实并不是 <code>bug</code>，本质原因是 <code>JS</code> 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p></blockquote><ul><li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li><li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: - 直接使用 <code>typeof</code>即可</li><li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li></ul><p>3. 数据类型转换</p><p>我们先看一段代码，了解下大致的情况。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&#39;123&#39; == 123   // false or true?
&#39;&#39; == null    // false or true?
&#39;&#39; == 0        // false or true?
[] == 0        // false or true?
[] == &#39;&#39;       // false or true?
[] == ![]      // false or true?
null == undefined //  false or true?
Number(null)     // 返回什么？
Number(&#39;&#39;)      // 返回什么？
parseInt(&#39;&#39;);    // 返回什么？
{}+10           // 返回什么？
let obj = {
    [Symbol.toPrimitive]() {
        return 200;
    },
    valueOf() {
        return 300;
    },
    toString() {
        return &#39;Hello&#39;;
    }
}
console.log(obj + 200); // 这里打印出来是多少？

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p></blockquote><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><p><img src="/assets/20220307225251.3a209f70.png" alt=""></p><p>转Boolean</p><blockquote><p>在条件判断时，除了 <code>undefined</code>，<code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Boolean(0)          //false
Boolean(null)       //false
Boolean(undefined)  //false
Boolean(NaN)        //false
Boolean(1)          //true
Boolean(13)         //true
Boolean(&#39;12&#39;)       //true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对象转原始类型</p><blockquote><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下</p></blockquote><ul><li>如果已经是原始类型了，那就不需要转换了</li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><blockquote><p>当然你也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
  valueOf() {
    return 0
  },
  toString() {
    return &#39;1&#39;
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // =&gt; 3

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>四则运算符</p><blockquote><p>它有以下几个特点：</p></blockquote><ul><li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li><li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1 + &#39;1&#39; // &#39;11&#39;
true + true // 2
4 + [1,2,3] // &quot;41,2,3&quot;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于第一行代码来说，触发特点一，所以将数字 <code>1</code> 转换为字符串，得到结果 <code>&#39;11&#39;</code></li><li>对于第二行代码来说，触发特点二，所以将 <code>true</code> 转为数字 <code>1</code></li><li>对于第三行代码来说，触发特点二，所以将数组通过 <code>toString</code>转为字符串 <code>1,2,3</code>，得到结果 <code>41,2,3</code></li></ul><blockquote><p>另外对于加法还需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为 <code>+ &#39;b&#39;</code> 等于 <code>NaN</code>，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ &#39;1&#39;</code>的形式来快速获取 <code>number</code> 类型。</li><li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>4 * &#39;3&#39; // 12
4 * [] // 0
4 * [1, 2] // NaN

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比较运算符</p><ul><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li><li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
  valueOf() {
    return 0
  },
  toString() {
    return &#39;1&#39;
  }
}
a &gt; -1 // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p></blockquote><p>强制类型转换</p><blockquote><p>强制类型转换方式包括 <code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>、<code>toString()</code>、<code>String()</code>、<code>Boolean()</code>，这几种方法都比较类似</p></blockquote><ul><li><code>Number()</code> 方法的强制转换规则</li><li>如果是布尔值，<code>true</code> 和 <code>false</code> 分别被转换为 <code>1</code> 和 <code>0</code>；</li><li>如果是数字，返回自身；</li><li>如果是 <code>null</code>，返回 <code>0</code>；</li><li>如果是 <code>undefined</code>，返回 <code>NaN</code>；</li><li>如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 <code>0X / 0x</code> 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 <code>0</code>；如果不是以上格式的字符串，均返回 NaN；</li><li>如果是 <code>Symbol</code>，抛出错误；</li><li>如果是对象，并且部署了 <code>[Symbol.toPrimitive]</code> ，那么调用此方法，否则调用对象的 <code>valueOf()</code> 方法，然后依据前面的规则转换返回的值；如果转换的结果是 <code>NaN</code> ，则调用对象的 <code>toString()</code> 方法，再次依照前面的顺序转换返回对应的值。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Number(true);        // 1
Number(false);       // 0
Number(&#39;0111&#39;);      //111
Number(null);        //0
Number(&#39;&#39;);          //0
Number(&#39;1a&#39;);        //NaN
Number(-0X11);       //-17
Number(&#39;0X11&#39;)       //17

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Object 的转换规则</p><blockquote><p>对象转换的规则，会先调用内置的 <code>[ToPrimitive]</code> 函数，其规则逻辑如下：</p></blockquote><ul><li>如果部署了 <code>Symbol.toPrimitive</code> 方法，优先调用再返回；</li><li>调用 <code>valueOf()</code>，如果转换为基础类型，则返回；</li><li>调用 <code>toString()</code>，如果转换为基础类型，则返回；</li><li>如果都没有返回基础类型，会报错。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var obj = {
  value: 1,
  valueOf() {
    return 2;
  },
  toString() {
    return &#39;3&#39;
  },
  [Symbol.toPrimitive]() {
    return 4
  }
}
console.log(obj + 1); // 输出5
// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&#39;31&#39;(字符串拼接)
// 再看两个特殊的case：
10 + {}
// &quot;10[object Object]&quot;，注意：{}会默认调用valueOf是{}，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&#39;+&#39;运算，按照字符串拼接规则来，参考&#39;+&#39;的规则C
[1,2,undefined,4,5] + 10
// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&#39;+&#39;的第3条规则

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>&#39;==&#39; 的隐式类型转换规则</p><ul><li>如果类型相同，无须进行类型转换；</li><li>如果其中一个操作值是 <code>null</code> 或者 <code>undefined</code>，那么另一个操作符必须为 <code>null</code> 或者 <code>undefined</code>，才会返回 <code>true</code>，否则都返回 <code>false</code>；</li><li>如果其中一个是 <code>Symbol</code> 类型，那么返回 <code>false</code>；</li><li>两个操作值如果为 <code>string</code> 和 number 类型，那么就会将字符串转换为 <code>number</code>；</li><li>如果一个操作值是 <code>boolean</code>，那么转换成 <code>number</code>；</li><li>如果一个操作值为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，就会把 <code>object</code> 转为原始类型再进行判断（调用 <code>object</code> 的 <code>valueOf/toString</code> 方法进行转换）。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>null == undefined       // true  规则2
null == 0               // false 规则2
&#39;&#39; == null              // false 规则2
&#39;&#39; == 0                 // true  规则4 字符串转隐式转换成Number之后再对比
&#39;123&#39; == 123            // true  规则4 字符串转隐式转换成Number之后再对比
0 == false              // true  e规则 布尔型隐式转换成Number之后再对比
1 == true               // true  e规则 布尔型隐式转换成Number之后再对比
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
// 注意这里a又可以等于1、2、3
console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true f规则 Object隐式转换
// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>&#39;+&#39; 的隐式类型转换规则</p><blockquote><p>&#39;+&#39; 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 &#39;+&#39; 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。</p></blockquote><ul><li>如果其中有一个是字符串，另外一个是 <code>undefined</code>、<code>null</code> 或布尔型，则调用 <code>toString()</code> 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。</li><li>如果其中有一个是数字，另外一个是 <code>undefined</code>、<code>null</code>、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。</li><li>如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1 + 2        // 3  常规情况
&#39;1&#39; + &#39;2&#39;    // &#39;12&#39; 常规情况
// 下面看一下特殊情况
&#39;1&#39; + undefined   // &quot;1undefined&quot; 规则1，undefined转换字符串
&#39;1&#39; + null        // &quot;1null&quot; 规则1，null转换字符串
&#39;1&#39; + true        // &quot;1true&quot; 规则1，true转换字符串
&#39;1&#39; + 1n          // &#39;11&#39; 比较特殊字符串和BigInt相加，BigInt转换为字符串
1 + undefined     // NaN  规则2，undefined转换数字相加NaN
1 + null          // 1    规则2，null转换为0
1 + true          // 2    规则2，true转换为1，二者相加为2
1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加
&#39;1&#39; + 3           // &#39;13&#39; 规则3，字符串拼接

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>整体来看，如果数据中有字符串，JavaScript 类型转换还是更倾向于转换成字符串，因为第三条规则中可以看到，在字符串和数字相加的过程中最后返回的还是字符串，这里需要关注一下</p></blockquote><p>null 和 undefined 的区别？</p><ul><li>首先 <code>Undefined</code> 和 <code>Null</code> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <code>undefined</code> 和 <code>null</code>。</li><li><code>undefined</code> 代表的含义是未定义， <code>null</code> 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 <code>undefined</code>，<code>null</code> 主要用于赋值给一些可能会返回对象的变量，作为初始化。</li></ul><blockquote><p>其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p></blockquote><ul><li>undefined 在 js 中不是一个保留字，这意味着我们可以使用 <code>undefined</code> 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 <code>undefined</code> 值，比如说 <code>void 0</code>。</li><li>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 &quot;object&quot;，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</li></ul><h3 id="_2-this" tabindex="-1"><a class="header-anchor" href="#_2-this" aria-hidden="true">#</a> 2 This</h3><blockquote><p>不同情况的调用，<code>this</code>指向分别如何。顺带可以提一下 <code>es6</code> 中箭头函数没有 <code>this</code>, <code>arguments</code>, <code>super</code> 等，这些只依赖包含箭头函数最接近的函数</p></blockquote><blockquote><p>我们先来看几个函数调用的场景</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></li><li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li><li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code></li></ul><blockquote><p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function a() {
  return () =&gt; {
    return () =&gt; {
      console.log(this)
    }
  }
}
console.log(a()()())

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的。</li><li>最后种情况也就是 <code>bind</code> 这些改变上下文的 <code>API</code> 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li><li>那么说到 <code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次 <code>bind</code>，那么上下文会是什么呢？</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // =&gt; ?

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如果你认为输出结果是 <code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次，<code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = { name: &#39;poetries&#39; }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // =&gt; &#39;poetries&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p></blockquote><blockquote><p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p></blockquote><p><img src="/assets/20220307225252.e5d5971d.png" alt=""></p><p>函数执行改变this</p><ul><li>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code>。</li></ul><blockquote><p>因此要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如</p></blockquote><ul><li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li><li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li></ul><blockquote><p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p></blockquote><ul><li><code>call: fn.call(target, 1, 2)</code></li><li><code>apply: fn.apply(target, [1, 2])</code></li><li><code>bind: fn.bind(target)(1,2)</code></li></ul><h3 id="_3-apply-call-bind-原理" tabindex="-1"><a class="header-anchor" href="#_3-apply-call-bind-原理" aria-hidden="true">#</a> 3 apply/call/bind 原理</h3><p><img src="/assets/20210414155100.ddd7ef66.png" alt=""></p><blockquote><p><code>call、apply</code> 和 <code>bind</code> 是挂在 <code>Function</code> 对象上的三个方法，调用这三个方法的必须是一个函数。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>func.call(thisArg, param1, param2, ...)
func.apply(thisArg, [param1,param2,...])
func.bind(thisArg, param1, param2, ...)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在浏览器里，在全局范围内this 指向window对象；</li><li>在函数中，this永远指向最后调用他的那个对象；</li><li>构造函数中，this指向new出来的那个新的对象；</li><li><code>call、apply、bind</code>中的this被强绑定在指定的那个对象上；</li><li>箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</li><li><code>apply、call、bind</code>都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</li></ul><p><img src="/assets/20220307225256.edc7029b.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
    value: 1
}
function getValue(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value)
}
getValue.call(a, &#39;poe&#39;, &#39;24&#39;)
getValue.apply(a, [&#39;poe&#39;, &#39;24&#39;])

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化</p></blockquote><p>方法的应用场景</p><blockquote><p>下面几种应用场景，你多加体会就可以发现它们的理念都是&quot;借用&quot;方法的思路。我们来看看都有哪些。</p></blockquote><ol><li>判断数据类型</li></ol><blockquote><p>用 <code>Object.prototype.toString</code> 来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function getType(obj){
  let type  = typeof obj;
  if (type !== &quot;object&quot;) {
    return type;
  }
  return Object.prototype.toString.call(obj).replace(/^$/, &#39;$1&#39;);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>类数组借用方法</li></ol><blockquote><p>类数组因为不是真正的数组，所有没有数组类型上自带的种种方法，所以我们就可以利用一些方法去借用数组的方法，比如借用数组的 <code>push</code> 方法，看下面的一段代码。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var arrayLike = {
  0: &#39;java&#39;,
  1: &#39;script&#39;,
  length: 2
}
Array.prototype.push.call(arrayLike, &#39;jack&#39;, &#39;lily&#39;);
console.log(typeof arrayLike); // &#39;object&#39;
console.log(arrayLike);
// {0: &quot;java&quot;, 1: &quot;script&quot;, 2: &quot;jack&quot;, 3: &quot;lily&quot;, length: 4}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>用 <code>call</code> 的方法来借用 <code>Array 原型链上的 push</code> 方法，可以实现一个<code>类数组的 push</code> 方法，给 <code>arrayLike</code> 添加新的元素</p></blockquote><ol><li>获取数组的最大 / 最小值</li></ol><blockquote><p>我们可以用 apply 来实现数组中判断最大 / 最小值，<code>apply</code> 直接传递数组作为调用方法的参数，也可以减少一步展开数组，可以直接使用 <code>Math.max、Math.min</code> 来获取数组的最大值 / 最小值，请看下面这段代码。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let arr = [13, 6, 10, 11, 16];
const max = Math.max.apply(Math, arr);
const min = Math.min.apply(Math, arr);

console.log(max);  // 16
console.log(min);  // 6

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个 bind 函数</p><p>对于实现以下几个函数，可以从几个方面思考</p><ul><li>不传入第一个参数，那么默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Function.prototype.myBind = function (context) {
  if (typeof this !== &#39;function&#39;) {
    throw new TypeError(&#39;Error&#39;)
  }
  var _this = this
  var args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个 call 函数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Function.prototype.myCall = function (context) {
  var context = context || window
  // 给 context 添加一个属性
  // getValue.call(a, &#39;pp&#39;, &#39;24&#39;) =&gt; a.fn = getValue
  context.fn = this
  // 将 context 后面的参数取出来
  var args = [...arguments].slice(1)
  // getValue.call(a, &#39;pp&#39;, &#39;24&#39;) =&gt; a.fn(&#39;pp&#39;, &#39;24&#39;)
  var result = context.fn(...args)
  // 删除 fn
  delete context.fn
  return result
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现一个 apply 函数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Function.prototype.myApply = function(context = window, ...args) {
  // this--&gt;func  context--&gt; obj  args--&gt; 传递过来的参数

  // 在context上加一个唯一值不影响context上的属性
  let key = Symbol(&#39;key&#39;)
  context[key] = this; // context为调用的上下文,this此处为函数，将这个函数作为context的方法
  // let args = [...arguments].slice(1)   //第一个参数为obj所以删除,伪数组转为数组

  let result = context[key](...args);
  delete context[key]; // 不删除会导致context属性越来越多
  return result;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 使用
function f(a,b){
 console.log(a,b)
 console.log(this.name)
}
let obj={
 name:&#39;张三&#39;
}
f.myApply(obj,[1,2])  //arguments[1]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-变量提升" tabindex="-1"><a class="header-anchor" href="#_4-变量提升" aria-hidden="true">#</a> 4 变量提升</h3><blockquote><p>当执行 <code>JS</code> 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>b() // call b
console.log(a) // undefined

var a = &#39;Hello world&#39;

function b() {
    console.log(&#39;call b&#39;)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，<code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p></blockquote><ul><li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>b() // call b second

function b() {
    console.log(&#39;call b fist&#39;)
}
function b() {
    console.log(&#39;call b second&#39;)
}
var b = &#39;Hello world&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>var</code> 会产生很多错误，所以在 ES6中引入了 <code>let</code>。<code>let</code>不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code>提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p></blockquote><h3 id="_5-执行上下文" tabindex="-1"><a class="header-anchor" href="#_5-执行上下文" aria-hidden="true">#</a> 5 执行上下文</h3><blockquote><p>当执行 JS 代码时，会产生三种执行上下文</p></blockquote><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code> 执行上下文</li></ul><blockquote><p>每个执行上下文中都有三个重要的属性</p></blockquote><ul><li>变量对象（<code>VO</code>），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li><li>作用域链（<code>JS</code> 采用词法作用域，也就是说变量的作用域是在定义时就决定了）</li><li><code>this</code></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 10
function foo(i) {
  var b = 20
}
foo()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>stack = [
    globalContext,
    fooContext
]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对于全局上下文来说，<code>VO</code>大概是这样的</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>globalContext.VO === globe
globalContext.VO = {
    a: undefined,
	foo: &lt;Function&gt;,
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对于函数 <code>foo</code> 来说，<code>VO</code> 不能访问，只能访问到活动对象（<code>AO</code>）</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>fooContext.VO === foo.AO
fooContext.AO {
    i: undefined,
	b: undefined,
    arguments: &lt;&gt;
}
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调用者

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 <code>[[Scope]]</code>属性查找上级变量</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>fooContext.[[Scope]] = [
    globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
    fooContext.VO,
    globalContext.VO
]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>接下来让我们看一个老生常谈的例子，<code>var</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>b() // call b
console.log(a) // undefined

var a = &#39;Hello world&#39;

function b() {
	console.log(&#39;call b&#39;)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 <code>VO</code>），<code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</p></blockquote><ul><li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>b() // call b second

function b() {
	console.log(&#39;call b fist&#39;)
}
function b() {
	console.log(&#39;call b second&#39;)
}
var b = &#39;Hello world&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>var</code>会产生很多错误，所以在 <code>ES6</code>中引入了 <code>let</code>。<code>let</code>不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。</p></blockquote><ul><li>对于非匿名的立即执行函数需要注意以下一点</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var foo = 1
(function foo() {
    foo = 10
    console.log(foo)
}()) // -&gt; ƒ foo() { foo = 10 ; console.log(foo) }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>因为当 <code>JS</code> 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code>，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>specialObject = {};

Scope = specialObject + Scope;

foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}

delete Scope[0]; // remove specialObject from the front of scope chain

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结</p><blockquote><p>执行上下文可以简单理解为一个对象:</p></blockquote><p>它包含三个部分:</p><ul><li>变量对象(<code>VO</code>)</li><li>作用域链(词法作用域)</li><li><code>this</code>指向</li></ul><p>它的类型:</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><p>代码执行过程:</p><ul><li>创建 全局上下文 (<code>global EC</code>)</li><li>全局执行上下文 (<code>caller</code>) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (<code>callee</code>) 被<code>push</code>到执行栈顶层</li><li>函数执行上下文被激活，成为 <code>active EC</code>, 开始执行函数中的代码，<code>caller</code> 被挂起</li><li>函数执行完后，<code>callee</code> 被<code>pop</code>移除出执行栈，控制权交还全局上下文 (<code>caller</code>)，继续执行</li></ul><h3 id="_6-作用域" tabindex="-1"><a class="header-anchor" href="#_6-作用域" aria-hidden="true">#</a> 6 作用域</h3><ul><li>作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li><li>作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。</li></ul><blockquote><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p></blockquote><ul><li>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找</li><li>作用域链的创建过程跟执行上下文的建立有关....</li></ul><blockquote><p>作用域可以理解为变量的可访问性，总共分为三种类型，分别为：</p></blockquote><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域，ES6 中的 <code>let</code>、<code>const</code> 就可以产生该作用域</li></ul><p>其实看完前面的闭包、<code>this</code> 这部分内部的话，应该基本能了解作用域的一些应用。</p><p>一旦我们将这些作用域嵌套起来，就变成了另外一个重要的知识点「作用域链」，也就是 JS 到底是如何访问需要的变量或者函数的。</p><ul><li>首先作用域链是在定义时就被确定下来的，和箭头函数里的 this 一样，后续不会改变，JS 会一层层往上寻找需要的内容。</li><li>其实作用域链这个东西我们在闭包小结中已经看到过它的实体了：<code>[[Scopes]]</code></li></ul><p><img src="/assets/20210406201055.27a4e26b.png" alt=""></p><p>图中的 <code>[[Scopes]]</code> 是个数组，作用域的一层层往上寻找就等同于遍历 <code>[[Scopes]]</code>。</p><p>1. 全局作用域</p><blockquote><p>全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var globalName = &#39;global&#39;;
function getName() {
  console.log(globalName) // global
  var name = &#39;inner&#39;
  console.log(name) // inner
}
getName();
console.log(name); //
console.log(globalName); //global
function setName(){
  vName = &#39;setName&#39;;
}
setName();
console.log(vName); // setName

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从这段代码中我们可以看到，globalName 这个变量无论在什么地方都是可以被访问到的，所以它就是全局变量。而在 getName 函数中作为局部变量的 name 变量是不具备这种能力的</li><li>当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域的问题。</li></ul><p>2. 函数作用域</p><blockquote><p>函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function getName () {
  var name = &#39;inner&#39;;
  console.log(name); //inner
}
getName();
console.log(name);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>除了这个函数内部，其他地方都是不能访问到它的。同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以你会看到在 getName 函数外面的 name 是访问不到的</p></blockquote><p>3. 块级作用域</p><blockquote><p>ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有&quot;暂时性死区&quot;的特点，也就是说这个变量在定义之前是不能被使用的。</p></blockquote><p>在 JS 编码过程中 <code>if 语句</code>及 <code>for</code> 语句后面 <code>{...}</code> 这里面所包括的，就是<code>块级作用域</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log(a) //a is not defined
if(true){
  let a = &#39;123&#39;；
  console.log(a)； // 123
}
console.log(a) //a is not defined

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从这段代码可以看出，变量 a 是在 <code>if 语句{...}</code> 中由 <code>let 关键词</code>进行定义的变量，所以它的作用域是 if 语句括号中的那部分，而在外面进行访问 a 变量是会报错的，因为这里不是它的作用域。所以在 if 代码块的前后输出 a 这个变量的结果，控制台会显示 a 并没有定义</p></blockquote><h3 id="_7-闭包" tabindex="-1"><a class="header-anchor" href="#_7-闭包" aria-hidden="true">#</a> 7 闭包</h3><blockquote><p>闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</p></blockquote><p><img src="/assets/20210414160103.ece9ed73.png" alt=""></p><p>因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。下面我们通过代码先来看一个简单的例子</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function fun1() {
	var a = 1;
	return function(){
		console.log(a);
	};
}
fun1();
var result = fun1();
result();  // 1

// 结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>闭包有两个常用的用途</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><blockquote><p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = 1
// fn 是闭包
function fn() {
  console.log(a);
}

function fn1() {
  let a = 1
  // 这里也是闭包
  return () =&gt; {
    console.log(a);
  }
}
const fn2 = fn1()
fn2()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>大家都知道闭包其中一个作用是访问私有变量，就比如上述代码中的 fn2 访问到了 fn1 函数中的变量 a。但是此时 fn1 早已销毁，我们是如何访问到变量 a 的呢？不是都说原始类型是存放在栈上的么，为什么此时却没有被销毁掉？</li><li>接下来笔者会根据浏览器的表现来重新理解关于原始类型存放位置的说法。</li><li>先来说下数据存放的正确规则是：局部、占用空间确定的数据，一般会存放在栈中，否则就在堆中（也有例外）。 那么接下来我们可以通过 Chrome 来帮助我们验证这个说法说法。</li></ul><p><img src="/assets/20210406200721.dbe4bb5f.png" alt=""></p><blockquote><p>上图中画红框的位置我们能看到一个内部的对象 <code>[[Scopes]]</code>，其中存放着变量 a，该对象是被存放在堆上的，其中包含了闭包、全局对象等等内容，因此我们能通过闭包访问到本该销毁的变量。</p></blockquote><p>另外最开始我们对于闭包的定位是：假如一个函数能访问外部的变量，那么这个函数它就是一个闭包，因此接下来我们看看在全局下的表现是怎么样的。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = 1
var b = 2
// fn 是闭包
function fn() {
  console.log(a, b);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210406200756.3a257662.png" alt=""></p><p>从上图我们能发现全局下声明的变量，如果是 var 的话就直接被挂到 globe 上，如果是其他关键字声明的话就被挂到 Script 上。虽然这些内容同样还是存在 <code>[[Scopes]]</code>，但是全局变量应该是存放在静态区域的，因为全局变量无需进行垃圾回收，等需要回收的时候整个应用都没了。</p><p>只有在下图的场景中，原始类型才可能是被存储在栈上。</p><blockquote><p>这里为什么要说可能，是因为 JS 是门动态类型语言，一个变量声明时可以是原始类型，马上又可以赋值为对象类型，然后又回到原始类型。这样频繁的在堆栈上切换存储位置，内部引擎是不是也会有什么优化手段，或者干脆全部都丢堆上？只有 const 声明的原始类型才一定存在栈上？当然这只是笔者的一个推测，暂时没有深究，读者可以忽略这段瞎想</p></blockquote><p><img src="/assets/20210406200826.e4f35fc7.png" alt=""></p><p>因此笔者对于原始类型存储位置的理解为：局部变量才是被存储在栈上，全局变量存在静态区域上，其它都存储在堆上。</p><p>当然这个理解是建立的 Chrome 的表现之上的，在不同的浏览器上因为引擎的不同，可能存储的方式还是有所变化的。</p><p>闭包产生的原因</p><blockquote><p>我们在前面介绍了作用域的概念，那么你还需要明白作用域链的基本概念。其实很简单，当访问一个变量时，代码解释器会首先在当前的作用域查找，如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，这样的链路就是作用域链</p></blockquote><p>需要注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。那么我们还是通过下面的代码来详细说明一下作用域链</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 1;
function fun1() {
  var a = 2
  function fun2() {
    var a = 3;
    console.log(a);//3
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从中可以看出，fun1 函数的作用域指向全局作用域（window）和它自己本身；fun2 函数的作用域指向全局作用域 （window）、fun1 和它本身；而作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。</li><li>那么这就很形象地说明了什么是作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。</li><li>由此可见，<code>闭包产生的本质就是：当前环境中存在指向父级作用域的引用</code>。那么还是拿上的代码举例。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function fun1() {
  var a = 2
  function fun2() {
    console.log(a);  //2
  }
  return fun2;
}
var result = fun1();
result();

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从上面这段代码可以看出，这里 result 会拿到父级作用域中的变量，输出 2。因为在当前环境中，含有对 fun2 函数的引用，fun2 函数恰恰引用了 window、fun1 和 fun2 的作用域。因此 fun2 函数是可以访问到 fun1 函数的作用域的变量。</li><li>那是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此还可以这么改代码，如下所示</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var fun3;
function fun1() {
  var a = 2
  fun3 = function() {
    console.log(a);
  }
}
fun1();
fun3();

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>可以看出，其中实现的结果和前一段代码的效果其实是一样的，就是在给 fun3 函数赋值后，fun3 函数就拥有了 window、fun1 和 fun3 本身这几个作用域的访问权限；然后还是从下往上查找，直到找到 fun1 的作用域中存在 a 这个变量；因此输出的结果还是 2，最后产生了闭包，形式变了，本质没有改变。</p></blockquote><p>因此最后<code>返回的不管是不是函数，也都不能说明没有产生闭包</code></p><p>闭包的表现形式</p><ol><li>返回一个函数</li><li><code>在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包</code>。请看下面这段代码，这些都是平常开发中用到的形式</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 定时器
setTimeout(function handler(){
  console.log(&#39;1&#39;);
}，1000);
// 事件监听
$(&#39;#app&#39;).click(function(){
  console.log(&#39;Event Listener&#39;);
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>作为函数参数传递的形式，比如下面的例子。</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 1;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  bar(baz);
}
function bar(fn){
  // 这就是闭包
  fn();
}
foo();  // 输出2，而不是1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><code>IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域</code>，因此可以输出全局的变量，如下所示</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 2;
(function IIFE(){
  console.log(a);  // 输出2
})();

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。</p></blockquote><p>如何解决循环输出问题？</p><blockquote><p>在互联网大厂的面试中，解决循环输出问题是比较高频的面试题，一般都会给一段这样的代码让你来解释</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for(var i = 1; i &lt;= 5; i ++){
  setTimeout(function() {
    console.log(i)
  }, 0)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段代码执行之后，从控制台执行的结果可以看出来，结果输出的是 5 个 6，那么一般面试官都会先问为什么都是 6？我想让你实现输出 1、2、3、4、5 的话怎么办呢？</p><p>因此结合本讲所学的知识我们来思考一下，应该怎么给面试官一个满意的解释。你可以围绕这两点来回答。</p><ul><li><code>setTimeout</code> 为宏任务，由于 JS 中单线程 <code>eventLoop 机制</code>，在主线程同步任务执行完后才去执行宏任务，因此<code>循环结束后 setTimeout 中的回调才依次执行</code></li><li>因为 <code>setTimeout</code> 函数也是一种闭包，往上找它的<code>父级作用域链就是 window</code>，<code>变量 i 为 window 上的全局变量</code>，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</li></ul><blockquote><p>那么我们再来看看如何按顺序依次输出 1、2、3、4、5 呢？</p></blockquote><ol><li>利用 IIFE</li></ol><blockquote><p>可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for(var i = 1;i &lt;= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>使用 ES6 中的 let</li></ol><blockquote><p>ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。通过改造后的代码，可以实现上面想要的结果。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for(let i = 1; i &lt;= 5; i++){
  setTimeout(function() {
    console.log(i);
  },0)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>定时器传入第三个参数</li></ol><blockquote><p>setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，而第三个参数用得比较少。那么结合第三个参数，调整完之后的代码如下。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for(var i=1;i&lt;=5;i++){
  setTimeout(function(j) {
    console.log(j)
  }, 0, i)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径</p><p>常见考点</p><ul><li>闭包能考的很多，概念和笔试题都会考。</li><li>概念题就是考考闭包是什么了。</li><li>笔试题的话基本都会结合上异步，比如最常见的：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for (var i = 0; i &lt; 6; i++) {
  setTimeout(() =&gt; {
    console.log(i)
  })
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这道题会问输出什么，有哪几种方式可以得到想要的答案？</p><h3 id="_8-new的原理" tabindex="-1"><a class="header-anchor" href="#_8-new的原理" aria-hidden="true">#</a> 8 New的原理</h3><p>常见考点</p><ul><li><code>new</code> 做了那些事？</li><li><code>new</code> 返回不同的类型时会有什么表现？</li><li>手写 new 的实现过程</li></ul><blockquote><p>new 关键词的<code>主要作用就是执行一个构造函数、返回一个实例对象</code>，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。下面我们通过一段代码来看一个简单的 new 的例子</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){
   this.name = &#39;Jack&#39;;
}
var p = new Person();
console.log(p.name)  // Jack

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码比较容易理解，从输出结果可以看出，p 是一个通过 person 这个构造函数生成的一个实例对象，这个应该很容易理解。</p><blockquote><p><code>new</code> 操作符可以帮助我们构建出一个实例，并且绑定上 this，内部执行步骤可大概分为以下几步：</p></blockquote><ol><li>创建一个新对象</li><li>对象连接到构造函数原型上，并绑定 <code>this</code>（this 指向新对象）</li><li>执行构造函数代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>在第四步返回新对象这边有一个情况会例外：</p><blockquote><p>那么问题来了，如果不用 <code>new</code> 这个关键词，结合上面的代码改造一下，去掉 <code>new</code>，会发生什么样的变化呢？我们再来看下面这段代码</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){
  this.name = &#39;Jack&#39;;
}
var p = Person();
console.log(p) // undefined
console.log(name) // Jack
console.log(p.name) // &#39;name&#39; of undefined

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从上面的代码中可以看到，我们没有使用 <code>new</code> 这个关键词，返回的结果就是 <code>undefined</code>。其中由于 <code>JavaScript</code> 代码在默认情况下 <code>this</code> 的指向是 <code>window</code>，那么 <code>name</code> 的输出结果就为 <code>Jack</code>，这是一种不存在 <code>new</code> 关键词的情况。</li><li>那么当构造函数中有 <code>return</code> 一个对象的操作，结果又会是什么样子呢？我们再来看一段在上面的基础上改造过的代码。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){
   this.name = &#39;Jack&#39;;
   return {age: 18}
}
var p = new Person();
console.log(p)  // {age: 18}
console.log(p.name) // undefined
console.log(p.age) // 18

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>通过这段代码又可以看出，当构造函数最后 <code>return</code> 出来的是一个和 <code>this</code> 无关的对象时，<code>new 命令会直接返回这个新对象</code>，<code>而不是通过 new 执行步骤生成的 this 对象</code></p></blockquote><p>但是这里要求构造函数必须是返回一个对象，<code>如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象</code>。接下来还是在上面这段代码的基础之上稍微改动一下</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){
   this.name = &#39;Jack&#39;;
   return &#39;tom&#39;;
}
var p = new Person();
console.log(p)  // {name: &#39;Jack&#39;}
console.log(p.name) // Jack

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，当构造函数中 <code>return</code> 的不是一个对象时，那么它还是会根据 <code>new</code> 关键词的执行逻辑，生成一个新的对象（绑定了最新 <code>this</code>），最后返回出来</p><blockquote><p>因此我们总结一下：<code>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象</code></p></blockquote><p><img src="/assets/20210414151626.d6a59dd8.png" alt=""></p><p>手工实现New的过程</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function create(fn, ...args) {
  if(typeof fn !== &#39;function&#39;) {
    throw &#39;fn must be a function&#39;;
  }
	// 1、用new Object() 的方式新建了一个对象obj
  // var obj = new Object()
	// 2、给该对象的__proto__赋值为fn.prototype，即设置原型链
  // obj.__proto__ = fn.prototype

  // 1、2步骤合并
  // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性
  // 即实现 obj.__proto__ === constructor.prototype
  var obj = Object.create(fn.prototype);

	// 3、执行fn，并将obj作为内部this。使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性
  var res = fn.apply(obj, args);
	// 4、如果fn有返回值，则将其作为new操作返回内容，否则返回obj
	return res instanceof Object ? res : obj;
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用 <code>Object.create</code> 将 <code>obj 的</code>proto<code>指向为构造函数的原型</code>；</li><li>使用 <code>apply</code> 方法，将构造函数内的 <code>this</code> 指向为 <code>obj</code>；</li><li>在 <code>create</code> 返回时，使用三目运算符决定返回结果。</li></ul><p>我们知道，<code>构造函数如果有显式返回值，且返回值为对象类型，那么构造函数返回结果不再是目标实例</code></p><p>如下代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name) {
  this.name = name
  return {1: 1}
}
const person = new Person(Person, &#39;lucas&#39;)
console.log(person)
// {1: 1}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//使用create代替new
function Person() {...}
// 使用内置函数new
var person = new Person(1,2)

// 使用手写的new，即create
var person = create(Person, 1,2)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>new 被调用后大致做了哪几件事情</p><ul><li>让实例可以访问到私有属性；</li><li>让实例可以访问构造函数原型（<code>constructor.prototype</code>）所在原型链上的属性；</li><li>构造函数返回的最后结果是引用数据类型。</li></ul><h3 id="_9-原型-原型链" tabindex="-1"><a class="header-anchor" href="#_9-原型-原型链" aria-hidden="true">#</a> 9 原型/原型链</h3><p><code>__proto__</code>和prototype关系：<code>__proto__</code>和<code>constructor</code>是对象独有的。2️⃣<code>prototype</code>属性是函数独有的</p><blockquote><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 <code>Object.getPrototypeOf()</code> 方法，我们可以通过这个方法来获取对象的原型。</p></blockquote><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <code>Object.prototype</code> 所以这就是我们新建的对象为什么能够使用 <code>toString()</code> 等方法的原因。</p><blockquote><p>特点：JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变</p></blockquote><ul><li>原型(<code>prototype</code>): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 <code>Firefox</code> 和 <code>Chrome</code> 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code>(非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</li><li>构造函数: 可以通过<code>new</code>来 新建一个对象 的函数。</li><li>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li></ul><blockquote><p>以<code>Object</code>为例，我们常用的<code>Object</code>便是一个构造函数，因此我们可以通过它构建实例。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 实例
const instance = new Object()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>则此时， 实例为<code>instance</code>, 构造函数为<code>Object</code>，我们知道，构造函数拥有一个<code>prototype</code>的属性指向原型，因此原型为:</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 原型
const prototype = Object.prototype

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们可以来看出三者的关系:</p><ul><li><code>实例.__proto__ === 原型</code></li><li><code>原型.constructor === 构造函数</code></li><li><code>构造函数.prototype === 原型</code></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如:
// const o = new Object()
// o.constructor === Object   --&gt; true
// o.__proto__ = null;
// o.constructor === Object   --&gt; false
实例.constructor === 构造函数

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20220307225112.c8cd19da.png" alt=""></p><p>原型链</p><blockquote><p>原型链是由原型对象组成，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链</p></blockquote><ul><li>属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><p>js 获取原型的方法</p><ul><li><code>p.proto</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><p>总结</p><p><img src="/assets/20220307225105.c4752ae1.png" alt=""></p><ul><li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li><li>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code>是内部属性，我们并不能访问到，所以使用 <code>_proto_</code>来访问。</li><li>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li></ul><h3 id="_10-继承" tabindex="-1"><a class="header-anchor" href="#_10-继承" aria-hidden="true">#</a> 10 继承</h3><p><img src="/assets/20210414142754.f006d629.png" alt=""></p><blockquote><p>涉及面试题：原型如何实现继承？<code>Class</code> 如何实现继承？<code>Class</code> 本质是什么？</p></blockquote><p>首先先来讲下 <code>class</code>，其实在 <code>JS</code>中并不存在类，<code>class</code> 只是语法糖，本质还是函数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Person {}
Person instanceof Function // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组合继承</p><blockquote><p>组合继承是最常用的继承方式</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>以上继承的方式核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</li><li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li></ul><p>寄生组合继承</p><blockquote><p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></blockquote><p>Class 继承</p><blockquote><p>以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>class</code> 实现继承的核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。</p></blockquote><p>ES5 和 ES6 继承的区别：</p><ul><li>ES6 继承的子类需要调用 <code>super()</code> 才能拿到子类，ES5 的话是通过 <code>apply</code> 这种绑定的方式</li><li>类声明不会提升，和 <code>let</code> 这些一致</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Super() {}
Super.prototype.getNumber = function() {
  return 1
}

function Sub() {}
Sub.prototype = Object.create(Super.prototype, {
  constructor: {
    value: Sub,
    enumerable: false,
    writable: true,
    configurable: true
  }
})
let s = new Sub()
s.getNumber()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>以下详细讲解几种常见的继承方式</p></blockquote><p>1. 方式1: 借助call</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> function Parent1(){
    this.name = &#39;parent1&#39;;
  }
  function Child1(){
    Parent1.call(this);
    this.type = &#39;child1&#39;
  }
  console.log(new Child1);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p></blockquote><p>2. 方式2: 借助原型链</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> function Parent2() {
    this.name = &#39;parent2&#39;;
    this.play = [1, 2, 3]
  }
  function Child2() {
    this.type = &#39;child2&#39;;
  }
  Child2.prototype = new Parent2();

  console.log(new Child2());

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var s1 = new Child2();
var s2 = new Child2();
s1.play.push(4);
console.log(s1.play, s2.play);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到控制台：</p><p><img src="/assets/20210309103243.772341e2.png" alt=""></p><blockquote><p>明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。</p></blockquote><p>那么还有更好的方式么？</p><p>3. 方式3：将前两种组合</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>  function Parent3 () {
    this.name = &#39;parent3&#39;;
    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = &#39;child3&#39;;
  }
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3.play, s4.play);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到控制台：</p><p><img src="/assets/20210309103312.eb7d3aa8.png" alt=""></p><blockquote><p>之前的问题都得以解决。但是这里又徒增了一个新问题，那就是<code>Parent3</code>的构造函数会多执行了一次（<code>Child3.prototype = new Parent3();</code>）。这是我们不愿看到的。那么如何解决这个问题？</p></blockquote><p>4. 方式4: 组合继承的优化1</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>  function Parent4 () {
    this.name = &#39;parent4&#39;;
    this.play = [1, 2, 3];
  }
  function Child4() {
    Parent4.call(this);
    this.type = &#39;child4&#39;;
  }
  Child4.prototype = Parent4.prototype;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var s3 = new Child4();
var s4 = new Child4();
console.log(s3)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210309103358.817e73a0.png" alt=""></p><blockquote><p>子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。</p></blockquote><p>5. 方式5(最推荐使用): 组合继承的优化2</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> function Parent5 () {
    this.name = &#39;parent5&#39;;
    this.play = [1, 2, 3];
  }
  function Child5() {
    Parent5.call(this);
    this.type = &#39;child5&#39;;
  }
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。</p><p>6. ES6的extends被编译后的JavaScript代码</p><blockquote><p>ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。</p></blockquote><p>那最后编译成了什么样子呢？</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function _possibleConstructorReturn(self, call) {
    // ...
    return call &amp;&amp; (typeof call === &#39;object&#39; || typeof call === &#39;function&#39;) ? call : self;
}

function _inherits(subClass, superClass) {
    // ...
    //看到没有
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Parent = function Parent() {
    // 验证是否是 Parent 构造出来的 this
    _classCallCheck(this, Parent);
};

var Child = (function (_Parent) {
    _inherits(Child, _Parent);

    function Child() {
        _classCallCheck(this, Child);

        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));
    }

    return Child;
}(Parent));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>核心是<code>_inherits</code>函数，可以看到它采用的依然也是第五种方式------------寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个<code>Object.setPrototypeOf(subClass, superClass)</code>，这是用来干啥的呢？</p></blockquote><p>答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。</p><p>追问: 面向对象的设计一定是好的设计吗？</p><blockquote><p>不一定。从继承的角度说，这一设计是存在巨大隐患的。</p></blockquote><h3 id="_11-面向对象" tabindex="-1"><a class="header-anchor" href="#_11-面向对象" aria-hidden="true">#</a> 11 面向对象</h3><p>编程思想</p><ul><li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li><li>优点 <ul><li>易维护 <ul><li>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的</li></ul></li><li>易扩展</li><li>开发工作的重用性、继承性高，降低重复工作量。</li><li>缩短了开发周期</li></ul></li></ul><blockquote><p>一般面向对象包含：继承，封装，多态，抽象</p></blockquote><p>1. 对象形式的继承</p><p>浅拷贝</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var Person = {
    name: &#39;poetry&#39;,
    age: 18,
    address: {
        home: &#39;home&#39;,
        office: &#39;office&#39;,
    }
    sclools: [&#39;x&#39;,&#39;z&#39;],
};

var programer = {
    language: &#39;js&#39;,
};

function extend(p, c){
    var c = c || {};
    for( var prop in p){
        c[prop] = p[prop];
    }
}
extend(Person, programer);
programer.name;  // poetry
programer.address.home;  // home
programer.address.home = &#39;house&#39;;  //house
Person.address.home;  // house

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本</p></blockquote><p>深拷贝</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function extendDeeply(p, c){
    var c = c || {};
    for (var prop in p){
        if(typeof p[prop] === &quot;object&quot;){
            c[prop] = (p[prop].constructor === Array)?[]:{};
            extendDeeply(p[prop], c[prop]);
        }else{
            c[prop] = p[prop];
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>利用递归进行深拷贝，这样子对象的修改就不会影响到父对象</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>extendDeeply(Person, programer);
programer.address.home = &#39;poetry&#39;;
Person.address.home; // home

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>利用call和apply继承</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Parent(){
    this.name = &quot;abc&quot;;
    this.address = {home: &quot;home&quot;};
}
function Child(){
    Parent.call(this);
    this.language = &quot;js&quot;;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES5中的Object.create()</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var p = { name : &#39;poetry&#39;};
var obj = Object.create(p);
obj.name; // poetry

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>Object.create()</code>作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//模拟Object.create()方法
function myCreate(o){
    function F(){};
    F.prototype = o;
    o = new F();
    return o;
}
var p = { name : &#39;poetry&#39;};
var obj = myCreate(p);
obj.name; // poetry

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>　if (!Object.create) {
　　　　Object.create = function (o) {
　　　　　　 function F() {}
　　　　　　F.prototype = o;
　　　　　　return new F();
　　　　};
　　}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2. 类的继承</p><blockquote><p><code>Object.create()</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age){}
Person.prototype.headCount = 1;
Person.prototype.eat = function(){
    console.log(&#39;eating...&#39;);
}
function Programmer(name, age, title){}

Programmer.prototype = Object.create(Person.prototype); //建立继承关系
Programmer.prototype.constructor = Programmer;  // 修改constructor的指向

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用父类方法</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age){
    this.name = name;
    this.age = age;
}
Person.prototype.headCount = 1;
Person.prototype.eat = function(){
    console.log(&#39;eating...&#39;);
}

function Programmer(name, age, title){
    Person.apply(this, arguments); // 调用父类的构造器
}

Programmer.prototype = Object.create(Person.prototype);
Programmer.prototype.constructor = Programmer;

Programmer.prototype.language = &quot;js&quot;;
Programmer.prototype.work = function(){
    console.log(&#39;i am working code in &#39;+ this.language);
    Person.prototype.eat.apply(this, arguments); // 调用父类上的方法
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3. 封装</p><ul><li>命名空间 <ul><li>js是没有命名空间的，因此可以用对象模拟</li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var app = {};  // 命名空间app
//模块1
app.module1 = {
    name: &#39;poetry&#39;,
    f: function(){
        console.log(&#39;hi robot&#39;);
    }
};
app.module1.name; // &quot;poetry&quot;
app.module1.f();  // hi robot

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对象的属性外界是可读可写 如何来达到封装的额目的？答：可通过<code>闭包+局部变量</code>来完成</p></blockquote><ul><li>在构造函数内部声明局部变量 和普通方法</li><li>因为作用域的关系 只有构造函数内的方法</li><li>才能访问局部变量 而方法对于外界是开放的</li><li>因此可以通过方法来访问 原本外界访问不到的局部变量 达到函数封装的目的</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Girl(name,age){
	var love = &#39;小明&#39;;//love 是局部变量 准确说不属于对象 属于这个函数的额激活对象 函数调用时必将产生一个激活对象 love在激活对象身上   激活对象有作用域的关系 有办法访问  加一个函数提供外界访问
	this.name = name;
	this.age = age;
	this.say = function () {
		return love;
	};

	this.movelove = function (){
		love = &#39;小轩&#39;; //35
	}

}

var g = new Girl(&#39;yinghong&#39;,22);

console.log(g);
console.log(g.say());//小明
console.log(g.movelove());//undefined  因为35行没有返回
console.log(g.say());//小轩

function fn(){
	function t(){
		//var age = 22;//声明age变量 在t的激活对象上
		age = 22;//赋值操作 t的激活对象上找age属性 ，找不到 找fn的激活对象....再找到 最终找到window.age = 22;
				//不加var就是操作window全局属性

	}
	t();
}
console.log(fn());//undefined

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4. 静态成员</p><blockquote><p>面向对象中的静态方法-静态属性：没有new对象 也能引用静态方法属性</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name){
    var age = 100;
    this.name = name;
}
//静态成员
Person.walk = function(){
    console.log(&#39;static&#39;);
};
Person.walk();  // static

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5. 私有与公有</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(id){
    // 私有属性与方法
    var name = &#39;poetry&#39;;
    var work = function(){
        console.log(this.id);
    };
    //公有属性与方法
    this.id = id;
    this.say = function(){
        console.log(&#39;say hello&#39;);
        work.call(this);
    };
};
var p1 = new Person(123);
p1.name; // undefined
p1.id;  // 123
p1.say();  // say hello 123

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6. 模块化</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var moduleA;
moduleA = function() {
    var prop = 1;

    function func() {}

    return {
        func: func,
        prop: prop
    };
}(); // 立即执行匿名函数

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7. 多态</p><blockquote><p>多态:同一个父类继承出来的子类各有各的形态</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Cat(){
	this.eat = &#39;肉&#39;;
}

function Tiger(){
	this.color = &#39;黑黄相间&#39;;
}

function Cheetah(){
	this.color = &#39;报文&#39;;
}

function Lion(){
	this.color = &#39;土黄色&#39;;
}

Tiger.prototype =  Cheetah.prototype = Lion.prototype = new Cat();//共享一个祖先 Cat

var T = new Tiger();
var C = new Cheetah();
var L = new Lion();

console.log(T.color);
console.log(C.color);
console.log(L.color);

console.log(T.eat);
console.log(C.eat);
console.log(L.eat);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>8. 抽象类</p><blockquote><p>在构造器中 <code>throw new Error(&#39;&#39;)</code>; 抛异常。这样防止这个类被直接调用</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function DetectorBase() {
    throw new Error(&#39;Abstract class can not be invoked directly!&#39;);
}

DetectorBase.prototype.detect = function() {
    console.log(&#39;Detection starting...&#39;);
};
DetectorBase.prototype.stop = function() {
    console.log(&#39;Detection stopped.&#39;);
};
DetectorBase.prototype.init = function() {
    throw new Error(&#39;Error&#39;);
};

// var d = new DetectorBase();
// Uncaught Error: Abstract class can not be invoked directly!

function LinkDetector() {}
LinkDetector.prototype = Object.create(DetectorBase.prototype);
LinkDetector.prototype.constructor = LinkDetector;

var l = new LinkDetector();
console.log(l); //LinkDetector {}__proto__: LinkDetector
l.detect(); //Detection starting...
l.init(); //Uncaught Error: Error

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_12-事件机制" tabindex="-1"><a class="header-anchor" href="#_12-事件机制" aria-hidden="true">#</a> 12 事件机制</h3><blockquote><p>涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？</p></blockquote><p>1. 简介</p><blockquote><p>事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在<code>DOM</code>中两种不同的传播方法</p></blockquote><p>事件流有三个阶段</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p>事件捕获</p><blockquote><p>事件捕获（<code>event capturing</code>）：通俗的理解就是，当鼠标点击或者触发<code>dom</code>事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p></blockquote><p>事件冒泡</p><blockquote><p>事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点</p></blockquote><p>无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播</p><p><img src="/assets/20220307225319.9f90eea5.png" alt=""></p><p>2. 捕获和冒泡</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;div1&quot;&gt;
  &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    let div1 = document.getElementById(&#39;div1&#39;);
    let div2 = document.getElementById(&#39;div2&#39;);

    div1.onClick = function(){
        alert(&#39;1&#39;)
    }

    div2.onClick = function(){
        alert(&#39;2&#39;);
    }

&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>当点击 <code>div2</code>时，会弹出两个弹出框。在 <code>ie8/9/10</code>、<code>chrome</code>浏览器，会先弹出&quot;2&quot;再弹出&quot;1&quot;，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反</p></blockquote><blockquote><p>W3C的标准是先捕获再冒泡， <code>addEventListener</code>的第三个参数决定把事件注册在捕获（<code>true</code>）还是冒泡(<code>false</code>)</p></blockquote><p>3. 事件对象</p><p><img src="/assets/20220307225320.6d0222b2.png" alt=""></p><p>4. 事件流阻止</p><blockquote><p>在一些情况下需要阻止事件流的传播，阻止默认动作的发生</p></blockquote><ul><li><code>event.preventDefault()</code>：取消事件对象的默认动作以及继续传播。</li><li><code>event.stopPropagation()/ event.cancelBubble = true</code>：阻止事件冒泡。</li></ul><p>事件的阻止在不同浏览器有不同处理</p><ul><li>在<code>IE</code>下使用 <code>event.returnValue= false</code>，</li><li>在非<code>IE</code>下则使用 <code>event.preventDefault()</code>进行阻止</li></ul><p>preventDefault与stopPropagation的区别</p><ul><li><code>preventDefault</code>告诉浏览器不用执行与事件相关联的默认动作（如表单提交）</li><li><code>stopPropagation</code>是停止事件继续冒泡，但是对IE9以下的浏览器无效</li></ul><p>5. 事件注册</p><ul><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code>。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>node.addEventListener(&#39;click&#39;,(event) =&gt;{
	event.stopImmediatePropagation()
	console.log(&#39;冒泡&#39;)
},false);
// 点击 node 只会执行上面的函数，该函数不会执行
node.addEventListener(&#39;click&#39;,(event) =&gt; {
	console.log(&#39;捕获 &#39;)
},true)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6. 事件委托</p><ul><li>在<code>js</code>中性能优化的其中一个主要思想是减少<code>dom</code>操作。</li><li>节省内存</li><li>不需要给子节点注销事件</li></ul><blockquote><p>假设有<code>100</code>个<code>li</code>，每个<code>li</code>有相同的点击事件。如果为每<code>个Li</code>都添加事件，则会造成<code>dom</code>访问次数过多，引起浏览器重绘与重排的次数过多，性能则会降低。 使用事件委托则可以解决这样的问题</p></blockquote><p>原理</p><blockquote><p>实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的<code>ul</code>、<code>li</code>、<code>a</code>的点击事件都会冒泡到最外层节点上，委托它代为执行事件</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;ul id=&quot;ul&quot;&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;
window.onload = function(){
    var ulEle = document.getElementById(&#39;ul&#39;);
    ul.onclick = function(ev){
        //兼容IE
        ev = ev || window.event;
        var target = ev.target || ev.srcElement;

        if(target.nodeName.toLowerCase() == &#39;li&#39;){
            alert( target.innerHTML);
        }

    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_13-模块化" tabindex="-1"><a class="header-anchor" href="#_13-模块化" aria-hidden="true">#</a> 13 模块化</h3><blockquote><p>js 中现在比较成熟的有四种模块加载方案：</p></blockquote><ul><li>第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</li><li>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范</li><li>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</li><li>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块</li></ul><blockquote><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code>的模块化</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// file a.js
export function a() {}
export function b() {}
// file b.js
export default function() {}

import {a, b} from &#39;./a.js&#39;
import XXX from &#39;./b.js&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CommonJS</p><blockquote><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code>解析了。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require(&#39;./a.js&#39;)
module.a // -&gt; log 1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var module = require(&#39;./a.js&#39;)
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// 基本实现
var module = {
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>再来说说 <code>module.exports</code> 和<code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p></blockquote><blockquote><p>对于 <code>CommonJS</code> 和 <code>ES6</code> 中的模块化的两者区别是：</p></blockquote><ul><li>前者支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。</li><li>而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。</li><li>但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 <code>require/exports</code> 来执行的</li></ul><p>AMD</p><blockquote><p><code>AMD</code> 是由 <code>RequireJS</code> 提出的</p></blockquote><p>AMD 和 CMD 规范的区别？</p><ul><li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li><li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// CMD
define(function(require, exports, module) {
  var a = require(&quot;./a&quot;);
  a.doSomething();
  // 此处略去 100 行
  var b = require(&quot;./b&quot;); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>AMD：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li><li>CMD：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li><li>CommonJs：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li><li>ES6 Module：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ul><p>谈谈对模块化开发的理解</p><ul><li>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</li><li>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</li><li>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</li><li>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</li></ul><h3 id="_14-iterator迭代器" tabindex="-1"><a class="header-anchor" href="#_14-iterator迭代器" aria-hidden="true">#</a> 14 Iterator迭代器</h3><blockquote><p><code>Iterator</code>（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署<code>Iterator</code>接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p></blockquote><p>Iterator语法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const obj = {
    [Symbol.iterator]:function(){}
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>[Symbol.iterator]</code> 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。</p></blockquote><ul><li>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据</li><li>每一次的 <code>next</code> 都会返回一个对象，该对象有两个属性 <ul><li><code>value</code> 代表想要获取的数据</li><li><code>done</code> 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束</li></ul></li></ul><p>Iterator 的作用有三个：</p><ul><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ul><blockquote><p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let arr = [{num:1},2,3]
let it = arr[Symbol.iterator]() // 获取数组中的迭代器
console.log(it.next())  // { value: Object { num: 1 }, done: false }
console.log(it.next())  // { value: 2, done: false }
console.log(it.next())  // { value: 3, done: false }
console.log(it.next())  // { value: undefined, done: true }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对象没有布局Iterator接口，无法使用<code>for of</code> 遍历。下面使得对象具备Iterator接口</p></blockquote><ul><li>一个数据结构只要有Symbol.iterator属性，就可以认为是&quot;可遍历的&quot;</li><li>原型部署了Iterator接口的数据结构有三种，具体包含四种，分别是数组，类似数组的对象，Set和Map结构</li></ul><p>为什么对象（Object）没有部署Iterator接口呢？</p><ul><li>一是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。然而遍历遍历器是一种线性处理，对于非线性的数据结构，部署遍历器接口，就等于要部署一种线性转换</li><li>对对象部署<code>Iterator</code>接口并不是很必要，因为<code>Map</code>弥补了它的缺陷，又正好有<code>Iteraotr</code>接口</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let obj = {
    id: &#39;123&#39;,
    name: &#39;张三&#39;,
    age: 18,
    gender: &#39;男&#39;,
    hobbie: &#39;睡觉&#39;
}

obj[Symbol.iterator] = function () {
    let keyArr = Object.keys(obj)
    let index = 0
    return {
        next() {
            return index &lt; keyArr.length ? {
                value: {
                    key: keyArr[index],
                    val: obj[keyArr[index++]]
                }
            } : {
                done: true
            }
        }
    }
}

for (let key of obj) {
  console.log(key)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210407141323.f0d258c4.png" alt=""></p><h3 id="_15-promise" tabindex="-1"><a class="header-anchor" href="#_15-promise" aria-hidden="true">#</a> 15 Promise</h3><blockquote><p>这里你谈 <code>promise</code>的时候，除了将他解决的痛点以及常用的 <code>API</code> 之外，最好进行拓展把 <code>eventloop</code> 带进来好好讲一下，<code>microtask</code>(微任务)、<code>macrotask</code>(任务) 的执行顺序，如果看过 <code>promise</code> 源码，最好可以谈一谈 原生 <code>Promise</code> 是如何实现的。<code>Promise</code> 的关键点在于<code>callback</code> 的两个参数，一个是 <code>resovle</code>，一个是 <code>reject</code>。还有就是 <code>Promise</code> 的链式调用（<code>Promise.then()</code>，每一个 <code>then</code> 都是一个责任人）</p></blockquote><ul><li><code>Promise</code> 是 <code>ES6</code> 新增的语法，解决了回调地狱的问题。</li><li>可以把 <code>Promise</code>看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code>，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</li><li><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。 对于 <code>then</code> 来说，本质上可以把它看成是 <code>flatMap</code></li></ul><p>1. Promise 的基本情况</p><blockquote><p>简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息</p></blockquote><p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p><ul><li>待定（<code>pending</code>）：初始状态，既没有被完成，也没有被拒绝。</li><li>已完成（<code>fulfilled</code>）：操作成功完成。</li><li>已拒绝（<code>rejected</code>）：操作失败。</li></ul><blockquote><p>待定状态的 <code>Promise</code> 对象执行的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生时，我们用 <code>Promise</code> 的 <code>then</code> 方法排列起来的相关处理程序就会被调用。因为最后 <code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code> 方法返回的是一个 <code>Promise</code>， 所以它们可以继续被链式调用</p></blockquote><p>关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况</p><p><img src="/assets/20210414175500.b182bb42.png" alt=""></p><p>从上图可以看出，我们最开始创建一个新的 <code>Promise</code> 返回给 <code>p1</code> ，然后开始执行，状态是 pending，当执行 <code>resolve</code>之后状态就切换为 <code>fulfilled</code>，执行 <code>reject</code> 之后就变为 <code>rejected</code> 的状态</p><p>2. Promise 的静态方法</p><ul><li><code>all 方法</code><ul><li>语法： <code>Promise.all（iterable）</code></li><li>参数： 一个可迭代对象，如 <code>Array</code>。</li><li>描述： 此方法对于汇总多个 <code>promise</code> 的结果很有用，在 ES6 中可以将多个 <code>Promise.all</code> 异步请求并行操作，返回结果一般有下面两种情况。 <ul><li>当所有结果成功返回时按照请求顺序返回成功结果。</li><li>当其中有一个失败方法时，则进入失败方法</li></ul></li></ul></li><li>我们来看下业务的场景，对于下面这个业务场景页面的加载，将多个请求合并到一起，用 all 来实现可能效果会更好，请看代码片段</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。

//1.获取轮播数据列表
function getBannerList(){
  return new Promise((resolve,reject)=&gt;{
      setTimeout(function(){
        resolve(&#39;轮播数据&#39;)
      },300)
  })
}
//2.获取店铺列表
function getStoreList(){
  return new Promise((resolve,reject)=&gt;{
    setTimeout(function(){
      resolve(&#39;店铺数据&#39;)
    },500)
  })
}
//3.获取分类列表
function getCategoryList(){
  return new Promise((resolve,reject)=&gt;{
    setTimeout(function(){
      resolve(&#39;分类数据&#39;)
    },700)
  })
}
function initLoad(){
  Promise.all([getBannerList(),getStoreList(),getCategoryList()])
  .then(res=&gt;{
    console.log(res)
  }).catch(err=&gt;{
    console.log(err)
  })
}
initLoad()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>allSettled</code> 方法 <ul><li><code>Promise.allSettled</code> 的语法及参数跟 <code>Promise.all</code> 类似，其参数接受一个 <code>Promise</code> 的数组，返回一个新的 <code>Promise</code>。<code>唯一的不同在于，执行完之后不会失败</code>，也就是说当 <code>Promise.allSettled</code> 全部处理完成后，我们可以拿到每个 <code>Promise</code> 的状态，而不管其是否处理成功</li></ul></li><li>我们来看一下用 <code>allSettled</code> 实现的一段代码</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const resolved = Promise.resolve(2);
const rejected = Promise.reject(-1);
const allSettledPromise = Promise.allSettled([resolved, rejected]);
allSettledPromise.then(function (results) {
  console.log(results);
});
// 返回结果：
// [
//    { status: &#39;fulfilled&#39;, value: 2 },
//    { status: &#39;rejected&#39;, reason: -1 }
// ]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从上面代码中可以看到，<code>Promise.allSettled</code> 最后返回的是一个数组，记录传进来的参数中每个 Promise 的返回值，这就是和 all 方法不太一样的地方。</p></blockquote><ul><li><code>any</code> 方法 <ul><li>语法： <code>Promise.any（iterable）</code></li><li>参数： <code>iterable</code> 可迭代的对象，例如 <code>Array</code>。</li><li>描述： <code>any</code> 方法返回一个 <code>Promise</code>，只要参数 <code>Promise</code> 实例有一个变成 <code>fulfilled</code>状态，最后 <code>any</code>返回的实例就会变成 <code>fulfilled</code> 状态；如果所有参数 <code>Promise</code> 实例都变成 <code>rejected</code> 状态，包装实例就会变成 <code>rejected</code> 状态。</li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const resolved = Promise.resolve(2);
const rejected = Promise.reject(-1);
const anyPromise = Promise.any([resolved, rejected]);
anyPromise.then(function (results) {
  console.log(results);
});
// 返回结果：
// 2

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从改造后的代码中可以看出，只要其中一个 <code>Promise</code> 变成 <code>fulfilled</code>状态，那么 <code>any</code> 最后就返回这个<code>p romise</code>。由于上面 <code>resolved</code> 这个 Promise 已经是 <code>resolve</code> 的了，故最后返回结果为 <code>2</code></p></blockquote><ul><li><code>race</code> 方法 <ul><li>语法： <code>Promise.race（iterable）</code></li><li>参数： <code>iterable</code> 可迭代的对象，例如 <code>Array</code>。</li><li>描述： <code>race</code>方法返回一个 <code>Promise</code>，只要参数的 <code>Promise</code> 之中有一个实例率先改变状态，则 <code>race</code> 方法的返回状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 <code>race</code> 方法的回调函数</li></ul></li><li>我们来看一下这个业务场景，对于图片的加载，特别适合用 race 方法来解决，将图片请求和超时判断放到一起，用 race 来实现图片的超时判断。请看代码片段。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//请求某个图片资源
function requestImg(){
  var p = new Promise(function(resolve, reject){
    var img = new Image();
    img.onload = function(){ resolve(img); }
    img.src = &#39;http://www.baidu.com/img/flexible/logo/pc/result.png&#39;;
  });
  return p;
}
//延时函数，用于给请求计时
function timeout(){
  var p = new Promise(function(resolve, reject){
    setTimeout(function(){ reject(&#39;图片请求超时&#39;); }, 5000);
  });
  return p;
}
Promise.race([requestImg(), timeout()])
.then(function(results){
  console.log(results);
})
.catch(function(reason){
  console.log(reason);
});

// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场景

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210414210720.95b663b8.png" alt=""></p><p>promise手写实现，面试够用版：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function myPromise(constructor){
    let self=this;
    self.status=&quot;pending&quot; //定义状态改变前的初始状态
    self.value=undefined;//定义状态为resolved的时候的状态
    self.reason=undefined;//定义状态为rejected的时候的状态
    function resolve(value){
        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的
       if(self.status===&quot;pending&quot;){
          self.value=value;
          self.status=&quot;resolved&quot;;
       }
    }
    function reject(reason){
        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的
       if(self.status===&quot;pending&quot;){
          self.reason=reason;
          self.status=&quot;rejected&quot;;
       }
    }
    //捕获构造异常
    try{
       constructor(resolve,reject);
    }catch(e){
       reject(e);
    }
}
// 定义链式调用的then方法
myPromise.prototype.then=function(onFullfilled,onRejected){
   let self=this;
   switch(self.status){
      case &quot;resolved&quot;:
        onFullfilled(self.value);
        break;
      case &quot;rejected&quot;:
        onRejected(self.reason);
        break;
      default:
   }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_16-generator" tabindex="-1"><a class="header-anchor" href="#_16-generator" aria-hidden="true">#</a> 16 Generator</h3><blockquote><p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程。Generator函数可以说是Iterator接口的具体实现方式。Generator 最大的特点就是可以控制函数的执行。</p></blockquote><ul><li><code>function*</code> 用来声明一个函数是生成器函数，它比普通的函数声明多了一个<code>*</code>,<code>*</code>的位置比较随意可以挨着 <code>function</code> 关键字，也可以挨着函数名</li><li><code>yield</code> 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有<code>yield</code> 关键字，函数遇到 <code>yield</code> 的时候会暂停，并把 <code>yield</code> 后面的表达式结果抛出去</li><li><code>next</code>作用是将代码的控制权交还给生成器函数</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // =&gt; {value: 6, done: false}
console.log(it.next(12)) // =&gt; {value: 8, done: false}
console.log(it.next(13)) // =&gt; {value: 42, done: true}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个示例就是一个Generator函数，我们来分析其执行过程：</p><ul><li>首先 Generator 函数调用时它会返回一个迭代器</li><li>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</li><li>当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</li><li>当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42</li></ul><p><code>yield</code>实际就是暂缓执行的标示，每执行一次<code>next()</code>，相当于指针移动到下一个<code>yield</code>位置</p><p><img src="/assets/20210408100806.708041e1.png" alt=""></p><blockquote><p>总结一下，<code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案。通过<code>yield</code>标识位和<code>next()</code>方法调用，实现函数的分段执行</p></blockquote><p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p><ul><li><code>function</code> 关键字与函数名之间有一个星号；</li><li>函数体内部使用 <code>yield</code>表达式，定义不同的内部状态；</li><li><code>next</code>指针移向下一个状态</li></ul><blockquote><p>这里你可以说说 <code>Generator</code>的异步编程，以及它的语法糖 <code>async</code> 和 <code>awiat</code>，传统的异步编程。<code>ES6</code> 之前，异步编程大致如下</p></blockquote><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li></ul><blockquote><p>传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 使用 * 表示这是一个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调用 next 恢复执行
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // &gt;  { value: 2, done: false }
console.log(b.next()); // &gt;  { value: 3, done: false }
console.log(b.next()); // &gt;  { value: undefined, done: true }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从以上代码可以发现，加上 <code>*</code>的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function() {
    var object = {
      next: 0,
      stop: function() {}
    };

    return {
      next: function() {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false
        };
      }
    };
  })();
}
// 如果你使用 babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function(_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成几块
        // 每次执行 next 函数就执行一块代码
        // 并且表明下次需要执行哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
		// 执行完毕
        case 6:
        case &quot;end&quot;:
          return _context.stop();
      }
    }
  });
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_17-async-await" tabindex="-1"><a class="header-anchor" href="#_17-async-await" aria-hidden="true">#</a> 17 async/await</h3><blockquote><p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p></blockquote><ul><li>await 和 promise 一样，更多的是考笔试题，当然偶尔也会问到和 promise 的一些区别。</li><li>await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用 Promise.all。</li><li>一个函数如果加上 async ，那么该函数就会返回一个 Promise</li></ul><blockquote><ul><li><code>async =&gt; *</code></li><li><code>await =&gt; yield</code></li></ul></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 基本用法

async function timeout (ms) {
  await new Promise((resolve) =&gt; {
    setTimeout(resolve, ms)
  })
}
async function asyncConsole (value, ms) {
  await timeout(ms)
  console.log(value)
}
asyncConsole(&#39;hello async and await&#39;, 1000)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面来看一个使用 <code>await</code> 的代码。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 0
var b = async () =&gt; {
  a = a + await 10
  console.log(&#39;2&#39;, a) // -&gt; &#39;2&#39; 10
  a = (await 10) + a
  console.log(&#39;3&#39;, a) // -&gt; &#39;3&#39; 20
}
b()
a++
console.log(&#39;1&#39;, a) // -&gt; &#39;1&#39; 1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>首先函数<code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 <code>0</code>，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，遇到<code>await</code>就会立即返回一个<code>pending</code>状态的<code>Promise</code>对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li><li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li><li>然后后面就是常规执行代码了</li></ul><p>优缺点：</p><blockquote><p><code>async/await</code>的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p></blockquote><p>async原理</p><blockquote><p><code>async/await</code>语法糖就是使用<code>Generator</code>函数+自动执行器来运作的</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 定义了一个promise，用来模拟异步请求，作用是传入参数++
function getNum(num){
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(num+1)
        }, 1000)
    })
}

//自动执行器，如果一个Generator函数没有执行完，则递归调用
function asyncFun(func){
  var gen = func();

  function next(data){
    var result = gen.next(data);
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data);
    });
  }

  next();
}

// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步
var func = function* (){
  var f1 = yield getNum(1);
  var f2 = yield getNum(f1);
  console.log(f2) ;
};
asyncFun(func);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在执行的过程中，判断一个函数的<code>promise</code>是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤</li><li>每一个 <code>next()</code> 方法返回值的 <code>value</code> 属性为一个 <code>Promise</code> 对象，所以我们为其添加 <code>then</code> 方法， 在 <code>then</code> 方法里面接着运行 <code>next</code> 方法挪移遍历器指针，直到 <code>Generator</code>函数运行完成</li></ul><p><img src="/assets/20210414210917.7ced44fa.png" alt=""></p><h3 id="_18-事件循环" tabindex="-1"><a class="header-anchor" href="#_18-事件循环" aria-hidden="true">#</a> 18 事件循环</h3><p><img src="/assets/20210516161332.440f2685.png" alt=""></p><ul><li>默认代码从上到下执行，执行环境通过<code>script</code>来执行（宏任务）</li><li>在代码执行过程中，调用定时器 <code>promise</code> <code>click</code>事件...不会立即执行，需要等待当前代码全部执行完毕</li><li>给异步方法划分队列，分别存放到微任务（立即存放）和宏任务（时间到了或事情发生了才存放）到队列中</li><li><code>script</code>执行完毕后，会清空所有的微任务</li><li>微任务执行完毕后，会渲染页面（不是每次都调用）</li><li>再去宏任务队列中看有没有到达时间的，拿出来其中一个执行</li><li>执行完毕后，按照上述步骤不停的循环</li></ul><p>例子</p><p><img src="/assets/20210516162034.56a47134.png" alt="">  <img src="/assets/20210516162330.b086aa7b.png" alt=""></p><blockquote><p>自动执行的情况 会输出 listener1 listener2 task1 task2</p></blockquote><p><img src="/assets/20210516162704.463e894d.png" alt="">  <img src="/assets/20210516163038.0a66aa22.png" alt=""></p><blockquote><p>如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2</p></blockquote><p><img src="/assets/20210516163647.77030e63.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log(1)

async function asyncFunc(){
  console.log(2)
  // await xx ==&gt; promise.resolve(()=&gt;{console.log(3)}).then()
  // console.log(3) 放到promise.resolve或立即执行
  await console.log(3)
  // 相当于把console.log(4)放到了then promise.resolve(()=&gt;{console.log(3)}).then(()=&gt;{
  //   console.log(4)
  // })
  // 微任务谁先注册谁先执行
  console.log(4)
}

setTimeout(()=&gt;{console.log(5)})

const promise = new Promise((resolve,reject)=&gt;{
  console.log(6)
  resolve(7)
})

promise.then(d=&gt;{console.log(d)})

asyncFunc()

console.log(8)

// 输出 1 6 2 3 8 7 4 5

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1. 浏览器事件循环</p><blockquote><p>涉及面试题：异步代码执行顺序？解释一下什么是 <code>Event Loop</code> ？</p></blockquote><blockquote><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p></blockquote><blockquote><p>js代码执行过程中会有很多任务，这些任务总的分成两类：</p></blockquote><ul><li>同步任务</li><li>异步任务</li></ul><blockquote><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：</p></blockquote><p><img src="/assets/20220307225270.a4714e4b.png" alt=""></p><p>我们解释一下这张图：</p><ul><li>同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><blockquote><p>那主线程执行栈何时为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数</p></blockquote><p>以上就是js运行的整体流程</p><p>面试中该如何回答呢？ 下面是我个人推荐的回答：</p><ul><li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行</li><li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function(resolve, reject) {
  console.log(2);
  resolve()
}).then(function() {
  console.log(3)
});
process.nextTick(function () {
  console.log(4)
})
console.log(5)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一轮：主线程开始执行，遇到<code>setTimeout</code>，将setTimeout的回调函数丢到宏任务队列中，在往下执行<code>new Promise</code>立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到<code>process.nextTick</code>，同样将回调函数扔到微任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和<code>nextTick</code>两个微任务，先执行哪个呢？<code>process.nextTick</code>指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。</li><li>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431</li></ul><blockquote><p><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</p></blockquote><p><img src="/assets/20220307225253.e2a85761.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;setTimeout&#39;);
}, 0);

console.log(&#39;script end&#39;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;setTimeout&#39;);
}, 0);

new Promise((resolve) =&gt; {
    console.log(&#39;Promise&#39;)
    resolve()
}).then(function() {
  console.log(&#39;promise1&#39;);
}).then(function() {
  console.log(&#39;promise2&#39;);
});

console.log(&#39;script end&#39;);
// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p>微任务</p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li><li><img src="/assets/20210516165328.61f79d8d.png" alt=""></li></ul><p>宏任务</p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code> 网络请求完成、文件读写完成事件</li><li><code>UI rendering</code></li><li>用户交互事件（比如鼠标点击、滚动页面、放大缩小等）</li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><img src="/assets/20210414213126.e0df9205.png" alt=""></p><p>所以正确的一次 Event loop 顺序是这样的</p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><ul><li>JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务</li><li>执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；</li><li>然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。</li></ul><p><img src="/assets/20210414211816.60cfcf20.png" alt=""></p><blockquote><p>总结起来就是：<code>一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务</code>。</p></blockquote><p>2. Node 中的 Event loop</p><blockquote><p>当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，<code>process.nextTick()</code> 方法会开始处理事件循环。下面就是 Node.js 官网提供的 <code>Eventloop</code> 事件循环参考流程</p></blockquote><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><p><img src="/assets/20210414211850.6d66f2d8.png" alt="">  <img src="/assets/20210516214402.722c6341.png" alt="">  <img src="/assets/20210516221825.ab9fe18a.png" alt=""></p><ul><li>每次执行执行一个宏任务后会清空微任务（执行顺序和浏览器一致，在node11版本以上）</li><li><code>process.nextTick</code> node中的微任务，当前执行栈的底部，优先级比<code>promise</code>要高</li></ul><blockquote><p>整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程。我们来分别看下这六个阶段都做了哪些事情。</p></blockquote><ul><li>Timers 阶段：这个阶段执行 <code>setTimeout</code> 和 <code>setInterval</code>的回调函数，简单理解就是由这两个函数启动的回调函数。</li><li>I/O callbacks 阶段：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。</li><li>idle，prepare 阶段：仅系统内部使用，你只需要知道有这 2 个阶段就可以。</li><li>poll 阶段：<code>poll</code> 阶段是一个重要且复杂的阶段，几乎所有 <code>I/O</code> 相关的回调，都在这个阶段执行（除了<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> 以及一些因为 <code>exception</code> 意外关闭产生的回调）。<code>检索新的 I/O 事件，执行与 I/O 相关的回调</code>，其他情况 Node.js 将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行。这个阶段的主要流程如下图所示。</li></ul><p><img src="/assets/20210414212124.927ac6af.png" alt=""></p><ul><li>check 阶段：<code>setImmediate()</code> 回调函数在这里执行，<code>setImmediate</code> 并不是立马执行，而是当事件循环 <code>poll 中没有新的事件处理时就执行该部分</code>，如下代码所示。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const fs = require(&#39;fs&#39;);
setTimeout(() =&gt; { // 新的事件循环的起点
    console.log(&#39;1&#39;);
}, 0);
setImmediate( () =&gt; {
    console.log(&#39;setImmediate 1&#39;);
});
/// fs.readFile 将会在 poll 阶段执行
fs.readFile(&#39;./test.conf&#39;, {encoding: &#39;utf-8&#39;}, (err, data) =&gt; {
    if (err) throw err;
    console.log(&#39;read file success&#39;);
});
/// 该部分将会在首次事件循环中执行
Promise.resolve().then(()=&gt;{
    console.log(&#39;poll callback&#39;);
});
// 首次事件循环执行
console.log(&#39;2&#39;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这一代码中有一个非常奇特的地方，就是 <code>setImmediate</code> 会在 <code>setTimeout</code> 之后输出。有以下几点原因：</p><blockquote><ul><li><code>setTimeout</code> 如果不设置时间或者设置时间为 <code>0</code>，则会默认为 <code>1ms</code></li><li>主流程执行完成后，超过 <code>1ms</code> 时，会将 <code>setTimeout</code> 回调函数逻辑插入到待执行回调函数 <code>poll</code> 队列中；</li><li>由于当前 <code>poll</code> 队列中存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行<code>check：setImmediate</code>。</li></ul></blockquote><blockquote><p>因此这也验证了这句话，<code>先执行回调函数，再执行 setImmediate</code></p></blockquote><ul><li>close callbacks 阶段：执行一些关闭的回调函数，如 <code>socket.on(&#39;close&#39;, ...)</code></li></ul><blockquote><p>除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 <code>Process.nextTick()</code></p></blockquote><p>可以认为，<code>Process.nextTick()</code> 会在上述各个阶段结束时，在<code>进入下一个阶段之前立即执行</code>（优先级甚至超过 <code>microtask</code> 队列）</p><p>事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢</p><p><img src="/assets/20210424174311.4691f31d.png" alt=""></p><ul><li>微任务：在 Node.js 中微任务包含 2 种------<code>process.nextTick</code> 和 <code>Promise</code>。<code>微任务在事件循环中优先级是最高的</code>，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且<code>process.nextTick 和 Promise</code>也存在优先级，<code>process.nextTick</code> 高于 <code>Promise</code></li><li>宏任务：在 Node.js 中宏任务包含 4 种------<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> 和 <code>I/O</code>。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列</li></ul><p>我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。</p><ul><li>同步代码。</li><li>将异步任务插入到微任务队列或者宏任务队列中。</li><li>执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const fs = require(&#39;fs&#39;);
// 首次事件循环执行
console.log(&#39;start&#39;);
/// 将会在新的事件循环中的阶段执行
fs.readFile(&#39;./test.conf&#39;, {encoding: &#39;utf-8&#39;}, (err, data) =&gt; {
    if (err) throw err;
    console.log(&#39;read file success&#39;);
});
setTimeout(() =&gt; { // 新的事件循环的起点
    console.log(&#39;setTimeout&#39;);
}, 0);
/// 该部分将会在首次事件循环中执行
Promise.resolve().then(()=&gt;{
    console.log(&#39;Promise callback&#39;);
});
/// 执行 process.nextTick
process.nextTick(() =&gt; {
    console.log(&#39;nextTick callback&#39;);
});
// 首次事件循环执行
console.log(&#39;end&#39;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析下上面代码的执行过程</p><ul><li>第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end</li><li>第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end；</li><li>再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：<code>Promise.resolve 和 process.nextTick</code>，宏任务队列包含：<code>fs.readFile 和 setTimeout</code>；</li><li>先执行微任务队列，但是根据优先级，先执行 <code>process.nextTick 再执行 Promise.resolve</code>，所以先输出 <code>nextTick callback</code> 再输出 <code>Promise callback</code>；</li><li>再执行宏任务队列，根据<code>宏任务插入先后顺序执行 setTimeout 再执行 fs.readFile</code>，这里需要注意，先执行 <code>setTimeout</code> 由于其回调时间较短，因此回调也先执行，并非是 <code>setTimeout</code> 先执行所以才先执行回调函数，但是它执行需要时间肯定大于 <code>1ms</code>，所以虽然 <code>fs.readFile</code> 先于<code>setTimeout</code> 执行，但是 <code>setTimeout</code> 执行更快，所以先输出 <code>setTimeout</code> ，最后输出 <code>read file success</code>。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 输出结果
start
end
nextTick callback
Promise callback
setTimeout
read file success

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210516224232.f5e6e868.png" alt=""></p><blockquote><p>当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const fs = require(&#39;fs&#39;);
setTimeout(() =&gt; { // 新的事件循环的起点
    console.log(&#39;1&#39;);
    fs.readFile(&#39;./config/test.conf&#39;, {encoding: &#39;utf-8&#39;}, (err, data) =&gt; {
        if (err) throw err;
        console.log(&#39;read file sync success&#39;);
    });
}, 0);
/// 回调将会在新的事件循环之前
fs.readFile(&#39;./config/test.conf&#39;, {encoding: &#39;utf-8&#39;}, (err, data) =&gt; {
    if (err) throw err;
    console.log(&#39;read file success&#39;);
});
/// 该部分将会在首次事件循环中执行
Promise.resolve().then(()=&gt;{
    console.log(&#39;poll callback&#39;);
});
// 首次事件循环执行
console.log(&#39;2&#39;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是 <code>setTimeout 和 fs.readFile</code>，微任务是 <code>Promise.resolve</code>。</p><ul><li>整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出 2。</li><li>接下来执行微任务，输出 <code>poll callback</code>。</li><li>再执行宏任务中的 <code>fs.readFile 和 setTimeout</code>，由于 <code>fs.readFile</code> 优先级高，先执行 <code>fs.readFile</code>。但是处理时间长于 <code>1ms</code>，因此会先执行 <code>setTimeout</code> 的回调函数，输出 <code>1</code>。这个阶段在执行过程中又会产生新的宏任务 <code>fs.readFile</code>，因此又将该 <code>fs.readFile 插入宏任务队列</code></li><li>最后由于只剩下宏任务了 <code>fs.readFile</code>，因此执行该宏任务，并等待处理完成后的回调，输出 <code>read file sync success</code>。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 结果
2
poll callback
1
read file success
read file sync success

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Process.nextick() 和 Vue 的 nextick</p><p><img src="/assets/20210414213602.04abed6d.png" alt=""></p><blockquote><p><code>Node.js</code> 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 <code>Node.js</code> 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>setTimeout(() =&gt; {
    console.log(&#39;setTimeout&#39;);
}, 0);
setImmediate(() =&gt; {
    console.log(&#39;setImmediate&#39;);
})
// 这里可能会输出 setTimeout，setImmediate
// 可能也会相反的输出，这取决于性能
// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate
// 否则会执行 setTimeout

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>setTimeout(()=&gt;{
    console.log(&#39;timer1&#39;)

    Promise.resolve().then(function() {
        console.log(&#39;promise1&#39;)
    })
}, 0)

setTimeout(()=&gt;{
    console.log(&#39;timer2&#39;)

    Promise.resolve().then(function() {
        console.log(&#39;promise2&#39;)
    })
}, 0)

// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中一定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><p><img src="/assets/20210529172258.77f98243.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>setTimeout(() =&gt; {
 console.log(&quot;timer1&quot;);

 Promise.resolve().then(function() {
   console.log(&quot;promise1&quot;);
 });
}, 0);

// poll阶段执行
fs.readFile(&#39;./test&#39;,()=&gt;{
  // 在poll阶段里面 如果有setImmediate优先执行，setTimeout处于事件循环顶端 poll下面就是setImmediate
  setTimeout(()=&gt;console.log(&#39;setTimeout&#39;),0)
  setImmediate(()=&gt;console.log(&#39;setImmediate&#39;),0)
})

process.nextTick(() =&gt; {
 console.log(&quot;nextTick&quot;);
});
// nextTick, timer1, promise1,setImmediate,setTimeout

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对于 <code>microtask</code> 来说，它会在以上每个阶段完成前清空 <code>microtask</code> 队列，下图中的 <code>Tick</code> 就代表了 <code>microtask</code></p></blockquote><p><img src="/assets/20220307225255.2f0fd634.png" alt=""></p><p>谁来启动这个循环过程，循环条件是什么？</p><blockquote><p>当 Node.js 启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的 API、调度定时器，或者 <code>process.nextTick()</code>，然后再开始处理事件循环。因此可以这样理解，Node.js 进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。</p></blockquote><p>总结来说，Node.js 事件循环的发起点有 4 个：</p><ul><li><code>Node.js</code> 启动后；</li><li><code>setTimeout</code> 回调函数；</li><li><code>setInterval</code> 回调函数；</li><li>也可能是一次 <code>I/O</code> 后的回调函数。</li></ul><p>无限循环有没有终点</p><blockquote><p>当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步 I/O，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行</p></blockquote><p>Node.js 是单线程的还是多线程的？</p><blockquote><p><code>主线程是单线程执行的</code>，但是 Node.js <code>存在多线程执行</code>，多线程包括 <code>setTimeout 和异步 I/O 事件</code>。其实 Node.js 还存在其他的线程，包括<code>垃圾回收、内存优化</code>等</p></blockquote><p>EventLoop 对渲染的影响</p><ul><li>想必你之前在业务开发中也遇到过 <code>requestIdlecallback 和 requestAnimationFrame</code>，这两个函数在我们之前的内容中没有讲过，但是当你开始考虑它们在 Eventloop 的生命周期的哪一步触发，或者这两个方法的回调会在微任务队列还是宏任务队列执行的时候，才发现好像没有想象中那么简单。这两个方法其实也并不属于 JS 的原生方法，而是浏览器宿主环境提供的方法，因为它们牵扯到另一个问题：渲染。</li><li>我们知道浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行</li><li>渲染原本就不应该出现在 Eventloop 相关的知识体系里，但是因为 Eventloop 显然是在讨论 JS 如何运行的问题，而渲染则是浏览器另外一个线程的工作。但是 <code>requestAnimationFrame</code>的出现却把这两件事情给关联起来</li><li>通过调用 <code>requestAnimationFrame</code> 我们可以在下次渲染之前执行回调函数。那下次渲染具体是哪个时间点呢？渲染和 Eventloop 有什么关系呢？ <ul><li>简单来说，就是在每一次 <code>Eventloop</code> 的末尾，<code>判断当前页面是否处于渲染时机，就是重新渲染</code></li></ul></li><li>有屏幕的硬件限制，比如 60Hz 刷新率，简而言之就是 1 秒刷新了 60 次，16.6ms 刷新一次。这个时候浏览器的渲染间隔时间就没必要小于 <code>16.6ms</code>，因为就算渲染了屏幕上也看不到。当然浏览器也不能保证一定会每 16.6ms 会渲染一次，因为还会受到处理器的性能、JavaScript 执行效率等其他因素影响。</li><li>回到 <code>requestAnimationFrame</code>，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 <code>setInterval</code>。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 <code>requestAnimationFrame</code> 更适合用来做针对每一帧来修改的动画效果</li><li>当然 <code>requestAnimationFrame</code> 不是 <code>Eventloop</code> 里的宏任务，或者说它并不在 <code>Eventloop</code> 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理</li></ul><p>但是 <code>requestIdlecallback</code> 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在&quot;空闲状态&quot;。这段空闲时间可以被 <code>requestIdlecallback</code> 利用起来执行一些优先级不高、不必立即执行的任务，如下图所示：</p><p><img src="/assets/20210414212916.0b0e1f6f.png" alt=""></p><h3 id="_19-垃圾回收" tabindex="-1"><a class="header-anchor" href="#_19-垃圾回收" aria-hidden="true">#</a> 19 垃圾回收</h3><ul><li>对于在JavaScript中的字符串，对象，数组是没有固定大小的，只有当对他们进行动态分配存储时，解释器就会分配内存来存储这些数据，当JavaScript的解释器消耗完系统中所有可用的内存时，就会造成系统崩溃。</li><li>内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。</li><li>JavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。</li><li>针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数</li><li>标记清除</li></ul><blockquote><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p></blockquote><ul><li>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</li><li>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。</li></ul><p>这个算法分为三步：</p><ul><li>首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</li><li>如果对象不存活，则释放对象的空间。</li><li>最后将 From 空间和 To 空间角色进行交换。</li></ul><p>新生代对象晋升到老生代有两个条件：</p><ul><li>第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老��代中；若没有经历，则复制到 To 空间。</li><li>第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</li></ul><blockquote><p>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p></blockquote><p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行</p><h3 id="_20-内存泄露" tabindex="-1"><a class="header-anchor" href="#_20-内存泄露" aria-hidden="true">#</a> 20 内存泄露</h3><ul><li>意外的全局变量: 无法被回收</li><li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li><li>事件监听: 没有正确销毁 (低版本浏览器可能出现)</li><li>闭包 <ul><li>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li><li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul></li><li><code>dom</code> 引用: <code>dom</code> 元素被删除时，内存中的引用未被正确清空</li><li>控制台<code>console.log</code>打印的东西</li></ul><blockquote><p>可用 <code>chrome</code> 中的 <code>timeline</code> 进行内存标记，可视化查看内存的变化情况，找出异常点。</p></blockquote><p><a href="https://juejin.cn/post/6947841638118998029?utm_source=gold_browser_extension" target="_blank" rel="noopener noreferrer">内存泄露排查方法(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_21-深浅拷贝" tabindex="-1"><a class="header-anchor" href="#_21-深浅拷贝" aria-hidden="true">#</a> 21 深浅拷贝</h3><p><img src="/assets/20210414142630.6b4f9a39.png" alt=""></p><p>1. 浅拷贝的原理和实现</p><blockquote><p>自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象</p></blockquote><p>方法一：object.assign</p><blockquote><p><code>object.assign</code>是 ES6 中 <code>object</code> 的一个方法，该方法可以用于 JS 对象的合并等多个用途，<code>其中一个用途就是可以进行浅拷贝</code>。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>object.assign 的语法为：Object.assign(target, ...sources)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>object.assign 的示例代码如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let target = {};
let source = { a: { b: 1 } };
Object.assign(target, source);
console.log(target); // { a: { b: 1 } };

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是使用 object.assign 方法有几点需要注意</p><ul><li>它不会拷贝对象的继承属性；</li><li>它不会拷贝对象的不可枚举的属性；</li><li>可以拷贝 <code>Symbol</code> 类型的属性。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let obj1 = { a:{ b:1 }, sym:Symbol(1)};
Object.defineProperty(obj1, &#39;innumerable&#39; ,{
    value:&#39;不可枚举属性&#39;,
    enumerable:false
});
let obj2 = {};
Object.assign(obj2,obj1)
obj1.a.b = 2;
console.log(&#39;obj1&#39;,obj1);
console.log(&#39;obj2&#39;,obj2);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210414134752.f964dd1b.png" alt=""></p><blockquote><p>从上面的样例代码中可以看到，利用 <code>object.assign</code> 也可以拷贝 <code>Symbol</code> 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中<code>依旧存在着访问共同堆内存的问题</code>，也就是说<code>这种方法还不能进一步复制，而只是完成了浅拷贝的功能</code></p></blockquote><p>方法二：扩展运算符方式</p><ul><li>我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。</li><li>扩展运算符的语法为：<code>let cloneObj = { ...obj };</code></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/* 对象的拷贝 */
let obj = {a:1,b:{c:1}}
let obj2 = {...obj}
obj.a = 2
console.log(obj)  //{a:2,b:{c:1}} console.log(obj2); //{a:1,b:{c:1}}
obj.b.c = 2
console.log(obj)  //{a:2,b:{c:2}} console.log(obj2); //{a:1,b:{c:2}}
/* 数组的拷贝 */
let arr = [1, 2, 3];
let newArr = [...arr]; //跟arr.slice()是一样的效果

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>扩展运算符 和 <code>object.assign</code> 有同样的缺陷，也就是<code>实现的浅拷贝的功能差不多</code>，但是如果属性都是<code>基本类型的值，使用扩展运算符进行浅拷贝会更加方便</code></p></blockquote><p>方法三：concat 拷贝数组</p><blockquote><p>数组的 <code>concat</code> 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 <code>concat</code> 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);  // [ 1, 2, 3 ]
console.log(newArr); // [ 1, 100, 3 ]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法四：slice 拷贝数组</p><blockquote><p><code>slice</code> 方法也比较有局限性，因为<code>它仅仅针对数组类型</code>。<code>slice方法会返回一个新的数组对象</code>，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>slice 的语法为：arr.slice(begin, end);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;
console.log(arr);  //[ 1, 2, { val: 1000 } ]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从上面的代码中可以看出，这就是<code>浅拷贝的限制所在了------它只能拷贝一层对象</code>。如果<code>存在对象的嵌套，那么浅拷贝将无能为力</code>。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝</p></blockquote><p>手工实现一个浅拷贝</p><p>根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：</p><ul><li>对基础类型做一个最基本的一个拷贝；</li><li>对引用类型开辟一个新的存储，并且拷贝一层对象属性。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const shallowClone = (target) =&gt; {
  if (typeof target === &#39;object&#39; &amp;&amp; target !== null) {
    const cloneTarget = Array.isArray(target) ? []: {};
    for (let prop in target) {
      if (target.hasOwnProperty(prop)) {
          cloneTarget[prop] = target[prop];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>利用类型判断，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性，基本就可以手工实现一个浅拷贝的代码了</p></blockquote><p>2. 深拷贝的原理和实现</p><p><code>浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝</code>。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p><p>这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，<code>深拷贝的原理可以总结如下</code>：</p><blockquote><p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p></blockquote><p>方法一：乞丐版（JSON.stringify）</p><blockquote><p><code>JSON.stringify()</code> 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 <code>JSON</code> 的字符串，并将对象里面的内容转换成字符串，最后再用 <code>JSON.parse()</code> 的方法将 <code>JSON</code> 字符串生成一个新的对象</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // FE

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是该方法也是有局限性的：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>无法拷贝不可枚举的属性</li><li>无法拷贝对象的原型链</li><li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li><li>拷贝 <code>Date</code> 引用类型会变成字符串</li><li>对象中含有 <code>NaN</code>、<code>Infinity</code> 以及 <code>-Infinity</code>，<code>JSON</code> 序列化的结果会变成 <code>null</code></li><li>不能解决循环引用的对象，即对象成环 (<code>obj[key] = obj</code>)。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Obj() {
  this.func = function () { alert(1) };
  this.obj = {a:1};
  this.arr = [1,2,3];
  this.und = undefined;
  this.reg = /123/;
  this.date = new Date(0);
  this.NaN = NaN;
  this.infinity = Infinity;
  this.sym = Symbol(1);
}
let obj1 = new Obj();
Object.defineProperty(obj1,&#39;innumerable&#39;,{
  enumerable:false,
  value:&#39;innumerable&#39;
});
console.log(&#39;obj1&#39;,obj1);
let str = JSON.stringify(obj1);
let obj2 = JSON.parse(str);
console.log(&#39;obj2&#39;,obj2);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210414141731.9dba5900.png" alt=""></p><blockquote><p>使用 <code>JSON.stringify</code> 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，<code>JSON.stringify</code> 暂时还是无法满足的，那么就需要下面的几种方法了</p></blockquote><p>方法二：基础版（手写递归实现）</p><blockquote><p>下面是一个实现 deepClone 函数封装的例子，通过 <code>for in</code> 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let obj1 = {
  a:{
    b:1
  }
}
function deepClone(obj) {
  let cloneObj = {}
  for(let key in obj) {                 //遍历
    if(typeof obj[key] ===&#39;object&#39;) {
      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归
    } else {
      cloneObj[key] = obj[key]  //基本类型的话直接复制值
    }
  }
  return cloneObj
}
let obj2 = deepClone(obj1);
obj1.a.b = 2;
console.log(obj2);   //  {a:{b:1}}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然利用递归能实现一个深拷贝，但是同上面的 <code>JSON.stringify</code> 一样，还是有一些问题没有完全解决，例如：</p><ul><li>这个深拷贝函数并不能复制不可枚举的属性以及 <code>Symbol</code> 类型；</li><li>这种方法<code>只是针对普通的引用类型的值做递归复制</code>，而对于 <code>Array、Date、RegExp、Error、Function</code> 这样的引用类型并不能正确地拷贝；</li><li>对象的属性里面成环，即<code>循环引用没有解决</code>。</li></ul><p>这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。</p><p>所以为了&quot;拯救&quot;这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。</p><p>方法三：改进版（改进后递归实现）</p><blockquote><p>针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。</p></blockquote><ul><li>针对能够遍历对象的不可枚举属性以及 <code>Symbol</code> 类型，我们可以使用 <code>Reflect.ownKeys</code> 方法；</li><li>当参数为 <code>Date、RegExp</code> 类型，则直接生成一个新的实例返回；</li><li>利用 <code>Object</code> 的 <code>getOwnPropertyDescriptors</code> 方法可以获得对象的所有属性，以及对应的特性，顺便结合 <code>Object.create</code> 方法创建一个新对象，并继承传入原对象的原型链；</li><li>利用 <code>WeakMap</code> 类型作为 <code>Hash</code> 表，因为 <code>WeakMap</code> 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 <code>Map</code> 和 <code>weakMap</code> 的关键区别，这里要用 <code>weakMap</code>），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 <code>WeakMap</code> 存储的值</li></ul><p>如果你在考虑到循环引用的问题之后，还能用 <code>WeakMap</code> 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了</p><p>实现深拷贝</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const isComplexDataType = obj =&gt; (typeof obj === &#39;object&#39; || typeof obj === &#39;function&#39;) &amp;&amp; (obj !== null)

const deepClone = function (obj, hash = new WeakMap()) {
  if (obj.constructor === Date) {
    return new Date(obj)       // 日期对象直接返回一个新的日期对象
  }

  if (obj.constructor === RegExp){
    return new RegExp(obj)     //正则对象直接返回一个新的正则对象
  }

  //如果循环引用了就用 weakMap 来解决
  if (hash.has(obj)) {
    return hash.get(obj)
  }
  let allDesc = Object.getOwnPropertyDescriptors(obj)

  //遍历传入参数所有键的特性
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)

  // 把cloneObj原型复制到obj上
  hash.set(obj, cloneObj)

  for (let key of Reflect.ownKeys(obj)) {
    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &#39;function&#39;) ? deepClone(obj[key], hash) : obj[key]
  }
  return cloneObj
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 下面是验证代码
let obj = {
  num: 0,
  str: &#39;&#39;,
  boolean: true,
  unf: undefined,
  nul: null,
  obj: { name: &#39;我是一个对象&#39;, id: 1 },
  arr: [0, 1, 2],
  func: function () { console.log(&#39;我是一个函数&#39;) },
  date: new Date(0),
  reg: new RegExp(&#39;/我是一个正则/ig&#39;),
  [Symbol(&#39;1&#39;)]: 1,
};
Object.defineProperty(obj, &#39;innumerable&#39;, {
  enumerable: false, value: &#39;不可枚举属性&#39; }
);
obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))
obj.loop = obj    // 设置loop成循环引用的属性
let cloneObj = deepClone(obj)
cloneObj.arr.push(4)
console.log(&#39;obj&#39;, obj)
console.log(&#39;cloneObj&#39;, cloneObj)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看一下结果，<code>cloneObj</code> 在 <code>obj</code> 的基础上进行了一次深拷贝，<code>cloneObj</code> 里的 <code>arr</code> 数组进行了修改，并未影响到 <code>obj.arr</code> 的变化，如下图所示</p><p><img src="/assets/20210414142525.8a7a2e6d.png" alt=""></p><h3 id="_22-节流与防抖" tabindex="-1"><a class="header-anchor" href="#_22-节流与防抖" aria-hidden="true">#</a> 22 节流与防抖</h3><ul><li>函数防抖 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><li>函数节流 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>
// 函数防抖的实现
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = arguments;

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() =&gt; {
      fn.apply(context, args);
    }, wait);
  };
}

// 函数节流的实现;
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = arguments,
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime &gt;= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_23-proxy代理" tabindex="-1"><a class="header-anchor" href="#_23-proxy代理" aria-hidden="true">#</a> 23 Proxy代理</h3><blockquote><p>proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var proxy = new Proxy(target, handler);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>new Proxy()</code>表示生成一个Proxy实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var target = {
   name: &#39;poetries&#39;
 };
 var logHandler = {
   get: function(target, key) {
     console.log(`${key} 被读取`);
     return target[key];
   },
   set: function(target, key, value) {
     console.log(`${key} 被设置为 ${value}`);
     target[key] = value;
   }
 }
 var targetWithLog = new Proxy(target, logHandler);

 targetWithLog.name; // 控制台输出：name 被读取
 targetWithLog.name = &#39;others&#39;; // 控制台输出：name 被设置为 others

 console.log(target.name); // 控制台输出: others

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>targetWithLog</code> 读取属性的值时，实际上执行的是 <code>logHandler.get</code> ：在控制台输出信息，并且读取被代理对象 <code>target</code> 的属性。</li><li>在 <code>targetWithLog</code> 设置属性值时，实际上执行的是 <code>logHandler.set</code> ：在控制台输出信息，并且设置被代理对象 <code>target</code> 的属性的值</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 由于拦截函数总是返回35，所以访问任何属性都得到35
var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Proxy 实例也可以作为其他对象的原型对象</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p></blockquote><p>Proxy的作用</p><blockquote><p>对于代理模式 <code>Proxy</code> 的作用主要体现在三个方面</p></blockquote><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>Proxy所能代理的范围--handler</p><blockquote><p>实际上 handler 本身就是ES6所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。
handler.getPrototypeOf()

// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。
handler.setPrototypeOf()

// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。
handler.isExtensible()

// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。
handler.preventExtensions()

// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。
handler.getOwnPropertyDescriptor()

// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, {}) 时。
andler.defineProperty()

// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。
handler.has()

// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。
handler.get()

// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。
handler.set()

// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。
handler.deleteProperty()

// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。
handler.ownKeys()

// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。
handler.apply()

// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。
handler.construct()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为何Proxy不能被Polyfill</p><ul><li>如class可以用<code>function</code>模拟；<code>promise</code>可以用<code>callback</code>模拟</li><li>但是proxy不能用<code>Object.defineProperty</code>模拟</li></ul><blockquote><p>目前谷歌的polyfill只能实现部分的功能，如get、set https://github.com/GoogleChrome/proxy-polyfill</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// commonJS require
const proxyPolyfill = require(&#39;proxy-polyfill/src/proxy&#39;)();

// Your environment may also support transparent rewriting of commonJS to ES6:
import ProxyPolyfillBuilder from &#39;proxy-polyfill/src/proxy&#39;;
const proxyPolyfill = ProxyPolyfillBuilder();

// Then use...
const myProxy = new proxyPolyfill(...);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_24-ajax" tabindex="-1"><a class="header-anchor" href="#_24-ajax" aria-hidden="true">#</a> 24 Ajax</h3><blockquote><p>它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</p></blockquote><p><img src="/assets/20220307225259.a65cb0e8.png" alt=""></p><p>面试手写（原生）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//1：创建Ajax对象
var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);// 兼容IE6及以下版本
//2：配置 Ajax请求地址
xhr.open(&#39;get&#39;,&#39;index.xml&#39;,true);
//3：发送请求
xhr.send(null); // 严谨写法
//4:监听请求，接受响应
xhr.onreadysatechange=function(){
     if(xhr.readySate==4&amp;&amp;xhr.status==200 || xhr.status==304 )
          console.log(xhr.responsetXML)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jQuery写法</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$.ajax({
  type:&#39;post&#39;,
  url:&#39;&#39;,
  async:ture,//async 异步  sync  同步
  data:data,//针对post请求
  dataType:&#39;jsonp&#39;,
  success:function (msg) {

  },
  error:function (error) {

  }
})

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>promise 封装实现：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// promise 封装实现：

function getJSON(url) {
  // 创建一个 promise 对象
  let promise = new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest();

    // 新建一个 http 请求
    xhr.open(&quot;GET&quot;, url, true);

    // 设置状态的监听函数
    xhr.onreadystatechange = function() {
      if (this.readyState !== 4) return;

      // 当请求成功或失败时，改变 promise 的状态
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };

    // 设置错误监听函数
    xhr.onerror = function() {
      reject(new Error(this.statusText));
    };

    // 设置响应的数据类型
    xhr.responseType = &quot;json&quot;;

    // 设置请求头信息
    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);

    // 发送 http 请求
    xhr.send(null);
  });

  return promise;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_25-深入数组" tabindex="-1"><a class="header-anchor" href="#_25-深入数组" aria-hidden="true">#</a> 25 深入数组</h3><p>一、梳理数组 API</p><p>1. <code>Array.of</code></p><blockquote><p><code>Array.of</code> 用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其他。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Array.of(8.0); // [8]
Array(8.0); // [empty × 8]
Array.of(8.0, 5); // [8, 5]
Array(8.0, 5); // [8, 5]
Array.of(&#39;8&#39;); // [&quot;8&quot;]
Array(&#39;8&#39;); // [&quot;8&quot;]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2. <code>Array.from</code></p><p>从语法上看，Array.from 拥有 3 个参数：</p><ul><li>类似数组的对象，必选；</li><li>加工函数，新生成的数组会经过该函数的加工再返回；</li><li><code>this</code> 作用域，表示加工函数执行时 <code>this</code> 的值。</li></ul><p>这三个参数里面第一个参数是必选的，后两个参数都是可选的。我们通过一段代码来看看它的用法。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var obj = {0: &#39;a&#39;, 1: &#39;b&#39;, 2:&#39;c&#39;, length: 3};
Array.from(obj, function(value, index){
  console.log(value, index, this, arguments.length);
  return value.repeat(3);   //必须指定返回值，否则返回 undefined
}, obj);

// return 的 value 重复了三遍，最后返回的数组为 [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]

// 如果这里不指定 this 的话，加工函数完全可以是一个箭头函数。上述代码可以简写为如下形式。
Array.from(obj, (value) =&gt; value.repeat(3));
//  控制台返回 (3) [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>除了上述 <code>obj</code> 对象以外，拥有迭代器的对象还包括 <code>String、Set、Map</code> 等，<code>Array.from</code> 统统可以处理，请看下面的代码。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// String
Array.from(&#39;abc&#39;);         // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
// Set
Array.from(new Set([&#39;abc&#39;, &#39;def&#39;])); // [&quot;abc&quot;, &quot;def&quot;]
// Map
Array.from(new Map([[1, &#39;ab&#39;], [2, &#39;de&#39;]]));
// [[1, &#39;ab&#39;], [2, &#39;de&#39;]]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3. <code>Array 的判断</code></p><blockquote><p>在 ES5 提供该方法之前，我们至少有如下 5 种方式去判断一个变量是否为数组。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [];
// 1.基于instanceof
a instanceof Array;
// 2.基于constructor
a.constructor === Array;
// 3.基于Object.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(a);
// 4.基于getPrototypeOf
Object.getPrototypeOf(a) === Array.prototype;
// 5.基于Object.prototype.toString
Object.prototype.toString.apply(a) === &#39;[object Array]&#39;;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>ES6 之后新增了一个 <code>Array.isArray</code> 方法，能直接判断数据类型是否为数组，但是如果 isArray 不存在，那么 <code>Array.isArray</code> 的 polyfill 通常可以这样写：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>if (!Array.isArray){
  Array.isArray = function(arg){
    return Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;
  };
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4. 改变自身的方法</p><blockquote><p>基于 ES6，会改变自身值的方法一共有 <code>9</code> 个，分别为 <code>pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// pop方法
var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];
var item = array.pop();
console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]
console.log(item); // mouse
// push方法
var array = [&quot;football&quot;, &quot;basketball&quot;,  &quot;badminton&quot;];
var i = array.push(&quot;golfball&quot;);
console.log(array);
// [&quot;football&quot;, &quot;basketball&quot;, &quot;badminton&quot;, &quot;golfball&quot;]
console.log(i); // 4
// reverse方法
var array = [1,2,3,4,5];
var array2 = array.reverse();
console.log(array); // [5,4,3,2,1]
console.log(array2===array); // true
// shift方法
var array = [1,2,3,4,5];
var item = array.shift();
console.log(array); // [2,3,4,5]
console.log(item); // 1
// unshift方法
var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
var length = array.unshift(&quot;yellow&quot;);
console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]
console.log(length); // 4
// sort方法
var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];
var array2 = array.sort();
console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]
console.log(array2 == array); // true
// splice方法
var array = [&quot;apple&quot;,&quot;boy&quot;];
var splices = array.splice(1,1);
console.log(array); // [&quot;apple&quot;]
console.log(splices); // [&quot;boy&quot;]
// copyWithin方法
var array = [1,2,3,4,5];
var array2 = array.copyWithin(0,3);
console.log(array===array2,array2);  // true [4, 5, 3, 4, 5]
// fill方法
var array = [1,2,3,4,5];
var array2 = array.fill(10,0,3);
console.log(array===array2,array2);
// true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5. 不改变自身的方法</p><p>基于 ES7，不会改变自身的方法也有 <code>9</code> 个，分别为 <code>concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未形成标准的 toSource，以及 ES7 新增的方法 includes</code>。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// concat方法
var array = [1, 2, 3];
var array2 = array.concat(4,[5,6],[7,8,9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array); // [1, 2, 3], 可见原数组并未被修改
// join方法
var array = [&#39;We&#39;, &#39;are&#39;, &#39;Chinese&#39;];
console.log(array.join()); // &quot;We,are,Chinese&quot;
console.log(array.join(&#39;+&#39;)); // &quot;We+are+Chinese&quot;
// slice方法
var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];
console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]
console.log(array.slice(2,3)); // [&quot;three&quot;]
// toString方法
var array = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;];
var str = array.toString();
console.log(str); // Jan,Feb,Mar,Apr
// tolocalString方法
var array= [{name:&#39;zz&#39;}, 123, &quot;abc&quot;, new Date()];
var str = array.toLocaleString();
console.log(str); // [object Object],123,abc,2016/1/5 下午1:06:23
// indexOf方法
var array = [&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;,&#39;123&#39;];
console.log(array.indexOf(&#39;def&#39;)); // 1
// includes方法
var array = [-0, 1, 2];
console.log(array.includes(+0)); // true
console.log(array.includes(1)); // true
var array = [NaN];
console.log(array.includes(NaN)); // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>其中 includes 方法需要注意的是，如果元素中有 0，那么在判断过程中不论是 +0 还是 -0 都会判断为 True，这里的 <code>includes 忽略了 +0 和 -0</code></p></blockquote><p>6. 数组遍历的方法</p><p>基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为 <code>forEach、every、some、filter、map、reduce、reduceRight，以及 ES6 新增的方法 entries、find、findIndex、keys、values</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// forEach方法
var array = [1, 3, 5];
var obj = {name:&#39;cc&#39;};
var sReturn = array.forEach(function(value, index, array){
  array[index] = value;
  console.log(this.name); // cc被打印了三次, this指向obj
},obj);
console.log(array); // [1, 3, 5]
console.log(sReturn); // undefined, 可见返回值为undefined
// every方法
var o = {0:10, 1:8, 2:25, length:3};
var bool = Array.prototype.every.call(o,function(value, index, obj){
  return value &gt;= 8;
},o);
console.log(bool); // true
// some方法
var array = [18, 9, 10, 35, 80];
var isExist = array.some(function(value, index, array){
  return value &gt; 20;
});
console.log(isExist); // true
// map 方法
var array = [18, 9, 10, 35, 80];
array.map(item =&gt; item + 1);
console.log(array);  // [19, 10, 11, 36, 81]
// filter 方法
var array = [18, 9, 10, 35, 80];
var array2 = array.filter(function(value, index, array){
  return value &gt; 20;
});
console.log(array2); // [35, 80]
// reduce方法
var array = [1, 2, 3, 4];
var s = array.reduce(function(previousValue, value, index, array){
  return previousValue * value;
},1);
console.log(s); // 24
// ES6写法更加简洁
array.reduce((p, v) =&gt; p * v); // 24
// reduceRight方法 (和reduce的区别就是从后往前累计)
var array = [1, 2, 3, 4];
array.reduceRight((p, v) =&gt; p * v); // 24
// entries方法
var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
var iterator = array.entries();
console.log(iterator.next().value); // [0, &quot;a&quot;]
console.log(iterator.next().value); // [1, &quot;b&quot;]
console.log(iterator.next().value); // [2, &quot;c&quot;]
console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined
// find &amp; findIndex方法
var array = [1, 3, 5, 7, 8, 9, 10];
function f(value, index, array){
  return value%2==0;     // 返回偶数
}
function f2(value, index, array){
  return value &gt; 20;     // 返回大于20的数
}
console.log(array.find(f)); // 8
console.log(array.find(f2)); // undefined
console.log(array.findIndex(f)); // 4
console.log(array.findIndex(f2)); // -1
// keys方法
[...Array(10).keys()];     // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[...new Array(10).keys()]; // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// values方法
var array = [&quot;abc&quot;, &quot;xyz&quot;];
var iterator = array.values();
console.log(iterator.next().value);//abc
console.log(iterator.next().value);//xyz

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7. 总结</p><p><img src="/assets/20210414163215.a4477e4e.png" alt=""></p><blockquote><p>这些方法之间存在很多共性，如下：</p></blockquote><ul><li>所有插入元素的方法，比如 <code>push、unshift</code> 一律返回数组新的长度；</li><li>所有删除元素的方法，比如 <code>pop、shift、splice</code> 一律返回删除的元素，或者返回删除的多个元素组成的数组；</li><li>部分遍历方法，比如 <code>forEach、every、some、filter、map、find、findIndex</code>，它们都包含 <code>function(value,index,array){}</code> 和 <code>thisArg</code> 这样两个形参。</li></ul><blockquote><p>数组和字符串方法</p></blockquote><p><img src="/assets/20220307225257.063292fc.png" alt="">  <img src="/assets/20220307225258.99f77d4e.png" alt=""></p><p>二、理解JS的类数组</p><blockquote><p>在 JavaScript 中有哪些情况下的对象是类数组呢？主要有以下几种</p></blockquote><ul><li>函数里面的参数对象 <code>arguments</code>；</li><li>用 <code>getElementsByTagName/ClassName/Name</code> 获得的 <code>HTMLCollection</code></li><li>用 <code>querySelector</code> 获得的 <code>NodeList</code></li></ul><p>1. arguments对象</p><blockquote><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个<code>length</code>属性，我们可以使用数组索引表示法<code>arguments[1]</code>来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function foo(name, age, sex) {
    console.log(arguments);
    console.log(typeof arguments);
    console.log(Object.prototype.toString.call(arguments));
}
foo(&#39;jack&#39;, &#39;18&#39;, &#39;male&#39;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码比较容易，就是直接将这个函数的 arguments 在函数内部打印出来，那么我们看下这个 arguments 打印出来的结果，请看控制台的这张截图。</p><p><img src="/assets/20210414164546.c0ace29d.png" alt=""></p><blockquote><p>从结果中可以看到，<code>typeof</code> 这个 <code>arguments</code> 返回的是 <code>object</code>，通过 <code>Object.prototype.toString.call</code> 返回的结果是 <code>&#39;[object arguments]&#39;</code>，可以看出来返回的不是 <code>&#39;[object array]&#39;</code>，说明 <code>arguments</code> 和数组还是有区别的。</p></blockquote><p>我们可以使用<code>Array.prototype.slice</code>将<code>arguments</code>对象转换成一个数组。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function one() {
  return Array.prototype.slice.call(arguments);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意:箭头函数中没有arguments对象。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function one() {
  return arguments;
}
const two = function () {
  return arguments;
}
const three = function three() {
  return arguments;
}

const four = () =&gt; arguments;

four(); // Throws an error  - arguments is not defined

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>当我们调用函数four时，它会抛出一个ReferenceError: arguments is not defined error。使用rest语法，可以解决这个问题。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const four = (...args) =&gt; args;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这会自动将所有参数值放入数组中。</p><blockquote><p>arguments 不仅仅有一个 length 属性，还有一个 callee 属性，我们接下来看看这个 callee 是干什么的，代码如下所示</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function foo(name, age, sex) {
    console.log(arguments.callee);
}
foo(&#39;jack&#39;, &#39;18&#39;, &#39;male&#39;);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/assets/20210414164425.d9412924.png" alt=""></p><blockquote><p>从控制台可以看到，输出的就是函数自身，如果在函数内部直接执行调用 <code>callee</code> 的话，那它就会不停地执行当前函数，直到执行到内存溢出</p></blockquote><p>2. HTMLCollection</p><blockquote><p>HTMLCollection 简单来说是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象，如果用 typeof 来判断的话，它返回的是 &#39;object&#39;。它是及时更新的，当文档中的 DOM 变化时，它也会随之变化。</p></blockquote><p>描述起来比较抽象，还是通过一段代码来看下 <code>HTMLCollection</code> 最后返回的是什么，我们先随便找一个页面中有 form 表单的页面，在控制台中执行下述代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var elem1, elem2;
// document.forms 是一个 HTMLCollection
elem1 = document.forms[0];
elem2 = document.forms.item(0);
console.log(elem1);
console.log(elem2);
console.log(typeof elem1);
console.log(Object.prototype.toString.call(elem1));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个有 form 表单的页面执行上面的代码，得到的结果如下。</p><p><img src="/assets/20210414164820.9b7d1305.png" alt=""></p><p>可以看到，这里打印出来了页面第一个 form 表单元素，同时也打印出来了判断类型的结果，说明打印的判断的类型和 arguments 返回的也比较类似，typeof 返回的都是 &#39;object&#39;，和上面的类似。</p><p>另外需要注意的一点就是 HTML DOM 中的 HTMLCollection 是即时更新的，当其所包含的文档结构发生改变时，它会自动更新。下面我们再看最后一个 NodeList 类数组。</p><p>3. NodeList</p><blockquote><p>NodeList 对象是节点的集合，通常是由 querySlector 返回的。NodeList 不是一个数组，也是一种类数组。虽然 NodeList 不是一个数组，但是可以使用 for...of 来迭代。在一些情况下，NodeList 是一个实时集合，也就是说，如果文档中的节点树发生变化，NodeList 也会随之变化。我们还是利用代码来理解一下 Nodelist 这种类数组。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var list = document.querySelectorAll(&#39;input[type=checkbox]&#39;);
for (var checkbox of list) {
  checkbox.checked = true;
}
console.log(list);
console.log(typeof list);
console.log(Object.prototype.toString.call(list));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从上面的代码执行的结果中可以发现，我们是通过有 CheckBox 的页面执行的代码，在结果可中输出了一个 NodeList 类数组，里面有一个 CheckBox 元素，并且我们判断了它的类型，和上面的 arguments 与 HTMLCollection 其实是类似的，执行结果如下图所示。</p></blockquote><p><img src="/assets/20210414164939.f15b8602.png" alt=""></p><p>4. 类数组应用场景</p><blockquote><ol><li>遍历参数操作</li></ol></blockquote><p>我们在函数内部可以直接获取 <code>arguments</code> 这个类数组的值，那么也可以对于参数进行一些操作，比如下面这段代码，我们可以将函数的参数默认进行求和操作。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function add() {
    var sum =0,
        len = arguments.length;
    for(var i = 0; i &lt; len; i++){
        sum += arguments[i];
    }
    return sum;
}
add()                           // 0
add(1)                          // 1
add(1，2)                       // 3
add(1,2,3,4);                   // 10

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ol><li>定义链接字符串函数</li></ol></blockquote><p>我们可以通过 arguments 这个例子定义一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 这段代码说明了，你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表进行拼接。从这个例子中也可以看出，我们可以在日常编码中采用这样的代码抽象方式，把需要解决的这一类问题，都抽象成通用的方法，来提升代码的可复用性
function myConcat(separa) {
  var args = Array.prototype.slice.call(arguments, 1);
  return args.join(separa);
}
myConcat(&quot;, &quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;);
// &quot;red, orange, blue&quot;
myConcat(&quot;; &quot;, &quot;elephant&quot;, &quot;lion&quot;, &quot;snake&quot;);
// &quot;elephant; lion; snake&quot;
myConcat(&quot;. &quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
// &quot;one. two. three. four. five&quot;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ol><li>传递参数使用</li></ol></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 使用 apply 将 foo 的参数传递给 bar
function foo() {
    bar.apply(this, arguments);
}
function bar(a, b, c) {
   console.log(a, b, c);
}
foo(1, 2, 3)   //1 2 3

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5. 如何将类数组转换成数组</p><blockquote><ol><li>类数组借用数组方法转数组</li></ol></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function sum(a, b) {
  let args = Array.prototype.slice.call(arguments);
 // let args = [].slice.call(arguments); // 这样写也是一样效果
  console.log(args.reduce((sum, cur) =&gt; sum + cur));
}
sum(1, 2);  // 3
function sum(a, b) {
  let args = Array.prototype.concat.apply([], arguments);
  console.log(args.reduce((sum, cur) =&gt; sum + cur));
}
sum(1, 2);  // 3

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ol><li>ES6 的方法转数组</li></ol></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function sum(a, b) {
  let args = Array.from(arguments);
  console.log(args.reduce((sum, cur) =&gt; sum + cur));
}
sum(1, 2);    // 3
function sum(a, b) {
  let args = [...arguments];
  console.log(args.reduce((sum, cur) =&gt; sum + cur));
}
sum(1, 2);    // 3
function sum(...args) {
  console.log(args.reduce((sum, cur) =&gt; sum + cur));
}
sum(1, 2);    // 3

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>Array.from</code> 和 <code>ES6 的展开运算符</code>，都可以把 <code>arguments</code>这个类数组转换成数组 <code>args</code></p></blockquote><p>类数组和数组的异同点</p><p><img src="/assets/20210414165705.d93bd0f4.png" alt=""></p><blockquote><p>在前端工作中，开发者往往会忽视对类数组的学习，其实在高级 JavaScript 编程中经常需要将类数组向数组转化，尤其是一些比较复杂的开源项目，经常会看到函数中处理参数的写法，例如：<code>[].slice.call(arguments)</code> 这行代码。</p></blockquote><p>三、实现数组扁平化的 6 种方式</p><p>1. 方法一：普通的递归实</p><p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接。我们来看下这个方法是如何实现的，如下所示</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 方法1
var a = [1, [2, [3, 4, 5]]];
function flatten(arr) {
  let result = [];

  for(let i = 0; i &lt; arr.length; i++) {
    if(Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
flatten(a);  //  [1, 2, 3, 4，5]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>从上面这段代码可以看出，最后返回的结果是扁平化的结果，这段代码核心就是循环遍历过程中的递归操作，就是在遍历过程中发现数组元素还是数组的时候进行递归操作，把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上，那么最后输出的结果就是扁平化后的数组</p></blockquote><p>2. 方法二：利用 reduce 函数迭代</p><p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么我们其实也可以用 <code>reduce</code> 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 方法2
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.reduce(function(prev, next){
        return prev.concat(Array.isArray(next) ? flatten(next) : next)
    }, [])
}
console.log(flatten(arr));//  [1, 2, 3, 4，5]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3. 方法三：扩展运算符实现</p><p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的，还是来看一下代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 方法3
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
    while (arr.some(item =&gt; Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从执行的结果中可以发现，我们先用数组的 some 方法把数组中仍然是组数的项过滤出来，然后执行 concat 操作，利用 ES6 的展开运算符，将其拼接到原数组中，最后返回原数组，达到了预期的效果。</p><p>前三种实现数组扁平化的方式其实是最基本的思路，都是通过最普通递归思路衍生的方法，尤其是前两种实现方法比较类似。值得注意的是 reduce 方法，它可以在很多应用场景中实现，由于 reduce 这个方法提供的几个参数比较灵活，能解决很多问题，所以是值得熟练使用并且精通的</p><p>4. 方法四：split 和 toString 共同处理</p><blockquote><p>我们也可以通过 split 和 toString 两个方法，来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 方法4
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.toString().split(&#39;,&#39;);
}
console.log(flatten(arr)); //  [1, 2, 3, 4]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组，你可以在控制台执行一下查看结果。</p><p>5. 方法五：调用 ES6 中的 flat</p><p>我们还可以直接调用 ES6 中的 flat 方法，可以直接实现数组扁平化。先来看下 flat 方法的语法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>arr.flat([depth])

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。那么如果多层的该怎么处理呢？参数也可以传进 Infinity，代表不论多少层都要展开。那么我们来看下，用 flat 方法怎么实现，请看下面的代码。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 方法5
var arr = [1, [2, [3, 4]]];
function flatten(arr) {
  return arr.flat(Infinity);
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以看出，一个嵌套了两层的数组，通过将 <code>flat</code> 方法的参数设置为 <code>Infinity</code>，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。</li><li>因此，你在编程过程中，发现对数组的嵌套层数不确定的时候，最好直接使用 <code>Infinity</code>，可以达到扁平化。下面我们再来看最后一种场景</li></ul><p>6. 方法六：正则和 JSON 方法共同处理</p><blockquote><p>我们在第四种方法中已经尝试了用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组。请看下面的代码</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 方法 6
let arr = [1, [2, [3, [4, 5]]], 6];
function flatten(arr) {
  let str = JSON.stringify(arr);
  str = str.replace(/(\[|\])/g, &#39;&#39;);
  str = &#39;[&#39; + str + &#39;]&#39;;
  return JSON.parse(str);
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，其中先把传入的数组转换成字符串，然后通过正则表达式的方式把括号过滤掉，这部分正则的表达式你不太理解的话，可以看看下面的图片</p><p><img src="/assets/20210414170410.41da49af.png" alt=""></p><blockquote><p>通过这个在线网站 https://regexper.com/ 可以把正则分析成容易理解的可视化的逻辑脑图。其中我们可以看到，匹配规则是：全局匹配（g）左括号或者右括号，将它们替换成空格，最后返回处理后的结果。之后拿着正则处理好的结果重新在外层包裹括号，最后通过 JSON.parse 转换成数组返回。</p></blockquote><p><img src="/assets/20210414170438.c2105de4.png" alt=""></p><p>四、如何用 JS 实现各种数组排序</p><p>数据结构算法中排序有很多种，常见的、不常见的，至少包含十种以上。根据它们的特性，可以大致分为两种类型：比较类排序和非比较类排序。</p><ul><li>比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><p>我们通过一张图片来看看这两种分类方式分别包括哪些排序方法。</p><p><img src="/assets/20210414170747.0811997b.png" alt=""></p><p>非比较类的排序在实际情况中用的比较少</p><p>1. 冒泡排序</p><blockquote><p>冒泡排序是最基础的排序，一般在最开始学习数据结构的时候就会接触它。冒泡排序是一次比较两个元素，如果顺序是错误的就把它们交换过来。走访数列的工作会重复地进行，直到不需要再交换，也就是说该数列已经排序完成。请看下面的代码。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function bubbleSort(array) {
  const len = array.length
  if (len &lt; 2) return array
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; i; j++) {
      if (array[j] &gt; array[i]) {
        const temp = array[j]
        array[j] = array[i]
        array[i] = temp
      }
    }
  }
  return array
}
bubbleSort(a);  // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面这段代码可以看出，最后返回的是排好序的结果。因为冒泡排序实在太基础和简单，这里就不过多赘述了。下面我们来看看快速排序法</p><p>2. 快速排序</p><blockquote><p>快速排序的基本思想是通过一趟排序，将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function quickSort(array) {
  var quick = function(arr) {
    if (arr.length &lt;= 1) return arr
    const len = arr.length
    const index = Math.floor(len &gt;&gt; 1)
    const pivot = arr.splice(index, 1)[0]
    const left = []
    const right = []
    for (let i = 0; i &lt; len; i++) {
      if (arr[i] &gt; pivot) {
        right.push(arr[i])
      } else if (arr[i] &lt;= pivot) {
        left.push(arr[i])
      }
    }
    return quick(left).concat([pivot], quick(right))
  }
  const result = quick(array)
  return result
}
quickSort(a);//  [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>上面的代码在控制台执行之后，也可以得到预期的结果。最主要的思路是从数列中挑出一个元素，称为 &quot;基准&quot;（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成，这就是快排的思路。</p></blockquote><p>3. 插入排序</p><p>插入排序算法描述的是一种简单直观的排序算法。它的<code>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，从而达到排序的效果</code>。来看一下代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function insertSort(array) {
  const len = array.length
  let current
  let prev
  for (let i = 1; i &lt; len; i++) {
    current = array[i]
    prev = i - 1
    while (prev &gt;= 0 &amp;&amp; array[prev] &gt; current) {
      array[prev + 1] = array[prev]
      prev--
    }
    array[prev + 1] = current
  }
  return array
}
insertSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从执行的结果中可以发现，通过插入排序这种方式实现了排序效果。插入排序的思路是基于数组本身进行调整的，首先循环遍历从 i 等于 1 开始，拿到当前的 current 的值，去和前面的值比较，如果前面的大于当前的值，就把前面的值和当前的那个值进行交换，通过这样不断循环达到了排序的目的</p><p>4. 选择排序</p><p>选择排序是一种简单直观的排序算法。它的工作原理是，<code>首先将最小的元素存放在序列的起始位置，再从剩余未排序元素中继续寻找最小元素，然后放到已排序的序列后面......以此类推，直到所有元素均排序完毕</code>。请看下面的代码。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function selectSort(array) {
  const len = array.length
  let temp
  let minIndex
  for (let i = 0; i &lt; len - 1; i++) {
    minIndex = i
    for (let j = i + 1; j &lt; len; j++) {
      if (array[j] &lt;= array[minIndex]) {
        minIndex = j
      }
    }
    temp = array[i]
    array[i] = array[minIndex]
    array[minIndex] = temp
  }
  return array
}
selectSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，通过选择排序的方法同样也可以实现数组的排序，从上面的代码中可以看出该排序是表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n 平方) 的时间复杂度，所以用到它的时候，数据规模越小越好</p><p>5. 堆排序</p><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆的底层实际上就是一棵完全二叉树，可以用数组实现。</p><p>根节点最大的堆叫作大根堆，根节点最小的堆叫作小根堆，你可以根据从大到小排序或者从小到大来排序，分别建立对应的堆就可以。请看下面的代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function heap_sort(arr) {
  var len = arr.length
  var k = 0
  function swap(i, j) {
    var temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
  }
  function max_heapify(start, end) {
    var dad = start
    var son = dad * 2 + 1
    if (son &gt;= end) return
    if (son + 1 &lt; end &amp;&amp; arr[son] &lt; arr[son + 1]) {
      son++
    }
    if (arr[dad] &lt;= arr[son]) {
      swap(dad, son)
      max_heapify(son, end)
    }
  }
  for (var i = Math.floor(len / 2) - 1; i &gt;= 0; i--) {
    max_heapify(i, len)
  }

  for (var j = len - 1; j &gt; k; j--) {
    swap(0, j)
    max_heapify(0, j)
  }

  return arr
}
heap_sort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码来看，堆排序相比上面几种排序整体上会复杂一些，不太容易理解。不过你应该知道两点：</p><ul><li>一是堆排序最核心的点就在于排序前先建堆；</li><li>二是由于堆其实就是完全二叉树，如果父节点的序号为 n，那么叶子节点的序号就分别是 <code>2n</code> 和 <code>2n+1</code>。</li></ul><p>你理解了这两点，再看代码就比较好理解了。堆排序最后有两个循环：第一个是处理父节点的顺序；第二个循环则是根据父节点和叶子节点的大小对比，进行堆的调整。通过这两轮循环的调整，最后堆排序完成。</p><p>6. 归并排序</p><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。我们先看一下代码。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function mergeSort(array) {
  const merge = (right, left) =&gt; {
    const result = []
    let il = 0
    let ir = 0
    while (il &lt; left.length &amp;&amp; ir &lt; right.length) {
      if (left[il] &lt; right[ir]) {
        result.push(left[il++])
      } else {
        result.push(right[ir++])
      }
    }
    while (il &lt; left.length) {
      result.push(left[il++])
    }
    while (ir &lt; right.length) {
      result.push(right[ir++])
    }
    return result
  }
  const mergeSort = array =&gt; {
    if (array.length === 1) { return array }
    const mid = Math.floor(array.length / 2)
    const left = array.slice(0, mid)
    const right = array.slice(mid, array.length)
    return merge(mergeSort(left), mergeSort(right))
  }
  return mergeSort(array)
}
mergeSort(a); // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面这段代码中可以看到，通过归并排序可以得到想要的结果。上面提到了分治的思路，你可以从 mergeSort 方法中看到，通过 mid 可以把该数组分成左右两个数组，分别对这两个进行递归调用排序方法，最后将两个数组按照顺序归并起来。</p><p>归并排序是一种稳定的排序方法，和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好得多，因为始终都是 O(nlogn) 的时间复杂度。而代价是需要额外的内存空间。</p><p><img src="/assets/20210414171508.b695278a.png" alt=""></p><p>其中你可以看到排序相关的时间复杂度和空间复杂度以及稳定性的情况，如果遇到需要自己实现排序的时候，可以根据它们的空间和时间复杂度综合考量，选择最适合的排序方法</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/advanced/HTML.html" class="" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.12353158.js" defer></script>
  </body>
</html>
