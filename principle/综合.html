<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>综合 | Frontend Starter</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.12353158.js"><link rel="modulepreload" href="/assets/综合.html.ff78888d.js"><link rel="modulepreload" href="/assets/综合.html.30e0bc70.js"><link rel="prefetch" href="/assets/index.html.ee998a26.js"><link rel="prefetch" href="/assets/CSS.html.c64e9431.js"><link rel="prefetch" href="/assets/HTML.html.a70e4433.js"><link rel="prefetch" href="/assets/HTTP.html.6dbdd949.js"><link rel="prefetch" href="/assets/JS基础.html.0a913d15.js"><link rel="prefetch" href="/assets/React.html.6802a56c.js"><link rel="prefetch" href="/assets/Vue.html.a81339b7.js"><link rel="prefetch" href="/assets/工程化.html.0c152696.js"><link rel="prefetch" href="/assets/性能.html.090fde92.js"><link rel="prefetch" href="/assets/框架通识.html.1a3f58ab.js"><link rel="prefetch" href="/assets/浏览器.html.2ec19a51.js"><link rel="prefetch" href="/assets/设计模式.html.5761cd54.js"><link rel="prefetch" href="/assets/Bootstrap.html.86ad9734.js"><link rel="prefetch" href="/assets/CSS.html.e3ee6176.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.6603dd61.js"><link rel="prefetch" href="/assets/JavaScript.html.14aca0a4.js"><link rel="prefetch" href="/assets/Webpack.html.f773c5e1.js"><link rel="prefetch" href="/assets/jQuery.html.c3b9972e.js"><link rel="prefetch" href="/assets/其他.html.c716f6ee.js"><link rel="prefetch" href="/assets/微信小程序.html.0335a142.js"><link rel="prefetch" href="/assets/综合.html.5dfe757e.js"><link rel="prefetch" href="/assets/编程题.html.cbfc1c8c.js"><link rel="prefetch" href="/assets/性能优化.html.30c3f1c5.js"><link rel="prefetch" href="/assets/高频考点.html.2ee4efd2.js"><link rel="prefetch" href="/assets/handwritten.html.879fcb5e.js"><link rel="prefetch" href="/assets/JavaScript.html.bcb5a0d9.js"><link rel="prefetch" href="/assets/Node.html.be9ed4e1.js"><link rel="prefetch" href="/assets/React.html.36beeb6b.js"><link rel="prefetch" href="/assets/Vue.html.b739e835.js"><link rel="prefetch" href="/assets/Webpack.html.b34fb870.js"><link rel="prefetch" href="/assets/CSS模块.html.99bd45d7.js"><link rel="prefetch" href="/assets/ES6模块.html.0f2bfddb.js"><link rel="prefetch" href="/assets/HTML模块.html.4fb65265.js"><link rel="prefetch" href="/assets/HTTP模块.html.b4ce19f7.js"><link rel="prefetch" href="/assets/JS模块.html.015ff251.js"><link rel="prefetch" href="/assets/Node模块.html.b1985276.js"><link rel="prefetch" href="/assets/React模块.html.f53e1f03.js"><link rel="prefetch" href="/assets/Vue模块.html.785747a6.js"><link rel="prefetch" href="/assets/前端安全模块.html.f0f98ff3.js"><link rel="prefetch" href="/assets/前端工程相关.html.183e2c9f.js"><link rel="prefetch" href="/assets/小程序模块.html.f7ab4d91.js"><link rel="prefetch" href="/assets/常用设计模式.html.03f9722f.js"><link rel="prefetch" href="/assets/性能优化相关.html.12e8a2e3.js"><link rel="prefetch" href="/assets/排序算法.html.40481e91.js"><link rel="prefetch" href="/assets/框架通识.html.c3c3096b.js"><link rel="prefetch" href="/assets/浏览器模块.html.24652566.js"><link rel="prefetch" href="/assets/移动多端开发.html.8636371c.js"><link rel="prefetch" href="/assets/计算机通识.html.728b7ceb.js"><link rel="prefetch" href="/assets/404.html.93c18560.js"><link rel="prefetch" href="/assets/index.html.60500264.js"><link rel="prefetch" href="/assets/CSS.html.02fa634c.js"><link rel="prefetch" href="/assets/HTML.html.3a31cd64.js"><link rel="prefetch" href="/assets/HTTP.html.a1df6d3a.js"><link rel="prefetch" href="/assets/JS基础.html.b88ab559.js"><link rel="prefetch" href="/assets/React.html.4ec983c7.js"><link rel="prefetch" href="/assets/Vue.html.5c58cab9.js"><link rel="prefetch" href="/assets/工程化.html.863e35db.js"><link rel="prefetch" href="/assets/性能.html.470e0a6f.js"><link rel="prefetch" href="/assets/框架通识.html.32d2fbab.js"><link rel="prefetch" href="/assets/浏览器.html.8279ebd9.js"><link rel="prefetch" href="/assets/设计模式.html.6afe6cf3.js"><link rel="prefetch" href="/assets/Bootstrap.html.2cc414a0.js"><link rel="prefetch" href="/assets/CSS.html.5d66e791.js"><link rel="prefetch" href="/assets/HTTP _ HTML.html.bbea8927.js"><link rel="prefetch" href="/assets/JavaScript.html.07acfd24.js"><link rel="prefetch" href="/assets/Webpack.html.a1c5dce1.js"><link rel="prefetch" href="/assets/jQuery.html.4e2f3899.js"><link rel="prefetch" href="/assets/其他.html.929587e1.js"><link rel="prefetch" href="/assets/微信小程序.html.69cc86fd.js"><link rel="prefetch" href="/assets/综合.html.1c892aa5.js"><link rel="prefetch" href="/assets/编程题.html.5478af99.js"><link rel="prefetch" href="/assets/性能优化.html.337c4654.js"><link rel="prefetch" href="/assets/高频考点.html.8772c401.js"><link rel="prefetch" href="/assets/handwritten.html.0f0ee7e3.js"><link rel="prefetch" href="/assets/JavaScript.html.5dd72bd0.js"><link rel="prefetch" href="/assets/Node.html.7eac5124.js"><link rel="prefetch" href="/assets/React.html.d8ccb952.js"><link rel="prefetch" href="/assets/Vue.html.47efbab1.js"><link rel="prefetch" href="/assets/Webpack.html.793df544.js"><link rel="prefetch" href="/assets/CSS模块.html.bcc3cfc7.js"><link rel="prefetch" href="/assets/ES6模块.html.2ea3507a.js"><link rel="prefetch" href="/assets/HTML模块.html.6b729342.js"><link rel="prefetch" href="/assets/HTTP模块.html.2c6adffa.js"><link rel="prefetch" href="/assets/JS模块.html.28259fe6.js"><link rel="prefetch" href="/assets/Node模块.html.c36cd1fb.js"><link rel="prefetch" href="/assets/React模块.html.b09a5954.js"><link rel="prefetch" href="/assets/Vue模块.html.a27ab950.js"><link rel="prefetch" href="/assets/前端安全模块.html.e3aebe2f.js"><link rel="prefetch" href="/assets/前端工程相关.html.281b6ffe.js"><link rel="prefetch" href="/assets/小程序模块.html.493268db.js"><link rel="prefetch" href="/assets/常用设计模式.html.a600f326.js"><link rel="prefetch" href="/assets/性能优化相关.html.aff23982.js"><link rel="prefetch" href="/assets/排序算法.html.361967d5.js"><link rel="prefetch" href="/assets/框架通识.html.7719e539.js"><link rel="prefetch" href="/assets/浏览器模块.html.ac4e495d.js"><link rel="prefetch" href="/assets/移动多端开发.html.d8fc5993.js"><link rel="prefetch" href="/assets/计算机通识.html.0e8ab127.js"><link rel="prefetch" href="/assets/404.html.232c3875.js"><link rel="prefetch" href="/assets/404.176778df.js"><link rel="prefetch" href="/assets/Layout.ac3a6e88.js">
    <link rel="stylesheet" href="/assets/style.20e644be.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Frontend Starter</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">基础 Basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/basic/HTTP%20&amp;%20HTML.html" class="sidebar-item" aria-label="HTML、HTTP、Web"><!--[--><!--]--> HTML、HTTP、Web <!--[--><!--]--></a><!----></li><li><a href="/basic/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/basic/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/basic/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/basic/Bootstrap.html" class="sidebar-item" aria-label="Bootstrap"><!--[--><!--]--> Bootstrap <!--[--><!--]--></a><!----></li><li><a href="/basic/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BC%96%E7%A8%8B%E9%A2%98.html" class="sidebar-item" aria-label="编程题"><!--[--><!--]--> 编程题 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E5%85%B6%E4%BB%96.html" class="sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----></li><li><a href="/basic/%E7%BB%BC%E5%90%88.html" class="sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">进阶 Advanced <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/advanced/JS%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="JS基础"><!--[--><!--]--> JS基础 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/advanced/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%B5%8F%E8%A7%88%E5%99%A8.html" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/advanced/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/advanced/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E6%80%A7%E8%83%BD.html" class="sidebar-item" aria-label="性能"><!--[--><!--]--> 性能 <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="sidebar-item" aria-label="工程化"><!--[--><!--]--> 工程化 <!--[--><!--]--></a><!----></li><li><a href="/advanced/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/advanced/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">精选 Selected <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/selected/HTML%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTML模块"><!--[--><!--]--> HTML模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/CSS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="CSS模块"><!--[--><!--]--> CSS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/JS%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="JS模块"><!--[--><!--]--> JS模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/ES6%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="ES6模块"><!--[--><!--]--> ES6模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="浏览器模块"><!--[--><!--]--> 浏览器模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/React%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="React模块"><!--[--><!--]--> React模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Vue%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Vue模块"><!--[--><!--]--> Vue模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/Node%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="Node模块"><!--[--><!--]--> Node模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="前端工程相关"><!--[--><!--]--> 前端工程相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="移动多端开发"><!--[--><!--]--> 移动多端开发 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="小程序模块"><!--[--><!--]--> 小程序模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="前端安全模块"><!--[--><!--]--> 前端安全模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3.html" class="sidebar-item" aria-label="性能优化相关"><!--[--><!--]--> 性能优化相关 <!--[--><!--]--></a><!----></li><li><a href="/selected/HTTP%E6%A8%A1%E5%9D%97.html" class="sidebar-item" aria-label="HTTP模块"><!--[--><!--]--> HTTP模块 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="sidebar-item" aria-label="常用设计模式"><!--[--><!--]--> 常用设计模式 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="框架通识"><!--[--><!--]--> 框架通识 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/selected/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" class="sidebar-item" aria-label="计算机通识"><!--[--><!--]--> 计算机通识 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">高频 Frequency <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/frequency/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" class="sidebar-item" aria-label="高频考点"><!--[--><!--]--> 高频考点 <!--[--><!--]--></a><!----></li><li><a href="/frequency/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">原理 Principle <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/principle/React.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/principle/Vue.html" class="sidebar-item" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/principle/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/principle/Node.html" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><li><a href="/principle/JavaScript.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#什么是-virtual-dom" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是 Virtual DOM"><!--[--><!--]--> 什么是 Virtual DOM <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#为什么使用-virtual-dom" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么使用 Virtual DOM"><!--[--><!--]--> 为什么使用 Virtual DOM <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#虚拟-dom-的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="虚拟 DOM 的作用"><!--[--><!--]--> 虚拟 DOM 的作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#virtual-dom-库" class="router-link-active router-link-exact-active sidebar-item" aria-label="Virtual DOM 库"><!--[--><!--]--> Virtual DOM 库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#snabbdom-基本使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="Snabbdom 基本使用"><!--[--><!--]--> Snabbdom 基本使用 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#创建项目" class="router-link-active router-link-exact-active sidebar-item" aria-label="创建项目"><!--[--><!--]--> 创建项目 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#基本使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本使用"><!--[--><!--]--> 基本使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#模块" class="router-link-active router-link-exact-active sidebar-item" aria-label="模块"><!--[--><!--]--> 模块 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#snabbdom-源码解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="Snabbdom 源码解析"><!--[--><!--]--> Snabbdom 源码解析 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#snabbdom-的核心" class="router-link-active router-link-exact-active sidebar-item" aria-label="Snabbdom 的核心"><!--[--><!--]--> Snabbdom 的核心 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#h-函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="h 函数"><!--[--><!--]--> h 函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#vnode" class="router-link-active router-link-exact-active sidebar-item" aria-label="VNode"><!--[--><!--]--> VNode <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#snabbdom" class="router-link-active router-link-exact-active sidebar-item" aria-label="snabbdom"><!--[--><!--]--> snabbdom <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#init" class="router-link-active router-link-exact-active sidebar-item" aria-label="init"><!--[--><!--]--> init <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#patch" class="router-link-active router-link-exact-active sidebar-item" aria-label="patch"><!--[--><!--]--> patch <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#createelm" class="router-link-active router-link-exact-active sidebar-item" aria-label="createElm"><!--[--><!--]--> createElm <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#patchvnode" class="router-link-active router-link-exact-active sidebar-item" aria-label="patchVnode"><!--[--><!--]--> patchVnode <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/principle/%E7%BB%BC%E5%90%88.html#updatechildren" class="router-link-active router-link-exact-active sidebar-item" aria-label="updateChildren"><!--[--><!--]--> updateChildren <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="综合" tabindex="-1"><a class="header-anchor" href="#综合" aria-hidden="true">#</a> 综合</h1><hr><h2 id="什么是-virtual-dom" tabindex="-1"><a class="header-anchor" href="#什么是-virtual-dom" aria-hidden="true">#</a> 什么是 Virtual DOM</h2><ol><li><code>Virtual DOM</code>(虚拟 DOM)，是由普通的 <code>JS</code> 对象来描述 <code>DOM</code> 对象，因为不是真实的 <code>DOM</code> 对象，所以叫 <code>Virtual DOM</code></li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let element = document.querySelector(&#39;#app&#39;)
let s = &#39;&#39;
for (var key in element) {
  s += key + &#39;,&#39;
}
console.log(s)

// 打印结果 align,title,lang,translate,dir,hidden,accessKey,draggable,spellcheck,aut ocapitalize,contentEditable,isContentEditable,inputMode,offsetParent,off setTop,offsetLeft,offsetWidth,offsetHeight,style,innerText,outerText,onc opy,oncut,onpaste,onabort,onblur,oncancel,oncanplay,oncanplaythrough,onc hange,onclick,onclose,oncontextmenu,oncuechange,ondblclick,ondrag,ondrag end,ondragenter,ondragleave,ondragover,ondragstart,ondrop,ondurationchan ge,onemptied,onended,onerror,onfocus,oninput,oninvalid,onkeydown,onkeypr ess,onkeyup,onload,onloadeddata,onloadedmetadata,onloadstart,onmousedown ,onmouseenter,onmouseleave,onmousemove,onmouseout,onmouseover,onmouseup, onmousewheel,onpause,onplay,onplaying,onprogress,onratechange,onreset,on resize,onscroll,onseeked,onseeking,onselect,onstalled,onsubmit,onsuspend ,ontimeupdate,ontoggle,onvolumechange,onwaiting,onwheel,onauxclick,ongot pointercapture,onlostpointercapture,onpointerdown,onpointermove,onpointe rup,onpointercancel,onpointerover,onpointerout,onpointerenter,onpointerl eave,onselectstart,onselectionchange,onanimationend,onanimationiteration ,onanimationstart,ontransitionend,dataset,nonce,autofocus,tabIndex,click ,focus,blur,enterKeyHint,onformdata,onpointerrawupdate,attachInternals,n amespaceURI,prefix,localName,tagName,id,className,classList,slot,part,at tributes,shadowRoot,assignedSlot,innerHTML,outerHTML,scrollTop,scrollLef t,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight ,attributeStyleMap,onbeforecopy,onbeforecut,onbeforepaste,onsearch,eleme ntTiming,previousElementSibling,nextElementSibling,children,firstElement Child,lastElementChild,childElementCount,onfullscreenchange,onfullscreen error,onwebkitfullscreenchange,onwebkitfullscreenerror,setPointerCapture ,releasePointerCapture,hasPointerCapture,hasAttributes,getAttributeNames ,getAttribute,getAttributeNS,setAttribute,setAttributeNS,removeAttribute ,removeAttributeNS,hasAttribute,hasAttributeNS,toggleAttribute,getAttrib uteNode,getAttributeNodeNS,setAttributeNode,setAttributeNodeNS,removeAtt ributeNode,closest,matches,webkitMatchesSelector,attachShadow,getElement sByTagName,getElementsByTagNameNS,getElementsByClassName,insertAdjacentE lement,insertAdjacentText,insertAdjacentHTML,requestPointerLock,getClien tRects,getBoundingClientRect,scrollIntoView,scroll,scrollTo,scrollBy,scr ollIntoViewIfNeeded,animate,computedStyleMap,before,after,replaceWith,re move,prepend,append,querySelector,querySelectorAll,requestFullscreen,web kitRequestFullScreen,webkitRequestFullscreen,createShadowRoot,getDestina tionInsertionPoints,ELEMENT_NODE,ATTRIBUTE_NODE,TEXT_NODE,CDATA_SECTION_ NODE,ENTITY_REFERENCE_NODE,ENTITY_NODE,PROCESSING_INSTRUCTION_NODE,COMME NT_NODE,DOCUMENT_NODE,DOCUMENT_TYPE_NODE,DOCUMENT_FRAGMENT_NODE,NOTATION _NODE,DOCUMENT_POSITION_DISCONNECTED,DOCUMENT_POSITION_PRECEDING,DOCUMEN T_POSITION_FOLLOWING,DOCUMENT_POSITION_CONTAINS,DOCUMENT_POSITION_CONTAI NED_BY,DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC,nodeType,nodeName,baseU RI,isConnected,ownerDocument,parentNode,parentElement,childNodes,firstCh ild,lastChild,previousSibling,nextSibling,nodeValue,textContent,hasChild Nodes,getRootNode,normalize,cloneNode,isEqualNode,isSameNode,compareDocu mentPosition,contains,lookupPrefix,lookupNamespaceURI,isDefaultNamespace ,insertBefore,appendChild,replaceChild,removeChild,addEventListener,remo veEventListener,dispatchEvent

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>可以使用 <code>Virtual DOM</code> 来描述真实 <code>DOM</code></li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{
  sel: &quot;div&quot;,
  data: {},
  children: undefined,
  text: &quot;Hello Virtual DOM&quot;,
  elm: undefined,
  key: undefined
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="为什么使用-virtual-dom" tabindex="-1"><a class="header-anchor" href="#为什么使用-virtual-dom" aria-hidden="true">#</a> 为什么使用 Virtual DOM</h2><ul><li>手动操作 <code>DOM</code> 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 <code>jQuery</code> 等库简化 <code>DOM</code> 操作，但是随着项目的复杂 DOM 操作复杂提升</li><li>为了简化 <code>DOM</code> 的复杂操作于是出现了各种 <code>MVVM</code> 框架，<code>MVVM</code> 框架解决了视图和状态的同步问题</li><li>为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是<code>Virtual DOM</code> 出现了</li><li><code>Virtual DOM</code> 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述<code>DOM</code>，<code>Virtual DOM</code> 内部将弄清楚如何有效(<code>diff</code>)的更新 <code>DOM</code></li><li>虚拟 <code>DOM</code> 可以维护程序的状态，跟踪上一次的状态</li><li>通过比较前后两次状态的差异更新真实 <code>DOM</code></li></ul><h2 id="虚拟-dom-的作用" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-的作用" aria-hidden="true">#</a> 虚拟 DOM 的作用</h2><ul><li>维护视图和状态的关系</li><li>复杂视图情况下提升渲染性能</li><li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li></ul><p><img src="https://s.poetries.work/images/20210328112610.png" alt=""></p><h2 id="virtual-dom-库" tabindex="-1"><a class="header-anchor" href="#virtual-dom-库" aria-hidden="true">#</a> Virtual DOM 库</h2><ul><li><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">Snabbdom(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><ul><li><code>Vue 2.x</code> 内部使用的 <code>Virtual DOM</code> 就是改造的 <code>Snabbdom</code></li><li>通过模块可扩展</li><li>源码使用 <code>TypeScript</code> 开发</li><li>最快的 <code>Virtual DOM</code> 之一</li></ul></li><li><a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener noreferrer">virtual-dom(opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="snabbdom-基本使用" tabindex="-1"><a class="header-anchor" href="#snabbdom-基本使用" aria-hidden="true">#</a> Snabbdom 基本使用</h2><h3 id="创建项目" tabindex="-1"><a class="header-anchor" href="#创建项目" aria-hidden="true">#</a> 创建项目</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code># 创建项目目录
md snabbdom-demo
# 进入项目目录
cd snabbdom-demo
# 创建 package.json yarn init -y
# 本地安装 parcel
yarn add parcel-bundler

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置 <code>package.json</code> 的 <code>scripts</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&quot;scripts&quot;: {
&quot;dev&quot;: &quot;parcel index.html --open&quot;, &quot;build&quot;: &quot;parcel build index.html&quot;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建目录结构</p><p><img src="https://s.poetries.work/images/20210328123653.png" alt=""></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>yarn add snabbdom

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import{init,h,thunk}from&#39;snabbdom&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>snabbdom</code> 的核心仅提供最基本的功能，只导出了三个函数 <code>init()</code>、<code>h()</code>、<code>thunk()</code></p></blockquote><ul><li><code>init()</code> 是一个高阶函数，返回 <code>patch()</code></li><li><code>h()</code> 返回虚拟节点 <code>VNode</code>，这个函数我们在使用 <code>Vue.js</code> 的时候见过</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>new Vue({
  router,
  store,
  render: h =&gt; h(App)
}).$mount(&#39;#app&#39;)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>thunk()</code> 是一种优化策略，可以在处理不可变数据时使用</li></ul><blockquote><p>注意:导入时候不能使用 <code>import snabbdom from &#39;snabbdom&#39;</code>。原因:<code>node_modules/src/snabbdom.ts</code> 末尾导出使用的语法是 <code>export</code> 导出 <code>API</code>，没有使用 <code>export default</code> 导出默认输出</p></blockquote><p><img src="https://s.poetries.work/images/20210328124133.png" alt=""></p><h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h3><p>例子1</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { h, init } from &#39;snabbdom&#39;

// 1. hello world
// 参数：数组，模块
// 返回值：patch函数，作用对比两个vnode的差异更新到真实DOM
let patch = init([])
// 第一个参数：标签+选择器
// 第二个参数：如果是字符串的话就是标签中的内容
let vnode = h(&#39;div#container.cls&#39;, {
  hook: {
    init (vnode) {
      console.log(vnode.elm)
    },
    create (emptyVnode, vnode) {
      console.log(vnode.elm)
    }
  }
}, &#39;Hello World&#39;)

let app = document.querySelector(&#39;#app&#39;)
// 第一个参数：可以是DOM元素，内部会把DOM元素转换成VNode
// 第二个参数：VNode
// 返回值：VNde
let oldVnode = patch(app, vnode)

// 假设的时刻
vnode = h(&#39;div&#39;, &#39;Hello Snabbdom&#39;)

patch(oldVnode, vnode)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子2</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 2. div中放置子元素 h1,p
import { h, init } from &#39;snabbdom&#39;

let patch = init([])

let vnode = h(&#39;div#container&#39;, [
  h(&#39;h1&#39;, &#39;Hello Snabbdom&#39;),
  h(&#39;p&#39;, &#39;这是一个p标签&#39;)
])

let app = document.querySelector(&#39;#app&#39;)

let oldVnode = patch(app, vnode)

setTimeout(() =&gt; {
  vnode = h(&#39;div#container&#39;, [
    h(&#39;h1&#39;, &#39;Hello World&#39;),
    h(&#39;p&#39;, &#39;Hello P&#39;)
  ])
  patch(oldVnode, vnode)

  // 清空页面元素 -- 错误
  // patch(oldVnode, null)
  patch(oldVnode, h(&#39;!&#39;))
}, 2000);

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子3 debug-patchVnode</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { h, init } from &#39;snabbdom&#39;

let patch = init([])

// 首次渲染
let vnode = h(&#39;div&#39;, &#39;Hello World&#39;)
let app = document.querySelector(&#39;#app&#39;)
let oldVnode = patch(app, vnode)

// patchVnode 的执行过程
vnode = h(&#39;div&#39;, &#39;Hello Snabbdom&#39;)
patch(oldVnode, vnode)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子4 debug-updateChildren</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { h, init } from &#39;snabbdom&#39;

let patch = init([])

// 首次渲染
let vnode = h(&#39;ul&#39;, [
  h(&#39;li&#39;, &#39;首页&#39;),
  h(&#39;li&#39;, &#39;视频&#39;),
  h(&#39;li&#39;, &#39;微博&#39;)
])
let app = document.querySelector(&#39;#app&#39;)
let oldVnode = patch(app, vnode)

// updateChildren 的执行过程
vnode = h(&#39;ul&#39;, [
  h(&#39;li&#39;, &#39;首页&#39;),
  h(&#39;li&#39;, &#39;微博&#39;),
  h(&#39;li&#39;, &#39;视频&#39;)
])
patch(oldVnode, vnode)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子5 debug-updateChildren-key</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { h, init } from &#39;snabbdom&#39;

let patch = init([])

// 首次渲染
let vnode = h(&#39;ul&#39;, [
  h(&#39;li&#39;, { key: &#39;a&#39; }, &#39;首页&#39;),
  h(&#39;li&#39;, { key: &#39;b&#39; }, &#39;视频&#39;),
  h(&#39;li&#39;, { key: &#39;c&#39; }, &#39;微博&#39;)
])
let app = document.querySelector(&#39;#app&#39;)
let oldVnode = patch(app, vnode)

// updateChildren 的执行过程
vnode = h(&#39;ul&#39;, [
  h(&#39;li&#39;, { key: &#39;a&#39; }, &#39;首页&#39;),
  h(&#39;li&#39;, { key: &#39;c&#39; }, &#39;微博&#39;),
  h(&#39;li&#39;, { key: &#39;b&#39; }, &#39;视频&#39;)
])
patch(oldVnode, vnode)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h3><blockquote><p><code>Snabbdom</code> 的核心库并不能处理元素的<code>属性/样式/事件</code>等，如果需要处理的话，可以使用模块</p></blockquote><p>常用模块</p><p>官方提供了 6 个模块</p><ul><li><code>attributes</code><ul><li>设置 <code>DOM</code> 元素的属性，使用 <code>setAttribute ()</code></li><li>处理布尔类型的属性</li></ul></li><li><code>props</code><ul><li>和 <code>attributes</code> 模块相似，设置 <code>DOM</code> 元素的属性 <code>element[attr] = value</code></li><li>不处理布尔类型的属性</li></ul></li><li><code>class</code><ul><li>切换类样式</li><li>注意:给元素设置类样式是通过 <code>sel</code> 选择器</li></ul></li><li><code>dataset</code><ul><li>设置 <code>data-*</code> 的自定义属性 <code>eventlisteners</code></li><li>注册和移除事件</li></ul></li><li><code>style</code><ul><li>设置行内样式，支持动画</li><li><code>delayed/remove/destroy</code></li></ul></li></ul><p>模块使用</p><blockquote><p>模块使用步骤:</p></blockquote><ul><li>导入需要的模块</li><li><code>init()</code> 中注册模块</li><li>使用 <code>h()</code> 函数创建 <code>VNode</code> 的时候，可以把第二个参数设置为对象，其他参数往后移</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import { init, h } from &#39;snabbdom&#39;
// 1. 导入模块
import style from &#39;snabbdom/modules/style&#39;
import eventlisteners from &#39;snabbdom/modules/eventlisteners&#39;
// 2. 注册模块
let patch = init([
  style,
  eventlisteners
])
// 3. 使用 h() 函数的第二个参数传入模块需要的数据（对象）
let vnode = h(&#39;div&#39;, {
  style: {
    backgroundColor: &#39;red&#39;
  },
  on: {
    click: eventHandler
  }
}, [
  h(&#39;h1&#39;, &#39;Hello Snabbdom&#39;),
  h(&#39;p&#39;, &#39;这是p标签&#39;)
])

function eventHandler () {
  console.log(&#39;点击我了&#39;)
}

let app = document.querySelector(&#39;#app&#39;)

let oldVnode = patch(app, vnode)

vnode = h(&#39;div&#39;, &#39;hello&#39;)
patch(oldVnode, vnode)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="snabbdom-源码解析" tabindex="-1"><a class="header-anchor" href="#snabbdom-源码解析" aria-hidden="true">#</a> Snabbdom 源码解析</h2><h3 id="snabbdom-的核心" tabindex="-1"><a class="header-anchor" href="#snabbdom-的核心" aria-hidden="true">#</a> Snabbdom 的核心</h3><ul><li>使用 <code>h()</code> 函数创建 JavaScript 对象(<code>VNode</code>)描述真实 DOM</li><li><code>init()</code> 设置模块，创建 <code>patch()</code></li><li><code>patch()</code> 比较新旧两个 <code>VNode</code></li><li>把变化的内容更新到真实 <code>DOM</code> 树上</li></ul><p>Snabbdom 源码</p><blockquote><p>源码地址: https://github.com/snabbdom/snabbdom</p></blockquote><p>src 目录结构</p><p><img src="https://s.poetries.work/images/20210328125857.png" alt=""></p><h3 id="h-函数" tabindex="-1"><a class="header-anchor" href="#h-函数" aria-hidden="true">#</a> h 函数</h3><ul><li><code>h()</code> 函数介绍: 在使用 <code>Vue</code> 的时候见过 <code>h()</code> 函数</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>new Vue({
  router,
  store,
  render: h =&gt; h(App)
}).$mount(&#39;#app&#39;)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>h()</code> 函数最早见于 <code>hyperscript</code>，使用 JavaScript 创建超文本</li><li>Snabbdom 中的 <code>h()</code> 函数不是用来创建超文本，而是创建 <code>VNode</code></li></ul><p>函数重载</p><ul><li>概念</li><li>参数个数或类型不同的函数</li><li><code>JavaScript</code> 中没有重载的概念</li><li><code>TypeScript</code> 中有重载，不过重载的实现还是通过代码调整参数</li><li>重载的示意</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function add (a, b) {
  console.log(a + b)
}
function add (a, b, c) {
  console.log(a + b + c)
}
add(1, 2)
add(1, 2, 3)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>源码位置:<code>src/h.ts</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// h函数的重载
export function h (sel: string): VNode
export function h (sel: string, data: VNodeData | null): VNode
export function h (sel: string, children: VNodeChildren): VNode
export function h (sel: string, data: VNodeData | null, children: VNodeChildren): VNode
export function h (sel: any, b?: any, c?: any): VNode {
  let data: VNodeData = {}
  let children: any
  let text: any
  let i: number
  // 处理参数，实现重载的机制
  if (c !== undefined) {
    // 处理三个参数的情况
    // sel、data、children/text
    if (b !== null) {
      data = b
    }
    if (is.array(c)) {
      children = c
      // 如果 c 是字符串或者数字
    } else if (is.primitive(c)) {
      text = c
    } else if (c &amp;&amp; c.sel) {
      children = [c]
    }
  } else if (b !== undefined &amp;&amp; b !== null) {
    // 处理两个参数的情况
    if (is.array(b)) {
      children = b
      // 如果 b 是字符串或者数字
    } else if (is.primitive(b)) {
      text = b
      // 如果 b 是 VNode
    } else if (b &amp;&amp; b.sel) {
      children = [b]
    } else { data = b }
  }
  if (children !== undefined) {
    // 处理 children 中的原始值(string/number)
    for (i = 0; i &lt; children.length; ++i) {
      // 如果 child 是 string/number，创建文本节点
      if (is.primitive(children[i])) children[i] = vnode(undefined, undefined, undefined, children[i], undefined)
    }
  }
  if (
    sel[0] === &#39;s&#39; &amp;&amp; sel[1] === &#39;v&#39; &amp;&amp; sel[2] === &#39;g&#39; &amp;&amp;
    (sel.length === 3 || sel[3] === &#39;.&#39; || sel[3] === &#39;#&#39;)
  ) {
    // 如果是 svg，添加命名空间
    addNS(data, children, sel)
  }
  // 返回 VNode
  return vnode(sel, data, children, text, undefined)
};

// 导出模块
export default h;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vnode" tabindex="-1"><a class="header-anchor" href="#vnode" aria-hidden="true">#</a> VNode</h3><blockquote><p>一个 <code>VNode</code> 就是一个虚拟节点用来描述一个 <code>DOM</code> 元素，如果这个 <code>VNode</code> 有 <code>children</code> 就是 <code>Virtual DOM</code></p></blockquote><p>源码位置: <code>src/vnode.ts</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>export interface VNodeData {
  props?: Props
  attrs?: Attrs
  class?: Classes
  style?: VNodeStyle
  dataset?: Dataset
  on?: On
  hero?: Hero
  attachData?: AttachData
  hook?: Hooks
  key?: Key
  ns?: string // for SVGs
  fn?: () =&gt; VNode // for thunks
  args?: any[] // for thunks
  is?: string // for custom elements v1
  [key: string]: any // for any other 3rd party module
}

export interface VNode {
  // 选择器
  sel: string | undefined
  // 节点数据:属性/样式/事件等
  data: VNodeData | undefined
  // 子节点，和 text 只能互斥
  children: Array&lt;VNode | string&gt; | undefined
  // 记录 vnode 对应的真实 DOM
  elm: Node | undefined
  // 节点中的内容，和 children 只能互斥
  text: string | undefined
  // 优化用
  key: Key | undefined
}

export function vnode (sel: string | undefined,
  data: any | undefined,
  children: Array&lt;VNode | string&gt; | undefined,
  text: string | undefined,
  elm: Element | Text | undefined): VNode {
  const key = data === undefined ? undefined : data.key
  return { sel, data, children, text, elm, key }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="snabbdom" tabindex="-1"><a class="header-anchor" href="#snabbdom" aria-hidden="true">#</a> snabbdom</h3><ul><li><code>patch(oldVnode, newVnode)</code></li><li>打补丁，把新节点中变化的内容渲染到真实 <code>DOM</code>，最后返回新节点作为下一次处理的旧节点</li><li>对比新旧 <code>VNode</code> 是否相同节点(节点的 <code>key</code> 和 <code>sel</code> 相同)</li><li>如果不是相同节点，删除之前的内容，重新渲染</li><li>如果是相同节点，再判断新的 <code>VNode</code> 是否有 <code>text</code>，如果有并且和 <code>oldVnode</code> 的 <code>text</code> 不同，直接更 新文本内容</li><li>如果新的 <code>VNode</code> 有 <code>children</code>，判断子节点是否有变化，判断子节点的过程使用的就是 <code>diff</code> 算法</li><li><code>diff</code> 过程只进行同层级比较</li></ul><p><img src="https://s.poetries.work/images/20210329091820.png" alt=""></p><h3 id="init" tabindex="-1"><a class="header-anchor" href="#init" aria-hidden="true">#</a> init</h3><ul><li>功能: <code>init(modules, domApi)</code>，返回 <code>patch()</code>函数(高阶函数)</li><li>为什么要使用高阶函数? <ul><li>因为 <code>patch()</code> 函数再外部会调用多次，每次调用依赖一些参数，比如: <code>modules/domApi/cbs</code></li><li>通过高阶函数让 <code>init()</code> 内部形成闭包，返回的 <code>patch()</code> 可以访问到 <code>modules/domApi/cbs</code>，而 不需要重新创建</li></ul></li><li><code>init()</code> 在返回 <code>patch()</code> 之前，首先收集了所有模块中的钩子函数存储到 <code>cbs</code> 对象中</li></ul><blockquote><p>源码位置:<code>src/init.ts</code></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>export function init (modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) {
  let i: number
  let j: number
  const cbs: ModuleHooks = {
    create: [],
    update: [],
    remove: [],
    destroy: [],
    pre: [],
    post: []
  }

  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi

  for (i = 0; i &lt; hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j &lt; modules.length; ++j) {
      const hook = modules[j][hooks[i]]
      if (hook !== undefined) {
        (cbs[hooks[i]] as any[]).push(hook)
      }
    }
  }
  ...

  return function patch (oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node
    const insertedVnodeQueue: VNodeQueue = []
    for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]()

    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode)
    }

    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue)
    } else {
      elm = oldVnode.elm!
      parent = api.parentNode(elm) as Node

      createElm(vnode, insertedVnodeQueue)

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))
        removeVnodes(parent, [oldVnode], 0, 0)
      }
    }

    for (i = 0; i &lt; insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])
    }
    for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i]()
    return vnode
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="patch" tabindex="-1"><a class="header-anchor" href="#patch" aria-hidden="true">#</a> patch</h3><ul><li>功能: <ul><li>传入新旧 <code>VNode</code>，对比差异，把差异渲染到 <code>DOM</code></li><li>返回新的 <code>VNode</code>，作为下一次 <code>patch()</code> 的 <code>oldVnode</code></li></ul></li><li>执行过程: <ul><li>首先执行模块中的钩子函数 <code>pre</code></li><li>如果 <code>oldVnode</code> 和 <code>vnode</code> 相同(<code>key</code> 和 <code>sel</code> 相同) <ul><li>调用 <code>patchVnode()</code>，找节点的差异并更新 <code>DOM</code></li></ul></li><li>如果 <code>oldVnode</code> 是 <code>DOM</code> 元素 <ul><li>把 <code>DOM</code> 元素转换成 <code>oldVnode</code></li><li>调用 <code>createElm()</code> 把 <code>vnode</code> 转换为真实 <code>DOM</code>，记录到 <code>vnode.elm</code></li><li>把刚创建的 <code>DOM</code> 元素插入到 <code>parent</code> 中</li><li>移除老节点</li><li>触发用户设置的 <code>create</code> 钩子函数</li></ul></li></ul></li></ul><p>源码位置:<code>src/snabbdom.ts</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>return function patch (oldVnode: VNode | Element, vnode: VNode): VNode {
  let i: number, elm: Node, parent: Node
  // 保存新插入节点的队列，为了触发钩子函数
  const insertedVnodeQueue: VNodeQueue = []
  // 执行模块的 pre 钩子函数
  for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]()

  // 如果 oldVnode 不是 VNode，创建 VNode 并设置 elm
  if (!isVnode(oldVnode)) {
    // 把 DOM 元素转换成空的 VNode
    oldVnode = emptyNodeAt(oldVnode)
  }
  // 如果新旧节点是相同节点(key 和 sel 相同)
  if (sameVnode(oldVnode, vnode)) {
    // 找节点的差异并更新 DOM
    patchVnode(oldVnode, vnode, insertedVnodeQueue)
  } else {
    // 如果新旧节点不同，vnode 创建对应的 DOM
    // 获取当前的 DOM 元素
    elm = oldVnode.elm!
    parent = api.parentNode(elm) as Node
    // 触发 init/create 钩子函数,创建 DOM
    createElm(vnode, insertedVnodeQueue)

    if (parent !== null) {
      // 如果父节点不为空，把 vnode 对应的 DOM 插入到文档中
      api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))
      // 移除老节点
      removeVnodes(parent, [oldVnode], 0, 0)
    }
  }
  // 执行用户设置的 insert 钩子函数
  for (i = 0; i &lt; insertedVnodeQueue.length; ++i) {
    insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])
  }
  // 执行模块的 post 钩子函数
  for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i]()
  // 返回 vnode
  return vnode
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="createelm" tabindex="-1"><a class="header-anchor" href="#createelm" aria-hidden="true">#</a> createElm</h3><ul><li><p>功能:</p><ul><li><code>createElm(vnode, insertedVnodeQueue)</code>，返回创建的 <code>DOM</code> 元素</li><li>创建 <code>vnode</code> 对应的 <code>DOM</code> 元素</li></ul></li><li><p>执行过程:</p></li><li><p>首先触发用户设置的 <code>init</code> 钩子函数</p></li><li><p>如果选择器是<code>!</code>，创建评论节点</p></li><li><p>如果选择器为空，创建文本节点</p></li><li><p>如果选择器不为空</p><ul><li>解析选择器，设置标签的 <code>id</code> 和 <code>class</code> 属性</li><li>执行模块的 <code>create</code> 钩子函数</li><li>如果 <code>vnode</code> 有 <code>children</code>，创建子 <code>vnode</code> 对应的 <code>DOM</code>，追加到 <code>DOM</code> 树</li><li>如果 <code>vnode</code> 的 <code>text</code> 值是 <code>string/number</code>，创建文本节点并追击到 <code>DOM</code> 树</li><li>执行用户设置的 <code>create</code> 钩子函数</li><li>如果有用户设置的 <code>insert</code> 钩子函数，把 <code>vnode</code> 添加到队列中</li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function createElm (vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
  let i: any
  let data = vnode.data
  if (data !== undefined) {
    // 执行用户设置的 init 钩子函数
    const init = data.hook?.init
    if (isDef(init)) {
      init(vnode)
      data = vnode.data
    }
  }
  const children = vnode.children
  const sel = vnode.sel
  if (sel === &#39;!&#39;) {
    // 如果选择器是!，创建评论节点
    if (isUndef(vnode.text)) {
      vnode.text = &#39;&#39;
    }
    vnode.elm = api.createComment(vnode.text!)
  } else if (sel !== undefined) {
    // Parse selector
    // 如果选择器不为空
    // 解析选择器
    // Parse selector
    const hashIdx = sel.indexOf(&#39;#&#39;)
    const dotIdx = sel.indexOf(&#39;.&#39;, hashIdx)
    const hash = hashIdx &gt; 0 ? hashIdx : sel.length
    const dot = dotIdx &gt; 0 ? dotIdx : sel.length
    const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel
    const elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = data.ns)
      ? api.createElementNS(i, tag, data)
      : api.createElement(tag, data)
    if (hash &lt; dot) elm.setAttribute(&#39;id&#39;, sel.slice(hash + 1, dot))
    if (dotIdx &gt; 0) elm.setAttribute(&#39;class&#39;, sel.slice(dot + 1).replace(/\./g, &#39; &#39;))
    // 执行模块的 create 钩子函数
    for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode)
    // 如果 vnode 中有子节点，创建子 vnode 对应的 DOM 元素并追加到 DOM 树上
    if (is.array(children)) {
      for (i = 0; i &lt; children.length; ++i) {
        const ch = children[i]
        if (ch != null) {
          api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue))
        }
      }
    } else if (is.primitive(vnode.text)) {
      // 如果 vnode 的 text 值是 string/number，创建文本节点并追加到 DOM 树
      api.appendChild(elm, api.createTextNode(vnode.text))
    }
    const hook = vnode.data!.hook
    if (isDef(hook)) {
      // 执行用户传入的钩子 create
      hook.create?.(emptyNode, vnode)
      if (hook.insert) {
        // 把 vnode 添加到队列中，为后续执行 insert 钩子做准备
        insertedVnodeQueue.push(vnode)
      }
    }
  } else {
    // 如果选择器为空，创建文本节点
    vnode.elm = api.createTextNode(vnode.text!)
  }
  // 返回新创建的 DOM
  return vnode.elm
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="patchvnode" tabindex="-1"><a class="header-anchor" href="#patchvnode" aria-hidden="true">#</a> patchVnode</h3><ul><li>功能: <ul><li><code>patchVnode(oldVnode, vnode, insertedVnodeQueue)</code></li><li>对比 <code>oldVnode</code> 和 <code>vnode</code> 的差异，把差异渲染到 <code>DOM</code></li></ul></li><li>执行过程: <ul><li>首先执行用户设置的 <code>prepatch</code> 钩子函数</li><li>执行 <code>create</code> 钩子函数 <ul><li>首先执行模块的 <code>create</code>钩子函数</li><li>然后执行用户设置的 <code>create</code> 钩子函数</li></ul></li><li>如果 <code>vnode.text</code> 未定义 <ul><li>如果 <code>oldVnode.children</code> 和 <code>vnode.children</code> 都有值 <ul><li>调用 <code>updateChildren()</code></li><li>使用 <code>diff</code> 算法对比子节点，更新子节点</li></ul></li><li>如果 <code>vnode.children</code> 有值， <code>oldVnode.children</code> 无值 <ul><li>清空 <code>DOM</code> 元素</li><li>调用 <code>addVnodes()</code> ，批量添加子节点</li></ul></li><li>如果 <code>oldVnode.children</code> 有值， <code>vnode.children</code> 无值 <ul><li>调用 <code>removeVnodes()</code> ，批量移除子节点</li></ul></li><li>如果 <code>oldVnode.text</code> 有值 <ul><li>清空 <code>DOM</code> 元素的内容</li></ul></li></ul></li><li>如果设置了 <code>vnode.text</code> 并且和和 <code>oldVnode.text</code> 不等 <ul><li>如果老节点有子节点，全部移除</li><li>设置 <code>DOM</code> 元素的 <code>textContent</code> 为 <code>vnode.text</code></li></ul></li><li>最后执行用户设置的 <code>postpatch</code> 钩子函数</li></ul></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function patchVnode (oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) {
  const hook = vnode.data?.hook
  // 首先执行用户设置的 prepatch 钩子函数
  hook?.prepatch?.(oldVnode, vnode)
  const elm = vnode.elm = oldVnode.elm!
  const oldCh = oldVnode.children as VNode[]
  const ch = vnode.children as VNode[]
  // 如果新老 vnode 相同返回
  if (oldVnode === vnode) return
  if (vnode.data !== undefined) {
    // 执行模块的 update 钩子函数
    for (let i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
    // 执行用户设置的 update 钩子函数
    vnode.data.hook?.update?.(oldVnode, vnode)
  }
  // 如果 vnode.text 未定义
  if (isUndef(vnode.text)) {
    // 如果新老节点都有 children
    if (isDef(oldCh) &amp;&amp; isDef(ch)) {
      // 使用 diff 算法对比子节点，更新子节点
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue)
    } else if (isDef(ch)) {
      // 如果新节点有 children，老节点没有 children
      // 如果老节点有text，清空dom 元素的内容
      if (isDef(oldVnode.text)) api.setTextContent(elm, &#39;&#39;)
      // 批量添加子节点
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
    } else if (isDef(oldCh)) {
      // 如果老节点有children，新节点没有children
      // 批量移除子节点
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      // 如果老节点有 text，清空 DOM 元素
      api.setTextContent(elm, &#39;&#39;)
    }
  } else if (oldVnode.text !== vnode.text) {
    // 如果没有设置 vnode.text
    if (isDef(oldCh)) {
      // 如果老节点有 children，移除
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    }
    // 设置 DOM 元素的 textContent 为 vnode.text
    api.setTextContent(elm, vnode.text!)
  }
  // 最后执行用户设置的 postpatch 钩子函数
  hook?.postpatch?.(oldVnode, vnode)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="updatechildren" tabindex="-1"><a class="header-anchor" href="#updatechildren" aria-hidden="true">#</a> updateChildren</h3><ul><li>功能: <ul><li><code>diff</code> 算法的核心，对比新旧节点的 <code>children</code>，更新 <code>DOM</code></li></ul></li><li>执行过程:</li><li>要对比两棵树的差异，我们可以取第一棵树的每一个节点依次和第二课树的每一个节点比 较，但是这样的时间复杂度为 <code>O(n^3)</code></li><li>在 <code>DOM</code> 操作的时候我们很少很少会把一个父节点移动/更新到某一个子节点</li><li>因此只需要找同级别的子节点依次比较，然后再找下一级别的节点比较，这样算法的时间复 杂度为 <code>O(n)</code></li></ul><p><img src="https://s.poetries.work/images/20210329092027.png" alt=""></p><ul><li>在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍 历的过程中移动索引</li><li>在对开始和结束节点比较的时候，总共有四种情况 <ul><li><code>oldStartVnode / newStartVnode</code> (旧开始节点 / 新开始节点)</li><li><code>oldEndVnode / newEndVnode</code> (旧结束节点 / 新结束节点)</li><li><code>oldStartVnode / oldEndVnode</code> (旧开始节点 / 新结束节点)</li><li><code>oldEndVnode / newStartVnode</code> (旧结束节点 / 新开始节点)</li></ul></li></ul><p><img src="https://s.poetries.work/images/20210329092301.png" alt=""></p><ul><li>开始节点和结束节点比较，这两种情况类似 <ul><li><code>oldStartVnode / newStartVnode</code> (旧开始节点 / 新开始节点)</li><li><code>oldEndVnode / newEndVnode</code> (旧结束节点 / 新结束节点)</li></ul></li><li>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是 <code>sameVnode</code> (<code>key</code> 和 <code>sel</code> 相同) <ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li><li>把旧开始和新开始索引往后移动 <code>oldStartIdx++ / oldEndIdx++</code></li></ul></li></ul><p><img src="https://s.poetries.work/images/20210329092430.png" alt=""></p><ul><li><code>oldStartVnode / newEndVnode</code> (旧开始节点 / 新结束节点) 相同 <ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li><li>把 <code>oldStartVnode</code> 对应的 <code>DOM</code> 元素，移动到右边 <ul><li>更新索引</li></ul></li></ul></li></ul><p><img src="https://s.poetries.work/images/20210329092820.png" alt=""></p><ul><li><code>oldEndVnode / newStartVnode</code> (旧结束节点 / 新开始节点) 相同 <ul><li>调用 <code>patchVnode()</code> 对比和更新节点</li><li>把 <code>oldEndVnode</code> 对应的 <code>DOM</code> 元素，移动到左边</li><li>更新索引</li></ul></li></ul><p><img src="https://s.poetries.work/images/20210329093025.png" alt=""></p><ul><li>如果不是以上四种情况 <ul><li>遍历新节点，使用 <code>newStartNode</code> 的 <code>key</code> 在老节点数组中找相同节点</li><li>如果没有找到，说明 <code>newStartNode</code> 是新节点 <ul><li>创建新节点对应的 DOM 元素，插入到 DOM 树中</li></ul></li><li>如果找到了 <ul><li>判断新节点和找到的老节点的 <code>sel</code> 选择器是否相同</li><li>如果不相同，说明节点被修改了 <ul><li>重新创建对应的 <code>DOM</code> 元素，插入到 DOM 树中</li></ul></li><li>如果相同，把 <code>elmToMove</code> 对应的 DOM 元素，移动到左边</li></ul></li></ul></li></ul><p><img src="https://s.poetries.work/images/20210329093137.png" alt=""></p><ul><li>循环结束 <ul><li>当老节点的所有子节点先遍历完 (<code>oldStartIdx &gt; oldEndIdx</code>)，循环结束</li><li>新节点的所有子节点先遍历完 (<code>newStartIdx &gt; newEndIdx</code>)，循环结束</li></ul></li><li>如果老节点的数组先遍历完(<code>oldStartIdx &gt; oldEndIdx</code>)，说明新节点有剩余，把剩余节点批量插入到右边</li></ul><p><img src="https://s.poetries.work/images/20210329093302.png" alt=""></p><ul><li>如果新节点的数组先遍历完(<code>newStartIdx &gt; newEndIdx</code>)，说明老节点有剩余，把剩余节点批 量删除</li></ul><p><img src="https://s.poetries.work/images/20210329093414.png" alt=""></p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/principle/JavaScript.html" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.12353158.js" defer></script>
  </body>
</html>
